<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=2" name="viewport"/>
<meta content="#222" name="theme-color"/>
<meta content="Hexo 7.2.0" name="generator"/><br/><meta content="Lua, 编程语言, 数据结构, Lua, 数据结构, 表, 数组, 矩阵, 多维数组, 稀疏矩阵, 队列, 集合" name="keywords"/><br/><meta content="Lua, 编程语言, 数据结构, Lua, 数据结构, 表, 数组, 矩阵, 多维数组, 稀疏矩阵, 队列, 集合" name="keywords"/><br/><meta content="Lua, 编程语言, 数据结构, Lua, 数据结构, 表, 数组, 矩阵, 多维数组, 稀疏矩阵, 队列, 集合" name="keywords"/>
<link href="/images/favicon-16x16-next.png" rel="apple-touch-icon" sizes="180x180"/>
<link href="/images/favicon-32x32-next.png" rel="icon" sizes="32x32" type="image/png"/>
<link href="/images/favicon-16x16-next.png" rel="icon" sizes="16x16" type="image/png"/>
<link color="#222" href="/images/favicon-32x32-next.png" rel="mask-icon"/>
<meta content="7f4abda1472881d3" name="yandex-verification"/>
<meta content="5lU3qr1ysBwet0Uc" name="baidu-site-verification"/>
<link href="/css/main.css" rel="stylesheet"/>
<link href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext" rel="stylesheet"/>
<link href="/lib/font-awesome/css/all.min.css" rel="stylesheet"/>
<link href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css" rel="stylesheet"/>
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lengmo714.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>
<meta content="Lua语言中的表并不是一种数据结构，它们是其他数据结构的基础。我们可以用Lua语言中的表来实现其他语言提供的数据结构，如数组、记录、列表、队列、集合等。而且，用Lua语言中的表实现这些数据结构还很高效。" name="description"/>
<meta content="article" property="og:type"/>
<meta content="Lua数据结构详解：表、数组与矩阵实现" property="og:title"/>
<meta content="https://lengmo714.top/42473.html" property="og:url"/>
<meta content="南锋" property="og:site_name"/>
<meta content="Lua语言中的表并不是一种数据结构，它们是其他数据结构的基础。我们可以用Lua语言中的表来实现其他语言提供的数据结构，如数组、记录、列表、队列、集合等。而且，用Lua语言中的表实现这些数据结构还很高效。" property="og:description"/>
<meta content="zh_CN" property="og:locale"/>
<meta content="2020-04-18T10:44:36.000Z" property="article:published_time"/>
<meta content="2024-11-14T17:08:29.637Z" property="article:modified_time"/>
<meta content="南锋" property="article:author"/>
<meta content="Lua" property="article:tag"/>
<meta content="summary" name="twitter:card"/>
<link href="https://lengmo714.top/42473.html" rel="canonical"/>
<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Lua数据结构详解：表、数组与矩阵实现 | 南锋</title>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-XDK58GP86Z"></script>
<script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XDK58GP86Z');
      }
    </script>
<noscript>
<style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage">
<div class="container use-motion">
<div class="headband"></div>
<header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
<div class="header-inner"><div class="site-brand-container">
<div class="site-nav-toggle">
<div aria-label="切换导航栏" class="toggle">
<span class="toggle-line toggle-line-first"></span>
<span class="toggle-line toggle-line-middle"></span>
<span class="toggle-line toggle-line-last"></span>
</div>
</div>
<div class="site-meta">
<a class="brand" href="/" rel="start">
<span class="logo-line-before"><i></i></span>
<h1 class="site-title">南锋</h1>
<span class="logo-line-after"><i></i></span>
</a>
<p class="site-subtitle" itemprop="description">南奔万里空，脱死锋镝余</p>
</div>
<div class="site-nav-right">
<div class="toggle popup-trigger">
<i class="fa fa-search fa-fw fa-lg"></i>
</div>
</div>
</div>
<nav class="site-nav">
<ul class="main-menu menu" id="menu">
<li class="menu-item menu-item-home">
<a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>
</li>
<li class="menu-item menu-item-about">
<a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>
</li>
<li class="menu-item menu-item-tags">
<a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>
</li>
<li class="menu-item menu-item-categories">
<a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>
</li>
<li class="menu-item menu-item-archives">
<a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>
</li>
<li class="menu-item menu-item-search">
<a class="popup-trigger" role="button"><i class="fa fa-search fa-fw"></i>搜索
        </a>
</li>
</ul>
</nav>
<div class="search-pop-overlay">
<div class="popup search-popup">
<div class="search-header">
<span class="search-icon">
<i class="fa fa-search"></i>
</span>
<div class="search-input-container">
<input autocapitalize="off" autocomplete="off" class="search-input" placeholder="搜索..." spellcheck="false" type="search"/>
</div>
<span class="popup-btn-close">
<i class="fa fa-times-circle"></i>
</span>
</div>
<div id="search-result">
<div id="no-result">
<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
</div>
</div>
</div>
</div>
</div>
</header>
<div class="reading-progress-bar"></div>
<a class="book-mark-link book-mark-link-fixed" role="button"></a>
<main class="main">
<div class="main-inner">
<div class="content-wrap">
<div class="content post posts-expand">
<article class="post-block" itemscope="" itemtype="http://schema.org/Article" lang="zh-CN">
<link href="https://lengmo714.top/42473.html" itemprop="mainEntityOfPage"/>
<span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
<meta content="/images/IMG_3307.JPG" itemprop="image"/>
<meta content="南锋" itemprop="name"/>
<meta content="记录工作中的一些笔记以及一些有趣的代码,致力于成为一个优秀的程序员" itemprop="description"/>
</span>
<span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
<meta content="南锋" itemprop="name"/>
</span>
<header class="post-header">
<h1 class="post-title" itemprop="name headline">
          Lua数据结构详解：表、数组与矩阵实现
        </h1>
<div class="post-meta">
<span class="post-meta-item">
<span class="post-meta-item-icon">
<i class="far fa-calendar"></i>
</span>
<span class="post-meta-item-text">发表于</span>
<time datetime="2020-04-18T18:44:36+08:00" itemprop="dateCreated datePublished" title="创建时间：2020-04-18 18:44:36">2020-04-18</time>
</span>
<span class="post-meta-item">
<span class="post-meta-item-icon">
<i class="far fa-calendar-check"></i>
</span>
<span class="post-meta-item-text">更新于</span>
<time datetime="2024-11-15T01:08:29+08:00" itemprop="dateModified" title="修改时间：2024-11-15 01:08:29">2024-11-15</time>
</span>
<span class="post-meta-item">
<span class="post-meta-item-icon">
<i class="far fa-folder"></i>
</span>
<span class="post-meta-item-text">分类于</span>
<span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
<a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
</span>
</span>
<span class="post-meta-item leancloud_visitors" data-flag-title="Lua数据结构详解：表、数组与矩阵实现" id="/42473.html" title="阅读次数">
<span class="post-meta-item-icon">
<i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读次数：</span>
<span class="leancloud-visitors-count"></span>
</span>
<span class="post-meta-item">
<span class="post-meta-item-icon">
<i class="far fa-comment"></i>
</span>
<span class="post-meta-item-text">Valine：</span>
<a href="/42473.html#valine-comments" itemprop="discussionUrl" title="valine">
<span class="post-comments-count valine-comment-count" data-xid="/42473.html" itemprop="commentCount"></span>
</a>
</span>
</div>
</header>
<div class="post-body" itemprop="articleBody">
<p>Lua语言中的表并不是一种数据结构，它们是其他数据结构的基础。我们可以用Lua语言中的表来实现其他语言提供的数据结构，如数组、记录、列表、队列、集合等。而且，用Lua语言中的表实现这些数据结构还很高效。</p>
<span id="more"></span>
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"></script>
<p><ins class="adsbygoogle" data-ad-client="ca-pub-3160571902547760" data-ad-format="fluid" data-ad-layout="in-article" data-ad-slot="8630948880" style="display:block; text-align:center;"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>在像C和Pascal这样更加传统的语言中，通常使用数组和列表来实现大多数数据结构。虽然在Lua语言中也可以使用表来实现数组和列表，但表实际上比数组和列表强大很多。使用表时，很多算法可以被简化。例如，由于表本身就支持任意数据类型的直接访问，因此我们很少在Lua语言中编写搜索算法。</p>
<h2 id="数组"><a class="headerlink" href="#数组" title="数组"></a>数组</h2><p>在Lua语言中，简单地使用整数来索引表即可实现数组。因此，数组的大小不用非得是固定的，而是可以按需增长的。通常，在初始化数组时就间接地定义了数组的大小。例如，在执行了以下的代码后，任何访问范围1~1000之外的元素都会返回nil而不是0：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = {}</span><br/><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">1000</span> <span class="keyword">do</span> </span><br/><span class="line">	a[i] = <span class="number">0</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>长度运算符（#）正是基于此来计算数组大小的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#a)</span><br/></pre></td></tr></table></figure>
<p>可以使用0、1或其他任何值来作为数组的起始索引：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">a = {}</span><br/><span class="line"><span class="keyword">for</span> i = <span class="number">-5</span> , <span class="number">5</span> <span class="keyword">do</span></span><br/><span class="line">	a[i] = <span class="number">0</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>不过，在Lua语言中一般以1作为数组的起始索引，Lua语言的标准库和长度运算符都遵循这个惯例。如果数组的索引不从1开始，那就不能使用这些机制。<br/>可以通过表构造器在一句表达式中同时创建和初始化数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">squares = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">12</span>}</span><br/></pre></td></tr></table></figure>
<p>这种表构造器根据需求要多大就能多大。在Lua语言中，利用数据描述文件创建包含几百万个元素组成的构造器很常见。</p>
<h2 id="矩阵及多维数组"><a class="headerlink" href="#矩阵及多维数组" title="矩阵及多维数组"></a>矩阵及多维数组</h2><p>在Lua语言中，有两种方式来表示矩阵。第一种方式就是使用一个不规则数组，即数组的数组，也就是一个所有元素均是另一个表的表。例如，可以使用如下代码来创建一个全0元素的N*M维矩阵：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> , N <span class="keyword">do</span></span><br/><span class="line">	<span class="keyword">local</span> row = {}</span><br/><span class="line">	mt[i] = row</span><br/><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, M <span class="keyword">do</span></span><br/><span class="line">		row[j] = <span class="number">0</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>由于表在Lua语言中是一种对象，因此在创建矩阵时必须显示地创建每一行。一方面，这比在C语言中直接声明一个多维数组更加具体；另一方面，这也给我们提供了很多的灵活性。例如，只需将前例中的内层循环改为for j = 1,i do … end就可以创建一个三角矩阵。使用这套代码，三角矩阵较原来的矩阵可以节约一半的内存。<br/>在Lua中表示矩阵的第二种方式是将两个索引合并为一个。典型情况下，我们通过将第一个索引乘以一个合适的常量再加上第二个索引来实现这种效果。在这种方式下，我们可以使用以下的代码来创建一个全0元素的N*M维矩阵：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, N <span class="keyword">do</span></span><br/><span class="line">	<span class="keyword">local</span> aux = (i <span class="number">-1</span>) * M </span><br/><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, M <span class="keyword">do</span></span><br/><span class="line">		mt[aux = j] = <span class="number">0</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>应用程序中经常会用到稀疏矩阵，这种矩阵中的大多数元素是0或nil。例如，我们可以使用邻接矩阵来表示图。当矩阵出元素的值为x时，表示图中的节点m和n是相连的，连接的权重为x；若上述的两个节点不相连，那么矩阵的 (m,n)处元素的值为nil。如果要表示一个具有1万个节点的图，那么需要一个包含1亿个元素的矩阵，但是其中大约只有5万个元素不为nil。许多有关数据结构的书籍都会深入地讨论如何实现这种稀疏矩阵而不必浪费800MB内存空间，但在Lua语言中却很少需要用到那些技巧。这是因为，我们使用表实现数组而表本来就是稀疏的。在第一种实现中，需要1万个表，每个表5个元素，总共5万个元素。在第二种实现中，只需要一个表，其中包含5万个元素。无论哪种实现，都是只非nil的元素才占用空间。<br/>由于在有效元素之间存在空间，因此不能对稀疏举着使用长度运算符。这没什么大不了的，即使我们能够使用长度运算符，最好也不要那么做。对于大多数针对稀疏矩阵的操作来说，遍历空元素是非常低效的。相反，可以使用pairs来只遍历非nil的元素。例如，考虑如何进行由不规则数组表示的稀疏矩阵的矩阵乘法。<br/>假设矩阵a[M,K]乘以矩阵b[K,N]的结果为矩阵c[M,N]，常见的矩阵相乘算法形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, M <span class="keyword">do</span></span><br/><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, N <span class="keyword">do</span></span><br/><span class="line">		c[i][j] = <span class="number">0</span></span><br/><span class="line">		<span class="keyword">for</span> k = <span class="number">1</span>,K <span class="keyword">do</span></span><br/><span class="line">			c[i][j] = c[i][j] + a[i][k] * b[k][j]</span><br/><span class="line">		<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>外层的两个循环遍历了整个结果矩阵，然后使用内层循环计算每一个元素的值。<br/>对于使用不规则矩阵实现的稀疏矩阵，内层循环会有问题。由于内层循环遍历的是一列b而不是一行，因此不能再此处使用pairs：这个循环必须遍历每一行来检查对应的行是否在对应列中有元素。除了遍历了少量非0元素以外，这个循环还遍历了所有的0元素。（由于不知道元素的空间位置，所以在其他场景下遍历一列可也能会有问题。）<br/>以下的算法与之前的示例非常类似，但是该算法调换了两个内层循环的顺序。通过这个简单的调整，该算法避免了遍历列：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, M <span class="keyword">do</span></span><br/><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span> , K <span class="keyword">do</span></span><br/><span class="line">		<span class="keyword">for</span> j = <span class="number">1</span>, N <span class="keyword">do</span></span><br/><span class="line">			c[i][j] = c[i][j] + a[i][k] * b [k][j]</span><br/><span class="line">		<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>这样，中间的一层循环遍历行a[i]，而内层循环遍历行b[k]。这两个遍历都可以使用pairs来实现遍历非0元素。由于一个空的稀疏矩阵本身就是使用0填充的，所以对结果矩阵c的初始化没有任何问题。<br/>下面代码战士了上述算法的完整实现，其中使用了pairs来处理稀疏矩阵的元素。这种实现只访问非nil元素，同时结果也是稀疏矩阵。此外，下面的代码还删去了结果中偶然为0的元素。</p>
<blockquote>
<p>稀疏矩阵相乘</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mult</span><span class="params">(a,b)</span></span></span><br/><span class="line">	<span class="keyword">local</span> c = {}</span><br/><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br/><span class="line">		<span class="keyword">local</span> resultline = {}</span><br/><span class="line">		<span class="keyword">for</span> k ,va <span class="keyword">in</span> <span class="built_in">pairs</span>(a[i]) <span class="keyword">do</span></span><br/><span class="line">			<span class="keyword">for</span> j , vb <span class="keyword">in</span> <span class="built_in">pairs</span>(b[k]) <span class="keyword">do</span></span><br/><span class="line">				<span class="keyword">local</span> res = (resultline[j] <span class="keyword">or</span> <span class="number">0</span> ) + va * vb</span><br/><span class="line">				resultline[j] = (res ~= <span class="number">0</span>) <span class="keyword">and</span> res  <span class="keyword">or</span> <span class="literal">nil</span></span><br/><span class="line">			<span class="keyword">end</span></span><br/><span class="line">		<span class="keyword">end</span></span><br/><span class="line">		c[i] = resultline</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">return</span> c</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<h2 id="链表"><a class="headerlink" href="#链表" title="链表"></a>链表</h2><p>由于表是动态对象，所以在Lua语言中可以很容易地实现链表。我们可以把每个节点用一个表来表示，链接则为一个包含指向其他表的引用的简单表字段。例如，让我们实现一个单链表，其中每个节点具有两个字段value和next。最简单的变量就是根节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">list = <span class="literal">nil</span></span><br/></pre></td></tr></table></figure>
<p>要在表头插入一个值为v的元素，可以使用如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">list = {<span class="built_in">next</span> = list, value = v}</span><br/></pre></td></tr></table></figure>
<p>可以通过如下的方式遍历链表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> l = list</span><br/><span class="line"><span class="keyword">while</span> l <span class="keyword">do</span></span><br/><span class="line">	visit l.value</span><br/><span class="line">	l = l.<span class="built_in">next</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>诸如双向链表或环形表等其他类型的链表也很容易实现。不过，由于通常无须链表即可用更简单的方式来表示数据，所以在Lua语言中很少需要用到这些数据结构。例如，我们可以通过一个无界数组来表示栈。</p>
<h2 id="队列及双端队列"><a class="headerlink" href="#队列及双端队列" title="队列及双端队列"></a>队列及双端队列</h2><p>在Lua语言中实现队列的一种简单方法是使用table标准库中的函数insert和remove。</p>
<blockquote>
<p>示例： 一个双端队列</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listNew</span><span class="params">()</span></span></span><br/><span class="line">	<span class="keyword">return</span> {first = <span class="number">0</span> ,last = <span class="number">1</span>}</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushFisrt</span><span class="params">(list,value)</span></span></span><br/><span class="line">	<span class="keyword">local</span> first = list.first - <span class="number">1</span></span><br/><span class="line">	list.first = first</span><br/><span class="line">	list[first] = value</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushLast</span> <span class="params">(list ,value)</span></span></span><br/><span class="line">	<span class="keyword">local</span> last = list.last + <span class="number">1</span></span><br/><span class="line">	list.last = last</span><br/><span class="line">	list[last] = value</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popFirst</span><span class="params">(list)</span></span></span><br/><span class="line">	<span class="keyword">local</span> first = list.first</span><br/><span class="line">	<span class="keyword">if</span> first &gt; list.last <span class="keyword">then</span></span><br/><span class="line">		<span class="built_in">error</span>(<span class="string">"list is empty"</span>)</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">local</span> value = list[first]</span><br/><span class="line">	list[first] = <span class="literal">nil</span></span><br/><span class="line">	list.first = first + <span class="number">1</span></span><br/><span class="line">	<span class="keyword">return</span> value</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popLast</span><span class="params">(list)</span></span></span><br/><span class="line">	<span class="keyword">local</span> last = list.last</span><br/><span class="line">	<span class="keyword">if</span> list.first &gt; last <span class="keyword">then</span></span><br/><span class="line">		<span class="built_in">error</span>(<span class="string">"list is empty"</span>)</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">local</span> value = list[last]</span><br/><span class="line">	list[last] = <span class="literal">nil</span></span><br/><span class="line">	list.last = last  - <span class="number">1</span></span><br/><span class="line">	<span class="keyword">return</span> value</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>如果希望严格地遵循队列的规范使用这个结构，那么就只能调用pushLast和popFirst函数，first和last都会不断增长。不过，由于我们在Lua语言中使用表来表示数组，所以我们既可以在1-20的范围内对数组进行索引，也可以在16777201-16777220的范围内索引数组。对于一个64为整型数而言，以每秒1000万次的速度进行插入也需要运行3万年才会发生溢出的问题。</p>
<h2 id="反向表"><a class="headerlink" href="#反向表" title="反向表"></a>反向表</h2><p>我们很少在Lua语言中进行索引操作。但是，我们使用被称为索引表或反向表的数据结构。<br/>假设有一个存放了一周每一天名称的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">days = {<span class="string">"Sunday"</span>,<span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>,<span class="string">"Wednesday"</span>,<span class="string">"Thursday"</span>,<span class="string">"Friday"</span>,<span class="string">"Saturday"</span>}</span><br/></pre></td></tr></table></figure>
<p>如果想要将一周每一天的名称转换为其在一周里的位置，那么可以通过索引这表来寻找指定的名称。不过，一种更高效的方式是构造一个方向表，假定为revDays，该表中的索引为一周每一天的名称而值为其在一周里的位置。这个表形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">revDays = {[<span class="string">"Sunday"</span>] = <span class="number">1</span> ,[<span class="string">"Monday"</span>] = <span class="number">2</span>,[<span class="string">"Tuesday"</span>] = <span class="number">3</span>,[<span class="string">"Wednesday"</span>] = <span class="number">4</span>,[<span class="string">"Thursday"</span>] = <span class="number">5</span>,[<span class="string">"Friday"</span>] = <span class="number">6</span>,[<span class="string">"Saturday"</span>] = <span class="number">7</span>}</span><br/></pre></td></tr></table></figure>
<p>然后，只需要直接在反向表中根据名称进行索引就可以了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">x = <span class="string">"Tuesday"</span></span><br/><span class="line"><span class="built_in">print</span>(revDays[x])				<span class="comment">-- 3</span></span><br/></pre></td></tr></table></figure>
<p>当然，这个反向表不同手工声明，可以从原始的表中自动地构造出方向标：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">revDays = {}</span><br/><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(days) <span class="keyword">do</span> </span><br/><span class="line">	revDays[v] = k</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>上例中的循环会对每个元素days进行赋值，变量k获取到的是键(1,2,…)而变量v获取到的是值(“Sunday”,”Monday”,…)。</p>
<h2 id="集合与包"><a class="headerlink" href="#集合与包" title="集合与包"></a>集合与包</h2><p> 假设我们想列出一个程序源代码中的所有标识符，同时过滤掉其中的保留字。一些C程序员可能倾向于使用字符串数组来表示保留字集合，然后搜索这个数组来决定某个单词是否属于该集合。为了提高搜索的速度，他们还可能使用二叉树来表示该集合。<br/>在Lua语言中，还可以用一中高效且简单的方式来表示这类集合，即集合元素作为索引放入表中。那么，对于指定的元素无须再搜索表，只需要该元素检索表并检查结果是否为nil即可。以上述需求为例，代码形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line">reserved = {[<span class="string">"while"</span>] = <span class="literal">true</span>, [<span class="string">"if"</span>] = <span class="literal">true</span>,[<span class="string">"else"</span>] = <span class="literal">true</span>,[<span class="string">"do"</span>] =<span class="literal">true</span>,}</span><br/><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">"[%a_][%w_]*"</span>) <span class="keyword">do</span></span><br/><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> reserved[w] <span class="keyword">then</span></span><br/><span class="line">			<span class="keyword">do</span> something with <span class="string">'w'</span></span><br/><span class="line">		<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>我们可以借助一个辅助函数来构造集合，使得初始化过程更清晰：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span><span class="params">(list)</span></span></span><br/><span class="line">	<span class="keyword">local</span> set = {}</span><br/><span class="line">	<span class="keyword">for</span> _, l <span class="keyword">in</span> <span class="built_in">ipairs</span>(list) <span class="keyword">do</span></span><br/><span class="line">		set[l] = <span class="literal">true</span> </span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">return</span> set</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">reserved = Set{<span class="string">"while"</span>,<span class="string">"end"</span>,<span class="string">"function"</span>,<span class="string">"local"</span>,}</span><br/></pre></td></tr></table></figure>
<p>我们还可以使用另一个集合来保存标识符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ids = {}</span><br/><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">"[%a_][%w_]*"</span>) <span class="keyword">do</span></span><br/><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> reserved[w] <span class="keyword">then</span></span><br/><span class="line">		ids[w] = <span class="literal">true</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="comment">-- 输出每一个标识符</span></span><br/><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">pairs</span>(ids) <span class="keyword">do</span> </span><br/><span class="line">	<span class="built_in">print</span>(w)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>包(bag)，也被称为多重集合，与普通集合的不同之处在于其中的元素可以出现多次。在Lua语言中，包的简单表示类似于此前集合的表示，只不过其中的每一个键都有一个对应的计数器。如果要插入一个元素，可以递增其计数器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> <span class="params">(bag,element)</span></span></span><br/><span class="line">	bag[element] = (bag[element] <span class="keyword">or</span> <span class="number">0</span>) + <span class="number">1</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>如果要删除一个元素，可以递减其计数器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> <span class="params">(bag,element)</span></span></span><br/><span class="line">	<span class="keyword">local</span> count = bag[element]</span><br/><span class="line">	bag[element] = (count <span class="keyword">and</span> count &gt; <span class="number">1</span>) <span class="keyword">and</span> count - <span class="number">1</span> <span class="keyword">or</span> <span class="literal">nil</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>只有当计数器存在且大于0时我们才会保留计数器。</p>
<h2 id="字符串缓冲区"><a class="headerlink" href="#字符串缓冲区" title="字符串缓冲区"></a>字符串缓冲区</h2><p>假设我们正在开发一段处理字符串的程序，比如逐行地读取一个文件。典型的代码可能形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> buff = <span class="string">""</span></span><br/><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br/><span class="line">	buff = buff .. line .. <span class="string">"\n"</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>虽然这段Lua语言代码看似能够正常工作，但实际上在处理大文件时却可能导致巨大的性能开销。<br/>这是为什么呢？为了搞清楚到底发生了什么，让我们想象一下读取循环中发生了什么。假设每行有20字节，当我们读取了大概2500行后，buff就会变成一个50KB大小的字符串。在Lua语言中进行字符串连接<code>buff..line.."\n"</code>时，会创建一个50020字节的新字符串，然后从buff中复制50000字节中到这个新字符串中。这样，对于后续的每一行，Lua语言都需要移动大概50KB且还在不断增长的内存。因此，该算法的时间复杂度是二次方的。在读取了100行以后，Lua语言就已经移动了至少5MB内存。当Lua语言完成了350KB的读取后，它已经至少移动了50GB的数据。<br/>对于较小的字符串，上述循环并没什么问题。当读取整个文件时，Lua语言提供了带有参数的函数io.read(“a”)来一次性读取整个文件。不过，有时候我们必须面对这个问题。Java提供了StringBuffer类还解决这个问题；而在Lua语言中，我们可以把一个表当做字符串缓冲区，其关键是使用函数table.concat，这个函数会将指定列表中的所有字符串连接起来并返回连接后的结果。使用函数concat可以这样重写上述循环：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = {}</span><br/><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br/><span class="line">	t[#t + <span class="number">1</span>] = line .. <span class="string">"\n"</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t)</span><br/></pre></td></tr></table></figure>
<p>之前的代码读取同样的文件需要超过半分钟，而上述实现则只需要不到0.05秒。我们还可以做得更好。函数concat还有第2个可选参数，用于指定插在字符串间的分隔符。有了这个分隔符，我们就不必在每行后插入换行符了。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = {}</span><br/><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br/><span class="line">	t[#t + <span class="number">1</span>] = line</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t,<span class="string">"\n"</span>) .. <span class="string">"\n"</span></span><br/></pre></td></tr></table></figure>
<p>虽然函数concat能够在字符串之间插入分隔符，但我们还需要增阿基最后一个换行符。最后一次字符串连接创建了结果字符串的一个副本，这个副本可能已经相当长了。虽然没有直接的选项能够让函数concat插入这个额外的分隔符，但我们可以想办法绕过，只需在字符串t后面添加一个空字符串就行了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">t[#t + <span class="number">1</span>] = <span class="string">""</span></span><br/><span class="line">s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t,<span class="string">"\n"</span>)</span><br/></pre></td></tr></table></figure>
<p>现在，正如我们所期望的那样，函数concat会在结果字符串的额最后添加一个换行符。</p>
<h2 id="图形"><a class="headerlink" href="#图形" title="图形"></a>图形</h2><p>像其他现代编程语言一眼个，Lua语言也允许开发人员使用多种实现表示图，每种实现都有其所使用的特定算法。<br/>我们使用一个由两个字段组成的表来表示每个节点，即name(节点名称)和adj(与此节点邻接的节点和集合)。由于我们会从一个文本文件中加载图对应的数据，所以需要能够根据节点的名称来寻找指定节点的方法。因此，我们使用了一个额外的表来建立节点和节点名称之间的映射。函数name2node可以根据指定节点的名称返回对应的节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">name2node</span><span class="params">(graph,name)</span></span></span><br/><span class="line">	<span class="keyword">local</span> node = graph[name]</span><br/><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br/><span class="line">		node = {name = name ,adj = {}}</span><br/><span class="line">		graph[name] = node </span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">return</span> node </span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<blockquote>
<p>示例：从文件中加载图</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readgraph</span><span class="params">()</span></span></span><br/><span class="line">	<span class="keyword">local</span> graph = {}</span><br/><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br/><span class="line">		<span class="comment">-- 把一行分割为两个名字</span></span><br/><span class="line">		<span class="keyword">local</span> namefrom, nameto = <span class="built_in">string</span>.<span class="built_in">match</span>(line,<span class="string">"(%S+)%s+(%S+)"</span>)</span><br/><span class="line">		<span class="comment">-- 找到对应的节点</span></span><br/><span class="line">		<span class="keyword">local</span> from = name2node(graph,namefrom)</span><br/><span class="line">		<span class="keyword">local</span> to = name2node(graph,nameto)</span><br/><span class="line">		<span class="comment">-- 把‘to’增加到邻接集合'from'中</span></span><br/><span class="line">		from.adj[to] = <span class="literal">true</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">return</span> graph</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>该函数逐行地读取一个文件，文件的每一行中有两个节点的名称，表示从第1个节点到第2个节点有一条边。对于每一行，调用函数string.match将一行中的两个节点的名称分开，然后根据名称找到对应的节点，最后将这些节点连接在一起。</p>
<blockquote>
<p>示例：寻找两个节点之间的路径</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findpath</span><span class="params">(curr,to,path,visited)</span></span></span><br/><span class="line">	<span class="built_in">path</span> = <span class="built_in">path</span> <span class="keyword">or</span> {}</span><br/><span class="line">	visited = visited <span class="keyword">or</span> {}</span><br/><span class="line">	<span class="keyword">if</span> visited[curr] <span class="keyword">then</span>   <span class="comment">-- 是否节点已被访问</span></span><br/><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>			<span class="comment">-- 不存在路径</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	visited[curr] = <span class="literal">true</span>    <span class="comment">-- 标记节点为已被访问</span></span><br/><span class="line">	<span class="built_in">path</span>[#<span class="built_in">path</span> + <span class="number">1</span>] = curr	<span class="comment">-- 增加到路径中</span></span><br/><span class="line">	<span class="keyword">if</span> curr == to <span class="keyword">then</span>		<span class="comment">-- 是否是最后一个节点</span></span><br/><span class="line">		<span class="keyword">return</span> <span class="built_in">path</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">	<span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">pairs</span>(curr.adj) <span class="keyword">do</span></span><br/><span class="line">		<span class="keyword">local</span> p = findpath(node,to ,<span class="built_in">path</span>,visited)</span><br/><span class="line">		<span class="keyword">if</span> p <span class="keyword">then</span></span><br/><span class="line">			<span class="keyword">return</span> p</span><br/><span class="line">		<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">path</span>)		<span class="comment">-- 从路径中删除节点</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
<p>函数findpath使用深度优先遍历搜索两个节点之间的路径。该函数的第1个参数是当前节点，第2个参数是目标节点，第3个参数用于保存从起点到当前节点的路径，最后一个参数为所有已被访问节点的几何。<br/>为了测试上述代码，我们编写一个打印一条路径的函数，再编写一些代码让上述所有代码跑起来：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printpath</span><span class="params">(path)</span></span></span><br/><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">path</span> <span class="keyword">do</span> </span><br/><span class="line">		<span class="built_in">print</span>(<span class="built_in">path</span>[i].name)</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">g = readgraph()</span><br/><span class="line">a = name2node(g,<span class="string">"a"</span>)</span><br/><span class="line">b = name2node(g,<span class="string">"b"</span>)</span><br/><span class="line">p = findpath(a,b)</span><br/><span class="line"><span class="keyword">if</span> p <span class="keyword">then</span> printpath(p) <span class="keyword">end</span></span><br/></pre></td></tr></table></figure>
</div>
<div class="reward-container">
<div></div>
<button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
<div id="qr" style="display: none;">
<div style="display: inline-block;">
<img alt="南锋 微信支付" src="/images/wechat.png"/>
<p>微信支付</p>
</div>
<div style="display: inline-block;">
<img alt="南锋 支付宝" src="/images/alipay.png"/>
<p>支付宝</p>
</div>
</div>
</div>
<div>
<ul class="post-copyright">
<li class="post-copyright-author">
<strong>本文作者： </strong>南锋
  </li>
<li class="post-copyright-link">
<strong>本文链接：</strong>
<a href="https://lengmo714.top/42473.html" title="Lua数据结构详解：表、数组与矩阵实现">https://lengmo714.top/42473.html</a>
</li>
<li class="post-copyright-license">
<strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>
<footer class="post-footer">
<div class="post-tags">
<a href="/tags/Lua/" rel="tag"><i class="fa fa-tag"></i> Lua</a>
</div>
<div class="post-nav">
<div class="post-nav-item">
<a href="/43504.html" rel="prev" title="深入解析Lua的位操作与字节处理：二进制数据的打包与解包">
<i class="fa fa-chevron-left"></i> 深入解析Lua的位操作与字节处理：二进制数据的打包与解包
    </a></div>
<div class="post-nav-item">
<a href="/7981.html" rel="next" title="Lua数据文件操作与序列化指南：从读取到安全存储">
      Lua数据文件操作与序列化指南：从读取到安全存储 <i class="fa fa-chevron-right"></i>
</a></div>
</div>
</footer>
</article>
</div>
<div class="comments" id="valine-comments"></div>
<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
<div class="toggle sidebar-toggle">
<span class="toggle-line toggle-line-first"></span>
<span class="toggle-line toggle-line-middle"></span>
<span class="toggle-line toggle-line-last"></span>
</div>
<aside class="sidebar">
<div class="sidebar-inner">
<ul class="sidebar-nav motion-element">
<li class="sidebar-nav-toc">
          文章目录
        </li>
<li class="sidebar-nav-overview">
          站点概览
        </li>
</ul>
<!--noindex-->
<div class="post-toc-wrap sidebar-panel">
<div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">矩阵及多维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E5%8F%8A%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">队列及双端队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">反向表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E5%8C%85"><span class="nav-number">6.</span> <span class="nav-text">集合与包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">7.</span> <span class="nav-text">字符串缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2"><span class="nav-number">8.</span> <span class="nav-text">图形</span></a></li></ol></div>
</div>
<!--/noindex-->
<div class="site-overview-wrap sidebar-panel">
<div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
<img alt="南锋" class="site-author-image" itemprop="image" src="/images/IMG_3307.JPG"/>
<p class="site-author-name" itemprop="name">南锋</p>
<div class="site-description" itemprop="description">记录工作中的一些笔记以及一些有趣的代码,致力于成为一个优秀的程序员</div>
</div>
<div class="site-state-wrap motion-element">
<nav class="site-state">
<div class="site-state-item site-state-posts">
<a href="/archives/">
<span class="site-state-item-count">206</span>
<span class="site-state-item-name">日志</span>
</a>
</div>
<div class="site-state-item site-state-categories">
<a href="/categories/">
<span class="site-state-item-count">70</span>
<span class="site-state-item-name">分类</span></a>
</div>
<div class="site-state-item site-state-tags">
<a href="/tags/">
<span class="site-state-item-count">69</span>
<span class="site-state-item-name">标签</span></a>
</div>
</nav>
</div>
<div class="links-of-author motion-element">
<span class="links-of-author-item">
<a href="https://github.com/lengmo714" rel="noopener" target="_blank" title="GitHub → https://github.com/lengmo714"><i class="fab fa-github fa-fw"></i>GitHub</a>
</span>
<span class="links-of-author-item">
<a href="/842673413@qq.com" title="E-Mail → 842673413@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
</span>
<span class="links-of-author-item">
<a href="https://weibo.com/u/3124723200" rel="noopener" target="_blank" title="Weibo → https://weibo.com/u/3124723200"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
</span>
<span class="links-of-author-item">
<a href="https://www.douyin.com/user/MS4wLjABAAAAGVvxXoafRJrfCUH8PiT5yO--ToMDJnA_7UpHsFucUuQDDEF4aHy6XOAIedS4rD7W" rel="noopener" target="_blank" title="抖音 → https://www.douyin.com/user/MS4wLjABAAAAGVvxXoafRJrfCUH8PiT5yO--ToMDJnA_7UpHsFucUuQDDEF4aHy6XOAIedS4rD7W"><i class="fa fa-mobile fa-fw"></i>抖音</a>
</span>
</div>
<div class="cc-license motion-element" itemprop="license">
<a class="cc-opacity" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><img alt="Creative Commons" src="/images/cc-by-nc-sa.svg"/></a>
</div>
<div class="links-of-blogroll motion-element">
<div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
<ul class="links-of-blogroll-list">
<li class="links-of-blogroll-item">
<a href="/Link/" title="/Link/">友情链接</a>
</li>
<li class="links-of-blogroll-item">
<a href="https://blog.csdn.net/Silent_F" rel="noopener" target="_blank" title="https://blog.csdn.net/Silent_F">CSDN</a>
</li>
<li class="links-of-blogroll-item">
<a href="https://lengmo714.top/net/map/index.html" title="https://lengmo714.top/net/map/index.html">足迹</a>
</li>
<li class="links-of-blogroll-item">
<a href="https://mall.jd.com/index-12955410.html" rel="noopener" target="_blank" title="https://mall.jd.com/index-12955410.html">京东小店</a>
</li>
<li class="links-of-blogroll-item">
<a href="https://lengmo714.top/net/Love/baby.html" title="https://lengmo714.top/net/Love/baby.html">恋爱计时</a>
</li>
<li class="links-of-blogroll-item">
<a href="https://lengmo714.top/net/wechat/index.html" title="https://lengmo714.top/net/wechat/index.html">微信对话生成器</a>
</li>
</ul>
</div>
</div>
<div class="back-to-top motion-element">
<i class="fa fa-arrow-up"></i>
<span>0%</span>
</div>
</div>
</aside>
<div id="sidebar-dimmer"></div>
</div>
</main>
<footer class="footer">
<div class="footer-inner">
<div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">湘ICP备 2022022717号 </a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=%E6%B9%98%E5%85%AC%E7%BD%91%E5%AE%89%E5%A4%8743011202000987%E5%8F%B7" rel="noopener" target="_blank">湘公网安备43011202000987号 </a>
</div>
<div class="copyright">
  
  © 2017 – 
  <span itemprop="copyrightYear">2024</span>
<span class="with-love">
<i class="fa fa-heart"></i>
</span>
<span class="author" itemprop="copyrightHolder">南锋</span>
</div>
</div>
</footer>
</div>
<script src="/lib/anime.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
<script src="/lib/velocity/velocity.min.js"></script>
<script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
<script src="/js/bookmark.js"></script>
<script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>
<script src="/js/local-search.js"></script>
<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 't3TkgC71hcBBtINYfsVe8r0R-gzGzoHsz',
      appKey     : 'SUF3DMDZlFZMDGj3ai9WfgFY',
      placeholder: "填写QQ邮箱就会使用QQ头像喔~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  +  
  
	<script src="/js/cursor/fireworks.js" type="text/javascript"></script>
</body>
</html>
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"></script>
<p><ins class="adsbygoogle" data-ad-client="ca-pub-3160571902547760" data-ad-format="fluid" data-ad-layout="in-article" data-ad-slot="8630948880" style="display:block; text-align:center;"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>