<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Lua输入输出" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/12/Lua%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" class="article-date">
  <time class="dt-published" datetime="2020-04-12T13:18:32.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/12/Lua%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">Lua输入输出</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>由于Lua语言强调可移植性和嵌入性，所以Lua语言本身并没有提供太多与外部交互的机制。在真实的Lua程序中，从图形、数据库到网络的网络的访问等大多数I&#x2F;O操作，要么游宿主程序实现，要么通过不包括在发行版中的外部库实现。单就Lua语言而言，只提供IOS C语言标准支持的功能，即基本的文件操作等。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="简单I-O模型"><a href="#简单I-O模型" class="headerlink" title="简单I&#x2F;O模型"></a>简单I&#x2F;O模型</h2><p>对于文件操作来说，I&#x2F;O库提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前输出流，其I&#x2F;O操作时通过这些流实现的。I&#x2F;O库把当前输入流初始化为进程的标准输入，将当前输出流初始化为进程的标准输出。因此，当执行类似于io.read()这样的语句时，就可以从标准输入中读取一行。<br>函数io.input可以用于改变当前的输入输出流。调用io.input(file-name)会以只读模式打开指定文件，并将文件设置为当前输入流。之后，所有的输入都将来自该文件，除非再次调用io.input。对于输出流而言，函数io.output的逻辑与之类似。如果出现错误，这两个函数都会抛出异常。如果想直接处理这些异常，则必须使用完整I&#x2F;O模型。<br>由于函数write比函数read简单，我们首先来看函数write。函数io.write可以读取任意数量的字符串并将其写入当前输入流。由于调用该函数时可以使用多个参数，因此应该避免使用io.write(a..b..c)，应该调用io.write(a,b,c)，后者可以用更少的资源达到同样的效果，并且可以避免更多的连接动作。<br>作为原则，应该只在“用后即弃”的代码或调试代码中使用函数print；当需要完全控制输出时，应该使用函数io.write。与函数print不同，函数io.wirte不会在最终的输出结果中添加诸如制表符或换行符这样的额外内容。此外，函数io.write允许对输出进行重定向，而函数print只能使用标准输出。最后，函数print可以自动为其参数调用tostring，这一点对于调试而言非常便利，但这也容易导致一些诡异的Bug。<br>函数io.write在将数值转为字符串时遵循一般的转换规则；如果想要完全地控制这种转换，则应该使用函数string.format:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;sin(3) = &quot;</span>,<span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">3</span>),<span class="string">&quot;\n&quot;</span>)		<span class="comment">-- sin(3) = 0.14112000805987</span></span><br><span class="line">&gt; <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;sin(3) = %0.4f\n&quot;</span>,<span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">3</span>))) 			<span class="comment">-- sin(3) = 0.1411</span></span><br></pre></td></tr></table></figure>
<p>函数io.read可以从当前输入流中读取字符串，其参数决定了要读取的数据：</p>
<hr>
<p>“a”				读取整个文件<br>“l”					读取下一行（丢弃换行符）<br>“L”				读取下一行（保留换行符）<br>“n”				读取一个数值<br>num				以字符串读取num个字符</p>
<hr>
<p>调用io.write(“a”)可以从当前位置开始读取输入文件的全部内容。如果当前位置处于文件的末尾或文件为空，那么该函数返回一个空字符串。<br>因为Lua语言可以高效地处理长字符串，所以在Lua语言编写过滤器的一种简单技巧就是将整个文件读取到一个字符串中，然后对字符串进行处理，最后输出结果为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;a&quot;</span>)			<span class="comment">-- 读取整个文件</span></span><br><span class="line">t = <span class="built_in">string</span>.<span class="built_in">gsub</span>(t,<span class="string">&quot;bad&quot;</span>,<span class="string">&quot;good&quot;</span>)			<span class="comment">-- 进行处理</span></span><br><span class="line"><span class="built_in">io</span>.wirte(t)					<span class="comment">-- 输出结果</span></span><br></pre></td></tr></table></figure>
<p>举一个更加具体的例子，一下是一段将某个人间的内容使用MIME可打印字符串引用编码进行编码的代码。这种编码方式将所有非ASCII字符编码为 &#x3D;xx，其中xx是这个字符的十六进制。为保证编码的一致性，等号也会被编码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">t = <span class="built_in">string</span>.<span class="built_in">gsub</span>(t,<span class="string">&quot;[\128 - \255 = ]&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(c)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;=%02X&quot;</span>,<span class="built_in">string</span>.<span class="built_in">byte</span>(c))</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(t)</span><br></pre></td></tr></table></figure>
<p>函数string.gsub会匹配所有的等号及非ASCII字符（从128到255），并调用指定的函数完成替换。<br>调用io.read(“l”)会返回当前输入流的下一行，不包括换行符在内；调用io.read(“L”)与之类似，但会保留换行符。当达到文件末尾时，由于已经没有内容可以返回，该函数会返回nil。选项”l”是函数read的默认参数。我通常只在逐行处理数据的算法使用该参数，其他情况则更倾向于使用选项”a”一次性地读取整个文件，或者像后续介绍的按块读取。<br>作为面向行的输入的一个简单例子，以下的程序会在将当前输入复制到当前输出中的同时对每行进行编码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> count = <span class="number">1</span> , <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> line = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> line == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%6d &quot;</span>,count),line)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，如果要逐行迭代一个文件，那么使用io.lines迭代器会更简单：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	count = count + <span class="number">1</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%6d &quot;</span>,count), line , <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>另一个面向行的输入的例子参考下例，其中给出了一个对文件中的进行排序的完整程序。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">lines</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">lines</span>[#<span class="built_in">lines</span> + <span class="number">1</span>] = line</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(<span class="built_in">lines</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, l <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">lines</span>) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(l,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用io.read(“n”)会从当前输入流中读取一个数值，这也是函数read返回值为数值而非字符串的唯一情况。如果在跳过了空格后，函数io.read仍然不能从当前位置读取到数值，则返回nil。<br>除了上述这些基本的读取模式外，在调用函数read时还可以用一个数字n作为其参数：在这种情况下，函数read会从输入流中读取n个字符。如果无法读取到任何字符则返回nil；否则，则返回一个由流中最多n个字符组成的字符串。作为这种读取模式的示例，以下的代码展示了将文件从stdin复制到stdout的高效方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> block = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="number">2</span>^<span class="number">13</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> block <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(block)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>io.read(0)是一个特例，它常用于测试是否到达了文件末尾。如果仍然有数据可供读取，它会返回一个空字符串；否则，则返回nil。<br>调用函数read时可以指定多个选项，函数会根据每个参数返回相应的结果。假设有一个每行由3个数字组成的文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.0</span> <span class="number">-3.23</span> <span class="number">15e12</span></span><br><span class="line"><span class="number">4.3</span>	<span class="number">234</span>	  <span class="number">1000001</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果想打印每一行的最大值，那么可以通过调用函数read来一次性地同时读取每行中的3个数字：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> n1,n2,n3 = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">max</span>(n1,n2,n3))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="完整I-O模型"><a href="#完整I-O模型" class="headerlink" title="完整I&#x2F;O模型"></a>完整I&#x2F;O模型</h2><p>简单I&#x2F;O模型对简单的需求而言还算适用，但对于诸如同时读写多个文件等更高级的文件操作来说就不够了。对于这些文件操作，我们需要用到完整I&#x2F;O模型。<br>可以使用函数io.open来打开一个文件，该函数仿造C语言中的函数fopen。这个函数有两个参数一个参数是待打开文件的文件名，另一个参数是一个模式字符串。模式字符串包括表示只读的r、表示只写的w、表示追加的a，以及另外一个可选的表示打开二进制文件的b。函数io.open返回对应文件的流。当发生错误时，该函数会返回nil的同时返回一条错误信息及一个系统相关的错误码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;non-existent-file&quot;</span>,<span class="string">&quot;r&quot;</span>))		<span class="comment">-- nil  non-existent-file:No such file file or directory 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;w&quot;</span>))			<span class="comment">-- nil  /etc/passwd:Permission denied 13</span></span><br></pre></td></tr></table></figure>
<p>检查错误的一种典型方法是使用函数assert:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(filename,mode))</span><br></pre></td></tr></table></figure>
<p>如果函数io.open执行失败，错误信息会作为函数assert的第二个参数被传入，之后函数assert会将错误信息展示出来。<br>在打开文件后，可以使用方法read和write从流中读取和向流中写入。它们与函数read和write类似，但需要使用冒号运算符将它们当做流对象的方法来调用。例如，可以使用如下的代码打开一个文件并读取其中多有内容：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(filename,<span class="string">&quot;r&quot;</span>))</span><br><span class="line"><span class="keyword">local</span> t = f:<span class="built_in">read</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">f:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>I&#x2F;O库提供了三个预定义的C语言流的句柄：io.stdin、io.stdout和io.stderr。例如，可以使用如下的代码将信息直接写到标准错误流中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">io</span>.<span class="built_in">stderr</span>:<span class="built_in">write</span>(message)</span><br></pre></td></tr></table></figure>
<p>函数io.input和io.output允许混用完整I&#x2F;O模型和简单I&#x2F;O模型。调用无参数的io.input()可以获得当前输入流，调用io.input(handle)可以设置当前输入流。例如，如果想要临时改变当前输入流，可以像这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> temp = <span class="built_in">io</span>.<span class="built_in">input</span>()			<span class="comment">-- 保存当前输入流</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(<span class="string">&quot;newinput&quot;</span>)			<span class="comment">-- 打开一个新的当前输入流</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>():<span class="built_in">close</span>()				<span class="comment">-- 关闭当前流</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(temp)					<span class="comment">-- 恢复此前的当前输入流</span></span><br></pre></td></tr></table></figure>
<p>注意，io.read(args)实际上是io.input():read(args)的简写，即函数read是用在当前输入流上的。同样，io.write(args)是io.output():write(args)的简写。<br>除了函数io.read外，还可以用函数io.lines从流中读取内容。正如之前的示例中展示的那样，函数io.lines返回一个可以从流中不断读取内容的迭代器。给函数io.lines提供一个文件名，它就会只读方式打开对应该文件的输入流，并在到达文件末尾后关闭该输入流。若调用时不带参数，函数io.lines就从当前输入读取。我们也可以把函数lines当作句柄的一个方法。</p>
<h2 id="其他文件操作"><a href="#其他文件操作" class="headerlink" title="其他文件操作"></a>其他文件操作</h2><p>函数io.tmpfile返回一个操作临时文件的句柄，该句柄是以读&#x2F;写模式打开的。当程序运行结束后，该临时文件会被自动移除。<br>函数flush将所有缓冲数据写入文件。与函数write一样，我们也可以把它当做io.flush()使用，以刷新当前输出流；或者把它当作方法f:flush()使用，以刷新流f。<br>函数setvbuf用于设置流的缓冲模式。该函数的第一个参数是一个字符串:”no”表示无缓冲，”full”表示在缓冲区满时或者显示地刷新文件时文件时才写入数据，”line”表示输出一直被缓冲直到遇到换行符或从一些特定文件中读取到了数据。对于后两个选项，函数setvbuf支持可选的第二个参数，用于指定缓冲区大小。<br>在大多数系统中，标准错误流(io.stdrr)是不被缓冲的，而标准输出流(io.stdout)按行缓冲。因此，当向标准输出中写入了不完整的行时，可能需要刷新这个输出流才能看到输出结果。<br>函数seek用来获取和设置文件的当前位置，常常使用f:seek(whence，offset)的形式来调用，其中参数whence是一个指定如何使用偏移的字符串。当参数whence取值为”set“时，表示相对文件开头的偏移；取值为”cur”时，表示相对于文件位置的偏移；取值为”end”时，表示相对于文件尾部的偏移。不管whence的取值是什么，该函数都会以字节为单位，返回当前新位置在流中的相对于文件开头的偏移。<br>whence的默认值是”cur”，offset的默认值是0。因此，调用函数file:seek()会返回当前的位置且不改变当前位置；调用函数file:seek(“set”)会将位置重置到文件开头并返回0；调用函数file:seek(“end”)会将当前位置到文件结尾并返回文件的大小。下面的函数演示了如何在不修改当前位置的情况下获取文件大小：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fsize</span> <span class="params">(file)</span></span></span><br><span class="line">	<span class="keyword">local</span> current = file:seek()				<span class="comment">-- 保存当前位置</span></span><br><span class="line">	<span class="keyword">local</span> size = file:seek(<span class="string">&quot;end&quot;</span>)			<span class="comment">-- 获取文件大小</span></span><br><span class="line">	file:seek(<span class="string">&quot;set&quot;</span>,current)				<span class="comment">-- 恢复当前位置</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>此外，函数os.rename用于文件重命名，函数os.remove用于移除（删除）文件。需要注意的是，由于这两个函数处理的是真实文件而非流，所以它们位于os库而非io库中。<br>上述所有的函数在遇到错误时，均会返回nil外加一条错误信息和一个错误新。</p>
<h2 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h2><p>函数os.exit用于终止程序的执行。该函数的第一个参数是可选的，表示该程序的返回状态，其值可以为一个数值（0表示执行成功）或者一个布尔值（true表示执行成功）；该函数的第二个参数也是可选的，当值为true时会关闭Lua状态并调用所有析构器释放所用的所有内存。<br>函数os.getenv用于获取某个环境变量，该函数的输入参数是换环境变量的名称，返回值为保存了该环境变量对应值的字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;HOME&quot;</span>)) 	<span class="comment">-- /home/lua</span></span><br></pre></td></tr></table></figure>
<p>对于未定义的环境变量，该函数返回nil。</p>
<h2 id="运行系统命令"><a href="#运行系统命令" class="headerlink" title="运行系统命令"></a>运行系统命令</h2><p>函数os.execute用于运行系统命令，它等价于C语言中的函数system。该函数的参数为表示待执行命令的字符串，返回值为命令运行结束后的状态。其中，第一个返回值是一个布尔类型，当为true时表示程序成功运行完成；第二个返回值是一个字符串，当为”exit”时表示程序正常运行程序，当为”signal”时表示因信号而中断；第三个返回值是返回状态或者终结该程序的信号代码。例如，在POSIX和Windows中都可以使用如下的函数创建新目录：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDir</span><span class="params">(dirname)</span></span></span><br><span class="line">	<span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&quot;mkdir &quot;</span> .. dirname)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>另一个非常有用的函数是io.popen。同函数os.execute一样，该函数运行一条系统命令，但该函数还可以重定向命令的输入&#x2F;输出，从而使得程序可以向命令中写入或从命令的输出中读取。例如，下列代码使用当前目录中的所有内容构建一个表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">popen</span>(<span class="string">&quot;dir/B&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dir = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> f:<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	dir[#dir + <span class="number">1</span>] = entry</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中，函数io.popen的第二个参数”r”表示从命令的执行结果中读取。由于该函数的默认行为就是这样，所以在上例中这个参数实际是可选的。<br>下面的示例用于发送一封邮件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> subject = <span class="string">&quot;some news&quot;</span></span><br><span class="line"><span class="keyword">local</span> address = <span class="string">&quot;someone@somewhere.org&quot;</span></span><br><span class="line"><span class="keyword">local</span> cmd = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;mail -s &#x27;%s&#x27; &#x27;%s&#x27; &quot;</span>,subject,address)</span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">popen</span>(cmd,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">f:<span class="built_in">write</span>(<span class="string">[[</span></span><br><span class="line"><span class="string">	Nothing important to say.</span></span><br><span class="line"><span class="string">	]]</span>)</span><br><span class="line">f:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>注意，该脚本只能在安装了相应工具包的POSIX系统中运行。上例中函数io.popen的第二个参数是”w”，表示向该命令中写入。<br>正如我们在上面的两个例子中看到的一样，函数os.execute和io.popen都是功能非常强大的函数，但它们也同样是非常依赖于操作系统的。<br>如果要使用操作系统的其他扩展功能，最好的选择是使用第三方库，比如用于基于目录操作和文件属性操作的LuaFileSystem，或者提供了POSIX.1标准支持的luaposix库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/12/Lua%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" data-id="clw7ne0xj003s4sad0tvrgw6b" data-title="Lua输入输出" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua中函数的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/10/Lua%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2020-04-10T14:21:53.000Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/10/Lua%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/">Lua中函数的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在Lua语言中，函数是对语句和表达式进行抽象的主要方式。函数既可以用于完成某种特定任务，也可以只是进行一些计算然后返回计算结果。在前一种情况下，我们将一句函数调用视为一条语句；而在后一种情况下，我们则将函数调用视为表达式：</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">8</span>*<span class="number">9</span> , <span class="number">9</span>/<span class="number">8</span>)</span><br><span class="line">a = <span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">3</span>) + <span class="built_in">math</span>.<span class="built_in">cos</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>())</span><br></pre></td></tr></table></figure>
<p>无论哪种情况，函数调用时都需要使用一对圆括号把参数列表括起来。即使被调用的函数不需要参数，也需要一对空括号()。对于这个规则，唯一的例外就是，当函数只有一个参数且该参数是字符串常量或表构造器时:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello World&quot;</span>    &lt;<span class="comment">--&gt; print(&quot;Hello World&quot;)</span></span><br><span class="line"><span class="built_in">dofile</span> <span class="string">&quot;a.lua&quot;</span>		   &lt;<span class="comment">--&gt; dofile(&#x27;a.lua&#x27;)</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">[[a multi-line message]]</span> &lt;<span class="comment">--&gt; print([[a multi-line message]])</span></span><br><span class="line">f&#123;x = <span class="number">10</span> , y = <span class="number">20</span>&#125;		&lt;<span class="comment">--&gt; f(&#123;x = 10 , y = 20&#125;)</span></span><br><span class="line"><span class="built_in">type</span>&#123;&#125;	</span><br></pre></td></tr></table></figure>
<p>Lua语言也为面向对象风格的调用提供了一种特殊的语法，即冒号操作符。形如x:foo(x)的表达式意味为调用对象o的foo方法。<br>一个Lua程序既可以调用Lua语言编写的函数，也可以调用C语言编写的函数。一般来说，我们选择使用C语言编写的函数来实现对性能要求更高，或不容易直接通过Lua语言进行操作的操作系统机制等。例如，Lua语言标准库中所有的函数就都是使用C语言编写的。不过，无论一个函数是用Lua语言编写的还是用C语言编写的，在调用它们时都没有任何区别。<br>正如我们已经在其他示例中所看到的，Lua语言中的函数定义的常见语法格式形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">( a )</span></span></span><br><span class="line">	<span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br><span class="line">		sum = sum + a[i]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种语法中，一个函数定义具有一个函数名、一个参数组成的列表和由一组语句组成的函数体。参数的行为与局部变量的行为完全一致，相当于一个用函数调用时转入的值进行初始化的局部变量。<br>调用函数时使用的参数个数可以与定义函数时使用的参数个数不一致。Lua语言会通过抛弃多余参数和将不足的参数设为nil的方式来调整参数的个数。例如，考虑如下的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> <span class="params">(a,b)</span></span> <span class="built_in">print</span>(a , b) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其形为如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f()				<span class="comment">-- nil  nil</span></span><br><span class="line">f(<span class="number">3</span>)			<span class="comment">-- 3  nil</span></span><br><span class="line">f(<span class="number">3</span>,<span class="number">4</span>)			<span class="comment">-- 3  4</span></span><br><span class="line">f(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)		<span class="comment">-- 3  4  (5被丢弃)</span></span><br></pre></td></tr></table></figure>
<p>虽然这种行为可能导致编程错误，但同样又是有用的，尤其是对于默认参数的情况。例如，考虑如下递增全局计数器的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCount</span><span class="params">( n )</span></span></span><br><span class="line">	n = n <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">	globalCounter = globalCounter + n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数以1作为默认实参，当调用无参数的incCount()时，将globalCounter加1。在调用incCount()时，Lua语言首先把参数n初始化为nil，接下来or表达式又返回了其第二个操作数，最终把n赋成了默认值1。</p>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Lua语言中一种与众不同但又非常有用的特性是允许一个函数返回多个结果。Lua语言中几个预定义函数就会返回多个值。我们已经接触过函数string.find，该函数用于在字符串中定位模式。当找到了对应的模式时，该函数会返回两个索引值：所匹配模式在字符串中初始字符和结尾字符的索引。使用多重赋值可以同时获取到这两个结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;hello lua users&quot;</span> , <span class="string">&quot;Lua&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s, e) 		<span class="comment">-- 7 	9</span></span><br></pre></td></tr></table></figure>
<p>请记住，字符串的第一个字符的索引值为1。<br>Lua语言编写的函数同样可以返回多个结果，只需在return关键字后列出所有要返回的值即可。例如，一个用于查找序列中最大元素的函数可以同时返回最大值及该元素的位置：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">local</span> mi = <span class="number">1</span></span><br><span class="line">	<span class="keyword">local</span> m = a[mi]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> a[i] &gt; m <span class="keyword">then</span></span><br><span class="line">			mi = i ; m = a[i]</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))  <span class="comment">--23 3</span></span><br></pre></td></tr></table></figure>
<p>Lua语言根据函数的被调用情况调整返回值的数量。当函数被作为一条单独语句调用时，其所有返回值都会被丢弃；当函数被作为表达式调用时，将只保留函数的第一个返回值。只有当函数调用是一系列表达式中的最后一个表达式时，其所有的返回值才能被获取到。这里所谓的“一系列表达式”在Lua中表现为4种情况：多重赋值、函数调用时传入的实参列表、表构造器和return语句。为了分别展示这几种情况，接下来举几个例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo0</span><span class="params">()</span></span> <span class="keyword">end</span>			<span class="comment">-- 不返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">&quot;a&quot;</span> <span class="keyword">end</span> 		<span class="comment">-- 返回1个结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> <span class="keyword">end</span> 	<span class="comment">-- 返回2个结果</span></span><br></pre></td></tr></table></figure>
<p>在多重赋值中，如果一个函数调用是一系列表达式中的最后一个表达式，则该函数调用将产生尽可能多的返回值以匹配待赋值变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x,y = foo2()			<span class="comment">-- x = &quot;a&quot;, y = &quot;b&quot;</span></span><br><span class="line">x = foo2()				<span class="comment">-- x = &quot;a&quot;, &quot;b&quot;被丢弃</span></span><br><span class="line">x,y,z = <span class="number">10</span>, foo2()		<span class="comment">-- x = 10, y = &quot;a&quot;, z = &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<p>在多重赋值中，如果一个函数没有返回值或者返回值个数不够多，那么Lua语言会用nil来补充缺失的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x,y = foo0()		<span class="comment">-- x = nil , y = nil</span></span><br><span class="line">x,y = foo1()		<span class="comment">-- x = &quot;a&quot; , y = nil</span></span><br><span class="line">x,y,z = foo2()		<span class="comment">-- x = &quot;a&quot; , y = &quot;b&quot; , z = nil</span></span><br></pre></td></tr></table></figure>
<p>请注意，只有当函数调用一系列表达式中的最后一个表达式时才能返回多值结果，否则只能返回一个结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x,y = foo2(), <span class="number">20</span> 			<span class="comment">-- x = &quot;a&quot;, y = 20  (&#x27;b&#x27;被丢弃)</span></span><br><span class="line">x,y = foo0(), <span class="number">20</span>, <span class="number">30</span> 		<span class="comment">-- x = nil, y = 20  (30被丢弃)</span></span><br></pre></td></tr></table></figure>
<p>当一个调用是另一个函数调用的最后一个实参时，第一个函数的所有返回值都会被作为实参传给第二个函数。我们已经见到过很多这样的代码结构，例如函数print。由于函数print能够接收可变数量的参数，所以print(g())会打印出g返回的所有结果。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(foo0())			<span class="comment">-- 没有结果</span></span><br><span class="line"><span class="built_in">print</span>(foo1())			<span class="comment">-- a</span></span><br><span class="line"><span class="built_in">print</span>(foo2())			<span class="comment">-- a   b</span></span><br><span class="line"><span class="built_in">print</span>(foo2(),<span class="number">1</span>)			<span class="comment">-- a   1</span></span><br><span class="line"><span class="built_in">print</span>(foo2() .. <span class="string">&quot;x&quot;</span>)	<span class="comment">-- ax</span></span><br></pre></td></tr></table></figure>
<p>当在表达式中调用foo2时，Lua语言会把其返回值的个数调整为1.因此，在上例的最后一行，只有第一个返回值”a”参与了字符串连接操作。<br>当我们调用f(g())时，如果f的参数是固定的，那么Lua语言会把g返回值的个数调整成与f的参数个数一致。<br>表构造器会完整地接收函数调用的所有返回值，而不会调整返回值的个数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;foo0()&#125;		<span class="comment">-- t = &#123;&#125;</span></span><br><span class="line">t = &#123;foo1()&#125;		<span class="comment">-- t = &#123;&quot;a&quot;&#125;</span></span><br><span class="line">t = &#123;foo2()&#125;		<span class="comment">-- t = &#123;&quot;a&quot;,&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>不过，这种行为只有当函数调用是表达式列表中的最后一个时才有效，在其他位置上的函数总是只返回一个结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;foo0(),foo2(),<span class="number">4</span>&#125;  <span class="comment">-- t[1] = nil, t[2] = &quot;a&quot;, t[3] = 4</span></span><br></pre></td></tr></table></figure>
<p>最后，形如return f()的语句会返回f返回的所有结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(i)</span></span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> foo0()</span><br><span class="line">	<span class="keyword">elseif</span> i == <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">return</span> foo1()</span><br><span class="line">	<span class="keyword">elseif</span> i == <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">return</span> foo2()</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">1</span>))		<span class="comment">-- a</span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">2</span>))		<span class="comment">-- a b</span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">0</span>))		<span class="comment">-- 无结果</span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">3</span>))		<span class="comment">-- 无结果</span></span><br></pre></td></tr></table></figure>
<p>将函数调用用一对圆括号括起来可以强制其只返回一个结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(foo0())		<span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(foo1())		<span class="comment">-- a</span></span><br><span class="line"><span class="built_in">print</span>(foo2())		<span class="comment">-- a</span></span><br></pre></td></tr></table></figure>
<p>应该意识到，return语句后面的内容是不需要加括号的，如果加了括号会导致程序出现额外的行为。因此，无论f究竟返回几个值，形如return(f(x))的语句只返回一个值。又是这可能是我们所希望出现的情况，但有时又可能不是。</p>
<h2 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h2><p>Lua语言中的函数可以是可变长参数函数，即可以支持数量可变的参数。例如，我们已经使用一个、两个或多个参数调用过函数print。虽然函数print是在C语言中定义的，但也可以在Lua语言中定义可变长参数函数。<br>下面是一个简答的示例，该函数返回所有参数的总和：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span></span><br><span class="line">		s = s + v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> s </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">25</span>,<span class="number">12</span>)) 	<span class="comment">-- 54</span></span><br></pre></td></tr></table></figure>
<p>参数列表中的三个点(…)表示该函数的参数是可变长的。当这个函数被调用时，Lua内部会把它所有参数收集起来，我们把这些被收集起来的参数称为函数的额外参数。当函数要访问这些参数时仍需用到三个点，但不同的是此时这三个点是作为一个表达式来使用的。在上例中，表达式{…}的结果是一个由所有可变长参数组成的列表，该函数会遍历该列表来累加其中的元素。<br>我们将三个点组成的表达式称为可变长参数表达式，其行为类似于一个具有多个返回值的函数，返回的是当前函数的所有可变长参数。<br>实际上，可以通过变长参数来模拟Lua中普遍的参数传递机制，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funtion foo (a,b,c)</span><br></pre></td></tr></table></figure>
<p>可以写成</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> a,b,c = ...</span><br></pre></td></tr></table></figure>
<p>喜欢Perl参数传递机制的人可能会更喜欢第二种形式。<br>形如下列的函数只是将调用它时所传入的所有参数简单地返回：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span> <span class="params">(...)</span></span> <span class="keyword">return</span> ... <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数是一个多值恒等式函数。下列函数的行为则类似于直接调用函数foo，唯一不同之处是在调用函数foo之前会先打印出传递函数foo的所有参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span><span class="params">( ... )</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;calling foo:&quot;</span>,...)</span><br><span class="line">	<span class="keyword">return</span> foo(...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当跟踪对某个特定的函数调用时，这个技巧很有用。<br>接下来再让我们看另外一个很有用的示例。Lua语言提供了专门用于格式化输出的函数string.format和输出文本的函数io.write。我们会很自然地想到把这两个函数合并为一个具有可变长参数的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwirte</span><span class="params">(fmt, ...)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">io</span>.wirte(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, ...))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>注意，在三个点前游一个固定的参数fmt。具有可变长参数的函数也可以具有任意数量的固定参数，但固定参数必须放在变长参数之前。Lua语言会先将前面的参数赋给固定参数，然后将剩余的参数作为可变长参数。<br>要遍历可变长参数，函数可以使用表达式{…}将可变长参数放在一个表中，就像add示例中所作的那样。不过，在某些罕见的情况下，如果可变长参数中包含无效的nil，那么{…}获得的表可能不再是一个有效的序列。此时，就没有办法在表中判断原始参数究竟是不是以nil结尾的。对于这种情况，Lua语言提供了函数table.pack。该函数像表达式{…}一样保存所有的参数，然后将其放在一个表中返回，但是这个表还有一个保存了参数个数的额外字段”n”。例如，下面的函数使用了函数table.pack来检测参数中是否有nil：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonils</span><span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">arg</span> = <span class="built_in">table</span>.pack(...)</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>  , <span class="built_in">arg</span>.n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">arg</span>[i] == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(nonils(<span class="number">2</span>,<span class="number">3</span>,<span class="literal">nil</span>))			<span class="comment">-- false</span></span><br><span class="line"><span class="built_in">print</span>(nonils(<span class="number">2</span>,<span class="number">3</span>))				<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(nonils())					<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(nonils(<span class="literal">nil</span>))				<span class="comment">-- false</span></span><br></pre></td></tr></table></figure>
<p>另一种遍历函数的可变长参数的方法是使用函数select。函数select总是具有一个固定的参数select，以及数量可变的参数。如果select是数值n，那么函数select则返回第n个参数后的所有参数；否则，select应该是字符串”#”，以便函数select返回额外参数的总数。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">select</span>(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>))			<span class="comment">-- a	b	c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">select</span>(<span class="number">2</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>))			<span class="comment">-- b	c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">select</span>(<span class="number">3</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>))			<span class="comment">-- c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>))			<span class="comment">-- 3</span></span><br></pre></td></tr></table></figure>
<p>通常，我们在需要把返回值个数调整为1的地方使用函数select，因此可以把select(n,…)认为是返回第n个额外参数的表达式。<br>来看一个使用函数select的典型示例，下面是使用该函数的add函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,...) <span class="keyword">do</span></span><br><span class="line">		s = s + <span class="built_in">select</span>(i , ...)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>对于参数较少的情况，第二个版本的add更快，因为该版本避免了每次调用时创建一个新表。不过，对于参数较多的情况，多次带有很多参数调用函数select会超过创建表的开销，因此第一个版本会更好。</p>
<h2 id="函数table-unpack"><a href="#函数table-unpack" class="headerlink" title="函数table.unpack"></a>函数table.unpack</h2><p>多重返回值还涉及一个特殊的函数table.unpack。该函数的参数是一个数组，返回值为数组内的所有元素：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">unpack</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;)		<span class="comment">-- 10	20	30</span></span><br><span class="line">a,b = <span class="built_in">table</span>.<span class="built_in">unpack</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;		<span class="comment">-- a = 10, b = 20 , 30被丢弃</span></span><br></pre></td></tr></table></figure>
<p>顾名思义，函数table.unpack与函数table.pack的功能相反。pack把参数列表转换成Lua语言中一个真实的列表，而unpack则把Lua语言中的真实的列表转换成一组返回值，进而可以作为另一个函数的参数被使用。<br>unpack函数的重要用途之一体现在泛型调用机制中。泛型调用机制允许我们动态地调用具有任意参数的函数。例如，在IOS C中，我们无法编写泛型调用的代码，只能声明可变长参数的函数或使用函数指针来调用不同的函数。但是，我们仍然不能调用具有可变量参数的函数，因为C语言中的每一个函数调用的实参个数是固定的，并且每个实参的类型也是固定的。而在Lua语言中，却可以做到这一点。如果我们想通过数组a传入可变的参数来调用函数f，那么可以写成：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="built_in">table</span>.<span class="built_in">unpack</span>(a))</span><br></pre></td></tr></table></figure>
<p>unpack会返回a中所有的元素，而这些元素又被用作f的参数。例如，考虑如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;ll&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>可以使用如下的代码动态地构造一个等价的调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">string</span>.<span class="built_in">find</span></span><br><span class="line">a = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;ll&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="built_in">table</span>.<span class="built_in">unpack</span>(a)))</span><br></pre></td></tr></table></figure>
<p>通常，函数table.unpack使用长度操作符获取返回值的个数，因而该函数只能用于序列。不过，如果有需要，也可以显示地限制返回元素的范围：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">unpack</span>(&#123;<span class="string">&quot;Sun&quot;</span>,<span class="string">&quot;Mon&quot;</span>,<span class="string">&quot;Tue&quot;</span>,<span class="string">&quot;Wed&quot;</span>&#125;,<span class="number">2</span>,<span class="number">3</span>))		<span class="comment">-- Mon	Tue</span></span><br></pre></td></tr></table></figure>
<p>虽然预定义的函数unpack是用C语言编写的，但是也可以利用递归在Lua语言中实现：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unpack</span><span class="params">(t,i,n)</span></span></span><br><span class="line">	i = i <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">	n = n <span class="keyword">or</span> #t</span><br><span class="line">	<span class="keyword">if</span> i &lt;= n <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> t[i],<span class="built_in">unpack</span>(t,i+<span class="number">1</span>,n)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在第一次调用该函数时，只传入一个参数，此时i为1，n为序列长度；然后，函数返回t[1]及unpack(t,2,n)返回的所有结果，而unpack(t,2,n)又会返回t[2]及unpack(t,3,n)返回的所有结果，一次类推，直到处理完n个元素为止。</p>
<h2 id="正确的尾调用"><a href="#正确的尾调用" class="headerlink" title="正确的尾调用"></a>正确的尾调用</h2><p>Lua语言中有关函数的另一个有趣的特性是，Lua语言是支持尾调用消除的。这意味着Lua语言可以正确地尾递归，虽然尾调用消除的概念并没有直接涉及递归。<br>尾调用是被当作函数调用使用的跳转。当一个函数的最后一个动作是调用另一个函数而没有再进行其他工作时，就行程了尾调用。例如，下例代码中对函数g的调用就是尾调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span> x = x + <span class="number">1</span>;<span class="keyword">return</span> g(x) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当函数f调用完函数g之后，f不再需要进行其他的工作。这样，当被调用的函数执行结束后，程序就不再需要返回最初的调用者。因此，在尾调用后，程序也就不需要在调用栈中保存有关调用函数的任何信息。当g返回时，程序的执行路径会直接返回到调用f的位置。在一些语言的实现中，例如Lua语言解释器，就利用了这个特点，是的进行尾调用时不使用任何额外的栈空间。我们就将这种实现称为尾调用消除。<br>由于尾调用不会使用栈空间，所以一个程序中能够嵌套的尾调用的数量是无限的。例如，下例函数支持任意的数字作为参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> foo(n - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数永远不会发生栈溢出。<br>关于尾调用消除的一个重点就是如何判断一个调用是尾调用。很多函数之所有不是尾调用，是由于这些函数在调用之后还进行了其他工作。例如，下例中调用g就不是尾调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">	g(x)</span><br><span class="line"><span class="keyword">end</span>	</span><br></pre></td></tr></table></figure>
<p>这个示例的问题在于，当调用完g后，f在返回前还不得不丢弃g返回的所有结果。类似的，以下的所有调用也都不符合尾调用的定义:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> g(x) + <span class="number">1</span>				<span class="comment">-- 必须进行加法</span></span><br><span class="line"><span class="keyword">return</span> x <span class="keyword">or</span> g(x)			<span class="comment">-- 必须把返回值限制为1个</span></span><br><span class="line"><span class="keyword">return</span> (g(x))				<span class="comment">-- 必须把返回值限制为1个</span></span><br></pre></td></tr></table></figure>
<p>在lua语言中，只有形如return func(args)的调用才是尾调用。不过，由于Lua语言会在调用钱对func及其参数求值，所以func及其参数都可以是复杂的表达式。例如，下面的例子就是尾调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> x[i].foo(x[j] + a * b, i + j)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/10/Lua%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="clw7ne0x3001f4sad7zmy3hts" data-title="Lua中函数的使用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua中表的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/10/Lua%E4%B8%AD%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2020-04-09T17:12:41.000Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/10/Lua%E4%B8%AD%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/">Lua连续教程之Lua中表的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>表是Lua中最主要和强大的数据结果。使用表，Lua语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结果。Lua语言也使用表来表示包和其他对象。当调用函数math.sin时，我们可能认为是“调用了math库中函数sin”；而对于Lua语言来说，其实际含义是“以字符串sin”为键检索表math。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>Lua语言中的表本质上是一种辅助数组。这种数组不仅可以使用数值作为索引，也可以使用字符串或其他任意类型的值作为索引（nil除外）。<br>我们使用构造器表达式创建表，其最简单的形式是{}:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;&#125;			<span class="comment">--创建一个表然后用表的引用赋值</span></span><br><span class="line">&gt; k = <span class="string">&quot;x&quot;</span></span><br><span class="line">&gt; a[k] = <span class="number">10</span> 		<span class="comment">-- 新元素，键是&quot;x&quot;,值是10</span></span><br><span class="line">&gt; a[<span class="number">20</span>] = <span class="string">&quot;great&quot;</span>	<span class="comment">-- 新元素，键是20，值是&quot;great&quot;</span></span><br><span class="line">&gt; a[<span class="string">&quot;x&quot;</span>]			<span class="comment">-- 10</span></span><br><span class="line">&gt; k = <span class="number">20</span></span><br><span class="line">&gt; a[k]				<span class="comment">-- &quot;great&quot;</span></span><br><span class="line">&gt; a[<span class="string">&quot;x&quot;</span>] = a[<span class="string">&quot;x&quot;</span>] + <span class="number">1</span> <span class="comment">-- 增加元素&quot;x&quot;的值</span></span><br><span class="line">&gt; a[<span class="string">&quot;x&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>表永远是匿名的，表本身和保存表的变量之间没有固定的关系：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;&#125;</span><br><span class="line">&gt; a[<span class="string">&quot;x&quot;</span>] = <span class="number">10</span></span><br><span class="line">&gt; b = a					<span class="comment">-- &#x27;b&#x27;和&#x27;a&#x27;引用同一张表</span></span><br><span class="line">&gt; b[<span class="string">&quot;x&quot;</span>] = <span class="number">20</span></span><br><span class="line">&gt; a[<span class="string">&quot;x&quot;</span>]				<span class="comment">-- 20</span></span><br><span class="line">&gt; a = <span class="literal">nil</span> 				<span class="comment">-- 只有&#x27;b&#x27;仍然指向表</span></span><br><span class="line">&gt; b = <span class="literal">nil</span>				<span class="comment">-- 没有指向表的引用了</span></span><br></pre></td></tr></table></figure>
<p>对于一个表而言，当程序中不再有指向它的引用时，垃圾收集器会最终删除这个表并重用其占用的内存。</p>
<h2 id="表索引"><a href="#表索引" class="headerlink" title="表索引"></a>表索引</h2><p>同一个表中存储的值可以具有不同的类型索引，并可以按需增长以容纳新的元素：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;&#125;		<span class="comment">-- 空的表</span></span><br><span class="line">&gt; <span class="comment">-- 创建1000个新元素</span></span><br><span class="line">&gt; <span class="keyword">for</span> i = <span class="number">1</span> , <span class="number">1000</span> <span class="keyword">do</span> a[i] = <span class="number">1</span> * <span class="number">2</span> <span class="keyword">end</span></span><br><span class="line">&gt; a[<span class="number">9</span>]			<span class="comment">-- 18</span></span><br><span class="line">&gt; a[<span class="string">&quot;x&quot;</span>] = <span class="number">10</span> 	</span><br><span class="line">&gt; a[<span class="string">&quot;x&quot;</span>]		<span class="comment">-- 10</span></span><br><span class="line">&gt; a[<span class="string">&quot;y&quot;</span>]		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>请注意上述代码的最后一行：如同全局变量一样，未经初始化的表元素为nil，将nil赋值给表元素可以将其删除。<br>当把表当做结构体使用时，可以把索引当作成员名称使用。因此，可以使用这种更加易读的方式改写前述示例的最后几行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;&#125;</span><br><span class="line">&gt; x = <span class="string">&quot;y&quot;</span></span><br><span class="line">&gt; a[x] = <span class="number">10</span> 		<span class="comment">-- 把10放在字段&quot;y&quot;中</span></span><br><span class="line">&gt; a[x]				<span class="comment">-- 10  字段&quot;y&quot;的值</span></span><br><span class="line">&gt; a.x 				<span class="comment">-- nil  字段&quot;x&quot;的值（未定义）</span></span><br><span class="line">&gt; a.y				<span class="comment">-- 10 字段&quot;y&quot;的值</span></span><br></pre></td></tr></table></figure>
<p>由于可以使用任意类型索引表，所以在索引表时会遇到相等性比较方面的微妙问题。虽然确实都能使用数字0和字符串”0”对同一个表进行索引，但这两个索引的值及其所对应的元素是不同的。同样，字符串”+1”、”01”和”1”指向的也是不同的元素。当不能确定表索引的真实数据类型时，可以使用显式的类型转换：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; i = <span class="number">10</span>; j = <span class="string">&quot;10&quot;</span>; k = <span class="string">&quot;+10&quot;</span></span><br><span class="line">&gt; a = &#123;&#125;</span><br><span class="line">&gt; a[i] = <span class="string">&quot;nubmer key&quot;</span></span><br><span class="line">&gt; a[j] = <span class="string">&quot;string key&quot;</span></span><br><span class="line">&gt; a[k] = <span class="string">&quot;another string key&quot;</span></span><br><span class="line">&gt; a[i]			<span class="comment">-- 数值类型的键</span></span><br><span class="line">&gt; a[j]			<span class="comment">-- 字符串类型的键</span></span><br><span class="line">&gt; a[k]			<span class="comment">-- 另一个字符串类型的键</span></span><br><span class="line">&gt; a[<span class="built_in">tonumber</span>(j)] <span class="comment">-- 数值类型的键</span></span><br><span class="line">&gt; a[<span class="built_in">tonumber</span>(k)] <span class="comment">-- 数值类型的键</span></span><br></pre></td></tr></table></figure>
<p>如果不注意这一点，就会很容易在程序中引入诡异的Bug。<br>整型和浮点型类型的表索引则不存在上述问题。由于2和2.0的值相等，所以当它们被当作表索引使用时指向的是同一个表元素：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;&#125;</span><br><span class="line">&gt; a[<span class="number">2.0</span>] = <span class="number">10</span></span><br><span class="line">&gt; a[<span class="number">2.1</span>] = <span class="number">20</span></span><br><span class="line">&gt; a[<span class="number">2</span>]		<span class="comment">-- 10 </span></span><br><span class="line">&gt; a[<span class="number">2.1</span>]	<span class="comment">-- 20 </span></span><br></pre></td></tr></table></figure>
<p>更准确地说，当被用作表索引时，任何能够被转换为整型的浮点数都会被转换为整型数。</p>
<h2 id="表构造器"><a href="#表构造器" class="headerlink" title="表构造器"></a>表构造器</h2><p>表构造器是用来创建和初始化表的表达式，也是Lua语言中独有的也是最有用、最灵活的机制之一。<br>正如我们此前已经提到的，最简单的构造器是空构造器{}。表构造器也可以被用来初始化列表，例如，下例中使用字符串”Sunday”初始化了day[1]、使用字符串”Monday”初始化了day[2]，依次类推：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wndnesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(days[<span class="number">4</span>])			<span class="comment">-- Wednesday</span></span><br></pre></td></tr></table></figure>
<p>Lua语言还提供一种初始化记录式表的特殊语法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x = <span class="number">10</span>, y = <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码等价于：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;;</span><br><span class="line">a.x = <span class="number">10</span>;</span><br><span class="line">a.y = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>不过在第一种写法中，由于能够提前判断表的大小，所以运行速度更快。<br>无论哪种方式创建，都可以随时增加或删除元素：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w = &#123;x = <span class="number">0</span> ,y = <span class="number">0</span>, label = <span class="string">&quot;console&quot;</span>&#125;</span><br><span class="line">x = &#123;<span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">0</span>),<span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">1</span>),<span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">2</span>)&#125;</span><br><span class="line">w[<span class="number">1</span>] = <span class="string">&quot;another field&quot;</span>			<span class="comment">-- 把键1增加到表&quot;w&quot;中</span></span><br><span class="line">x.f = w							<span class="comment">-- 把键&quot;f&quot;增加到表&quot;w&quot;中</span></span><br><span class="line"><span class="built_in">print</span>(w[<span class="string">&quot;x&quot;</span>])					<span class="comment">-- 0</span></span><br><span class="line"><span class="built_in">print</span>(w[<span class="number">1</span>])						<span class="comment">-- another field</span></span><br><span class="line"><span class="built_in">print</span>(x.f[<span class="number">1</span>])					<span class="comment">-- another field</span></span><br><span class="line">w.x = <span class="literal">nil</span> 						<span class="comment">-- 删除字段&quot;x&quot;</span></span><br></pre></td></tr></table></figure>
<p>不过，正如此前所提到的，使用合适的构造器来创建表会更加高效和易读。<br>在同一个构造器中，可以混用记录式和列表式写法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">polyline = &#123;color = <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">			thickness = <span class="number">2</span>,</span><br><span class="line">			npoints   = <span class="number">4</span>,</span><br><span class="line">			&#123;x = <span class="number">0</span> ,y = <span class="number">0</span> &#125;,		<span class="comment">-- polyline[1]</span></span><br><span class="line">			&#123;x = <span class="number">-10</span>, y = <span class="number">0</span>&#125;,		<span class="comment">-- polyline[2]</span></span><br><span class="line">			&#123;x = <span class="number">-10</span>, y = <span class="number">1</span>&#125;,		<span class="comment">-- polyline[3]</span></span><br><span class="line">			&#123;x = <span class="number">0</span> , y = <span class="number">1</span>&#125;			<span class="comment">-- polyline[4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的示例也同时展示了如何创建嵌套表以表达更加复杂的数据结构。每一个元素polyline[i]都是代表一条记录的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(polyline[<span class="number">2</span>].x)			<span class="comment">-- -10</span></span><br><span class="line"><span class="built_in">print</span>(polyline[<span class="number">4</span>].y)			<span class="comment">-- 1</span></span><br></pre></td></tr></table></figure>
<p>不过，这两种构造器都有各自的局限。例如，使用这两种构造器时，不能使用负数索引舒适化表元素，不能使用不符合规范的标识符作为索引。对于这类需求，可以使用另一种更加通用的构造器，即通过方括号括起来的表达式显式地指定每一个索引：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">opnames = &#123;[<span class="string">&quot;+&quot;</span>] = <span class="string">&quot;add&quot;</span>, [<span class="string">&quot;-&quot;</span>] = <span class="string">&quot;sub&quot;</span> ,</span><br><span class="line">		   [<span class="string">&quot;*&quot;</span>] = <span class="string">&quot;mul&quot;</span>, [<span class="string">&quot;/&quot;</span>] = <span class="string">&quot;div&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">20</span></span><br><span class="line">s = <span class="string">&quot;-&quot;</span></span><br><span class="line">a = &#123;[i + <span class="number">0</span>] = s, [i + <span class="number">1</span>] = s..s, [i + <span class="number">2</span>] = s..s..s&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(opnames[s])		<span class="comment">-- sub</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">22</span>])			<span class="comment">-- ---</span></span><br></pre></td></tr></table></figure>
<p>这种构造器虽然冗长，但非常灵活，不管是记录式构造器还是列表式构造器军师其特殊形选的。例如，下面的几种表达式就相互等价：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125;			<span class="comment">-- &#123;[&quot;x”] = 0, [&quot;y&quot;] = 0&#125;</span></span><br><span class="line">&#123;<span class="string">&quot;r&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;			<span class="comment">-- &#123;[1] = &quot;r&quot;, [2] = &quot;g&quot;, [3] = &quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>在最后一个元素后总是可以紧跟一个逗号。虽然总是有效，但是否加最后一个逗号是可选的。<br>这种灵活性使得开发人员在编写表构造器时不需要对最后一个元素进行特殊处理。<br>最后，表构造器中的逗号也可以使用分号代替，这主要是为了兼容Lua语言的旧版本。</p>
<h2 id="数组、列表和序列"><a href="#数组、列表和序列" class="headerlink" title="数组、列表和序列"></a>数组、列表和序列</h2><p>如果想表示常见的数组或列表，那么只需要使用整型作为索引的表即可。同时，也不需要预先声明表的大小，只需要直接初始化我们需要的元素即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a  = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span> </span><br><span class="line">	a [i] = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>鉴于能够使用任意值对表进行索引，我们也可以使用任意数字作为第一个元素的索引。不过，在Lua语言中，数组索引按照惯例是从1开始的（不像C语言从0开始），Lua语言中的其他很多机制也遵循这个惯例。<br>在操作表时，往往必须事先获取列表的长度。列表的长度可以存放在常量中，也可以存放在其他变量或数据结构中。通常，我们把列表的长度保持在表中某个非数值类型的字段中。当然，列表的长度经常也是隐形的。请注意，由于为初始化的元素均为nil，所以可以利用nil值来标记列表的结束。例如，当向一个列表中写入了10行数据后，由于该列表的数值类型的索引为1,2,…,10，所以可以很容易地知道列表的长度就是10.这种技巧只有在列表中不存在空洞时才有效，此时我们把这种所有元素都不为nil的数组称为序列。<br>Lua语言提供了获取序列长度的操作符#。正如我们之前所看到的，对于字符串而言，该操作符返回字符串的字节数；对于表而言，该操作符返回表对应序列的长度。例如，可以使用如下代码输出上例中读入的内容：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> ,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(a[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>长度操作符也操作序列提供了几种有用的写法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[#a])			<span class="comment">-- 输出序列&#x27;a&#x27;的最后一个值</span></span><br><span class="line">a[#a] = <span class="literal">nil</span>				<span class="comment">-- 移除最后一个值</span></span><br><span class="line">a[#a + <span class="number">1</span>] = v			<span class="comment">-- 把&#x27;v&#x27;加到序列的最后</span></span><br></pre></td></tr></table></figure>
<p>对于中间存在空洞的列表而言，序列长度操作符是不可靠的，它只能用于序列。更准确地说，序列是由指定的n个正数数值类型的键所组成集合[1,…,n]形成的表。特别地，不包含数值类型键的表就是长度为零的序列。<br>将长度操作符用于存在空洞的列表的行为是Lua语言中具有争议的内容之一。在过去几年中，很多人建议在操作存在空洞的列表时直接抛出异常，也有人建议扩展长度操作符的语义。然而，这些建议都是说起来容易做起来难。其根源在于列表实际上是一个表，而对于表来说，“长度”的概念在一定程度上是不容易理解的。例如，考虑如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="literal">nil</span>    <span class="comment">--什么也没有做</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们这里可以很容易确定这是一个长度为4、在索引2的位置上存在空洞的列表。不过，对于下面这个类似的示例是否也如此呢？</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>是否应该认为a 是一个具有10000个元素，9998个空洞的列表？如果代码进行了如下的操作：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">10000</span>] = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>那么该列表的长度会变成多少？由于代码删除了最后一个元素，该列表的长度是不是变成了9999？或者由于代码只是将最后一个元素变成了nil，该列表的长度仍然是10000？又或者该列表的长度缩成了1？<br>另一种常见的建议是让#操作符返回表中全部元素的数量。虽然这种语义听起来清晰且定义明确，但并非特别有用和符合直觉。请考虑下我们在此讨论过的所有例子，然后思考一下这些例子而言，为什么让#操作符返回表中全部元素的数量并非特备有用。<br>更复杂的列表是以nil结尾的情况。请问如下的列表的长度是多少：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，对于Lua语言而言，一个为nil的字段和一个不存在的元素没有区别。因此，上述列表与{10,20,30}是等价的，其长度为3，而不是5.<br>可以将以nil结尾的列表当作一种非常特殊的情况。不过，很多列表时通过逐个添加各个元素创建出来的。任何按照这种方式构造出来的带有空洞的列表，其最后一定存在为nil的值。<br>尽管讨论了这么多，程序中的大多数列表其实都是序列。正因如此，在多数情况下使用长度操作符是安全的。在确实需要处理存在空洞的列表时，应该将列表的长度显式地保存起来。</p>
<h2 id="遍历表"><a href="#遍历表" class="headerlink" title="遍历表"></a>遍历表</h2><p>我们可以用是pairs迭代器遍历表中的键值对：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>, <span class="built_in">print</span>, x = <span class="number">12</span>, k = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k ,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1	10</span></span><br><span class="line"><span class="comment">-- k	hi</span></span><br><span class="line"><span class="comment">-- 2	function:0x420610</span></span><br><span class="line"><span class="comment">-- x 	12</span></span><br></pre></td></tr></table></figure>
<p>受限于表在Lua中的底层实现机制，遍历过程中元素的出现顺序可能是随机的，相同的程序在每次运行时也可能产生不同的顺序。唯一可以确定的是，在遍历的过程中每个元素会且只会出现一次。<br>对于列表而言，可以使用ipairs迭代器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>, <span class="built_in">print</span>, x = <span class="number">12</span>, k = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k ,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1	10</span></span><br><span class="line"><span class="comment">-- 2	hi</span></span><br><span class="line"><span class="comment">-- 3	function:0x420610</span></span><br><span class="line"><span class="comment">-- 4 	12</span></span><br></pre></td></tr></table></figure>
<p>此时，Lua会确保遍历是按照顺序进行的。<br>另一种遍历序列的方法是使用数值型for循环：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>, <span class="built_in">print</span>, x = <span class="number">12</span>, k = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> , #t <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k , t[k])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1	10</span></span><br><span class="line"><span class="comment">-- 2	hi</span></span><br><span class="line"><span class="comment">-- 3	function:0x420610</span></span><br><span class="line"><span class="comment">-- 4 	12</span></span><br></pre></td></tr></table></figure>
<h2 id="安全访问"><a href="#安全访问" class="headerlink" title="安全访问"></a>安全访问</h2><p>考虑如下的情景：我们想确认在指定的库中是否存在某个函数。如果我们确定这个库确实存在，那么可以直接使用<code>if lib.foo then ...;</code>否则，就得使用形如<code>if lib and lib.foo then ...</code>的表达式。<br>当表的嵌套深度变得比较深时，这种写法就会很容易出错，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip = company <span class="keyword">and</span> company.director <span class="keyword">and</span> company.director.address <span class="keyword">and</span> company.director.address.zipcode</span><br></pre></td></tr></table></figure>
<p>这种写法不仅冗长而且低效，该写法在一次成功的访问中对表进行了6次访问而非3词访问。<br>对于这种情景，诸如C#的一些编程语言提供了一种安全访问操作符。在C#中，这种安全访问操作符被记为<code>?.</code>。例如，对于表达式<code>a?.b</code>，当a为nil时，其结果是nil而不会产生异常。使用这种操作符，可以将上例改为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip = company?.director?.address?.zipcode</span><br></pre></td></tr></table></figure>
<p>如果上述的成员访问过程中出现nil，安全访问操作符会正确地处理nil并最终返回nil。<br>Lua语言并没有提供安全访问操作符，并且认为也不应该提供这种操作符。一方面，Lua语言在设计上力求简单；另一方面，这种操作符也是非常有争议的，很多人就无理由认为该操作符容易导致无意的编程错误。不过，我们可以使用其他语句在Lua语言中模拟安全访问操作符。<br>对于表达式 <code>a or &#123;&#125;</code>，当a为nil时其结果是一个空表。因此，对于表达式<code>(a or &#123;&#125;).b</code>，当a为nil时其结果也同样是nil。这样，我们就可以将之前的例子重写为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip = (((company <span class="keyword">or</span> &#123;&#125;).director <span class="keyword">or</span> &#123;&#125;).address <span class="keyword">or</span> &#123;&#125;).zipcode</span><br></pre></td></tr></table></figure>
<p>再进一步，我们还可以写得更短更高效：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E = &#123;&#125;</span><br><span class="line">...</span><br><span class="line">zip = (((company <span class="keyword">or</span> E).director <span class="keyword">or</span> E).address <span class="keyword">or</span> E).zipcode</span><br></pre></td></tr></table></figure>
<p>确实，上述的语法比安全访问操作符更加复杂。不过尽管如此，表中的每一个字段名都只被使用了一次，从而保证了尽可能少地对表进行访问；同时，还避免了向语言中引入新的操作符。</p>
<h2 id="表标准库"><a href="#表标准库" class="headerlink" title="表标准库"></a>表标准库</h2><p>表标准库提供了操作列表和序列的一些常用函数。<br>函数<code>table.insert</code>向序列的指定位置插入一个元素，其他元素依次后移。例如，对于列表t &#x3D; {10,20,30}，在调用table.insert(t,1,15)后它会变成{15,10,20,30}，另一种特殊但常见的情况是调用insert时不指定位置，此时函数会在序列的最后插入指定的元素，不会移动任何元素。例如，下述代码从标准输入中安行读入内容并将其保存到一个序列中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(t,line)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(#t)</span><br></pre></td></tr></table></figure>
<p>函数<code>table.remove</code>删除后并返回序列指定位置的元素，然后将其后的元素向前移动填充删除元素后造成的空洞。如果在调用该函数时不指定位置，该函数会删除序列的最后一个元素。<br>借助这个函数，可以很容易地实现栈、队列和双端队列。以栈的实现为例，我们可以使用t &#x3D; {}来表示栈，Push操作可以使用table.insert(t,x)实现，Pop操作可以使用table.remove(t)实现，调用table.insert(t,1,x)可以实现在栈的顶部进行插入，调用table.remove(t,1)可以从栈的顶部移除。由于后两个函数设计表中其他元素的移动，所以其运行效率并不是特别的高。当然，由于table标准库中的这些函数是使用C语言实现的，所以移动元素所涉及循环的性能开销也并不是太昂贵。因而，对于几百个元素组成的小数组来说这种实现已经够了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/10/Lua%E4%B8%AD%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="clw7ne0x700254sad7psobtq5" data-title="Lua连续教程之Lua中表的使用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/08/Lua%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2020-04-07T16:42:19.000Z" itemprop="datePublished">2020-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/08/Lua%E5%AD%97%E7%AC%A6%E4%B8%B2/">Lua连续教程之Lua字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>字符串用于文本。Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍。在Lua语言中，操作100K或者1M个字母组成的字符串的程序也很常见。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>Lua语言中的字符串是不可变值。我们不能像在C语言中那样直接改变某个字符串中的某个字符，但是我们可以通过创建一个新的字符串的方式来达到修改的目的。例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;one string&quot;</span></span><br><span class="line">b = <span class="built_in">string</span>.<span class="built_in">gsub</span>(a,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;another&quot;</span>) <span class="comment">--改变字符串中的某些部分</span></span><br><span class="line"><span class="built_in">print</span>(a)				<span class="comment">--one string</span></span><br><span class="line"><span class="built_in">print</span>(b)				<span class="comment">--another string</span></span><br></pre></td></tr></table></figure>
<p>像Lua语言中的其他对象一样，Lua语言中的字符串也是自动内存管理的对象之一。这意味着Lua语言会负责字符串的分配和释放，开发人员无须关注。<br>可以使用长度操作符(#)获取字符串的长度：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#a)			<span class="comment">--5</span></span><br><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;good bye&quot;</span>)  <span class="comment">--8</span></span><br></pre></td></tr></table></figure>
<p>该操作符返回字符串占用的字节数，在某些编码中，这个值可能与字符串中字符的个数不同。<br>我们可以使用连接操作符<code>..</code>（两个点）来进行字符串连接。如果操作数中存在数值，那么Lua语言会先把数值转换成字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&quot;Hello&quot;</span> .. <span class="string">&quot;World&quot;</span> 		<span class="comment">-- Hello World</span></span><br><span class="line">&gt; <span class="string">&quot;result is &quot;</span> .. <span class="number">3</span>			<span class="comment">-- result is 3</span></span><br></pre></td></tr></table></figure>
<p>在某些语言中，字符串连接使用的是加号，但实际上3+5和3..5是不一样的。<br>应该注意，在Lua语言中，字符串是不可变量。字符串连接总是创建一个新字符串，而不会改变原来作为操作数的字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&gt; a .. <span class="string">&quot;World&quot;</span>      <span class="comment">-- Hello World</span></span><br><span class="line">&gt; a 				<span class="comment">-- Hello</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>我们可以使用一对双引号或单引号来声明字符串常量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot; a line &quot;</span></span><br><span class="line">b = <span class="string">&#x27; another line&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用双引号和单引号声明字符串是等价的。它们两者唯一的区别在于，使用双引号声明的字符串中出现单引号时，单引号可以不用转义；使用单引号声明的字符串中出现双引号时，双引号可以不用转义。<br>Lua语言中的字符串支持下列C语言风格的转义字符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a			响铃（bell）</span><br><span class="line">\b			退格（back space）</span><br><span class="line">\f			换页（form feed）</span><br><span class="line">\n			换行（newline）</span><br><span class="line">\r			回车（carriage <span class="keyword">return</span>）</span><br><span class="line">\t			水平制表符（horizontal tab）</span><br><span class="line">\v			垂直制表符（vertical tab）</span><br><span class="line">\\			反斜杠（backslash）</span><br><span class="line">\<span class="string">&quot;			双引号（double quote）</span></span><br><span class="line"><span class="string">\&#x27;			单引号（single quote）</span></span><br></pre></td></tr></table></figure>
<p>下述示例展示了转义字符的使用方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">print</span>(<span class="string">&quot;one line \n next line \n\&quot;in quotes\&quot;,&#x27;in quotes&#x27; &quot;</span>)</span><br><span class="line">one line</span><br><span class="line"><span class="built_in">next</span> line</span><br><span class="line"><span class="string">&quot;in quotes&quot;</span> , <span class="string">&#x27;in quotes&#x27;</span></span><br><span class="line">&gt;<span class="built_in">print</span>(<span class="string">&#x27;a backslash inside quotes:\&#x27; \\\ &#x27;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">a backslash inside quotes: &#x27;</span>\<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;print(&quot;a simpler way: &#x27;</span>\\<span class="string">&#x27; &quot;)</span></span><br><span class="line"><span class="string">a simpler way: &#x27;</span>\<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在字符串中，还可以通过转义\add和\xhh来声明字符。其中，add是由最多3个十进制数字组成的序列，hh是由两个且必须是两个十六进制数字组成的序列。</p>
<h2 id="长字符串-多行字符串"><a href="#长字符串-多行字符串" class="headerlink" title="长字符串&#x2F;多行字符串"></a>长字符串&#x2F;多行字符串</h2><p>像长注释&#x2F;多行注释一样，可以使用一对双括号来声明长度字符串&#x2F;多行字符串常量。被方括号括起来的内容可以包含很多行，并且内容中的转义序列不会被转义。此外，如果多行字符串中的第一个字符是换行符，那么这个换行符会被忽略。多行字符串在声明包含大段代码的字符串时非常方便，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">	&lt;title&gt; An HTML Page&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">	&lt;a href = &quot;http://www.lua.org&quot;&gt;Lua&lt;a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br></pre></td></tr></table></figure>
<p>有时字符串中可能有类似a &#x3D; b[c[i]]这样的内容，或者，字符串中可能有被注释掉的代码。为了应对这些情况，可以在两个左方括号之间加上任意数量的等号，如[&#x3D;&#x3D;&#x3D;[。这样，字符串常量只有在遇到了包含了相同数量等号的两个右括号时才会结束。Lua语言的语法扫描器会忽略所含等号数量不相同的方括号。通过选择恰当数量的等号，就可以在无须修改原字符串的情况下声明任意的字符串常量了。<br>对注释而言，这种机制也同样有效。例如，我们可以使用–[&#x3D;和]&#x3D;]来进行长注释，从而降低了对内部已经包含注释的代码进行注释的难度。<br>当代码中需要使用常量文本时，使用长字符串是一种理想的选择。但是，对于非文本的常量我们不应该滥用长字符串。虽然Lua语言中的字符串常量可以包含任意字节，但是滥用这个特行并不明智。同时，像”\r\n”一样的EOF序列在被读取的时候可能会被归一化成”\n”。作为替代方案，最好就是把这些可能引起歧义的二进制数据用十进制或十六进制的数值转义系列进行表示，例如”\x13\x01\xA1\xBB”。不过，由于这种转义表示行程的字符串往往很长，所以对于长字符串来说仍可能是个问题。针对这种情况，从Lua5.2开始引入了转义序列\z，该转义符会跳过其后的所有空白字符，直到遇到第一个非空白字符。下列中演示了该转义符的使用方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">&quot;\x00\x01\x02\x03\x04\x05\x06\x07\z</span></span><br><span class="line"><span class="string">		\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F&quot;</span></span><br></pre></td></tr></table></figure>
<p>第一行最后的\z会跳过其后的EOF和第二行的制表符，因此最终得到的字符串中，\x08实际上是紧跟着\x07的。</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>Lua语言在运行时提供了数值和字符串之间的自动转换。针对字符串的所有算术操作会尝试将字符串转换为数值。Lua语言不仅仅在算术操作时进行这种强制类型转换，还会在任何需要数值的情况下进行，例如函数math.sin的参数。<br>相反，当Lua语言发现在需要字符串的地方出现了数值时，它就会把数值转换为字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span> .. <span class="number">20</span> )  	<span class="comment">--1020</span></span><br></pre></td></tr></table></figure>
<p>当在数值后紧接着使用字符串连接时，必须使用空格将它们分开，否则Lua语言会把第一个点当成小数点。<br>很多人认为自动强制类型转换算不上是Lua语言中的一项好设计。作为原则之一，建议最好不要完全寄希望于自动强制类型转换。虽然在某些场景下这种机制很便利，但同时也给语言和适用这种机制的程序带来了复杂性。<br>作为这种”二类状态”的表现之一，Lua5.3没有实现强制类型转换娱整型的集成，而是采用了另一种更简单和快速的实现方式：算术运算的规则就是只有在两个操作数都是整型值时结果才是整型。因此，由于字符串不是整型值，所以任何有字符串参与的算术运算都会被当做浮点运算处理：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;10&quot;</span> + <span class="number">1</span>          <span class="comment">--11.0</span></span><br></pre></td></tr></table></figure>
<p>如果需要显示地将一个字符串转换成数值，那么可以使用函数tonumber。当这个字符串的内容不能表示为有效数字时该函数返回nil；否则，该函数就按照Lua语法扫描器的规则返回对应的整型值或浮点类型值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; tounmber(<span class="string">&quot; -3 &quot;</span>)			<span class="comment">-- -3</span></span><br><span class="line">&gt; tounmber(<span class="string">&quot; 10e4 &quot;</span>)		<span class="comment">-- 100000.0</span></span><br><span class="line">&gt; tounmber(<span class="string">&quot; 10e &quot;</span>)         <span class="comment">-- nil (not a valid number)</span></span><br><span class="line">&gt; tounmber(<span class="string">&quot; 0x1.3p - 4&quot;</span>)   <span class="comment">-- 0.07421875</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，函数tonumber使用的是十进制，但是也可以指明使用二进制到三十六进制之间的任意进制：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; tounmber(<span class="string">&quot;100101&quot;</span>, <span class="number">2</span>)			<span class="comment">-- 37</span></span><br><span class="line">&gt; tounmber(<span class="string">&quot;fff&quot;</span> ,<span class="number">16</span>)			<span class="comment">-- 4095</span></span><br><span class="line">&gt; tounmber(<span class="string">&quot;-ZZ&quot;</span>,<span class="number">36</span>)      	<span class="comment">-- -1295</span></span><br><span class="line">&gt; tounmber(<span class="string">&quot;987&quot;</span>,<span class="number">8</span>)   			<span class="comment">-- nli</span></span><br></pre></td></tr></table></figure>
<p>在最后一行，对于制定的进制而言，传入的字符串是一个无效值，因此函数tonumber返回nil。<br>调用函数tonumber可以将数值转换成字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(<span class="number">10</span>) == <span class="string">&quot;10&quot;</span>)   <span class="comment">--true</span></span><br></pre></td></tr></table></figure>
<p>上述的这种转换总是有效，但我们需要记住，使用这种转换时并不能控制输出字符串的格式。</p>
<h2 id="字符串标准库"><a href="#字符串标准库" class="headerlink" title="字符串标准库"></a>字符串标准库</h2><p>Lua语言解释器本身处理字符串的功能是十分有限的。一个程序能够创建字符串、连接字符串、比较字符串和获取字符串的长度，但是，它并不能提取字符串的子串或检视字符串的内容。Lua语言处理字符串的完整能力来自其字符串标准库。<br>字符串标准库中的一些函数非常简单：函数string.len(s)返回字符串s的长度，等价于#s。函数string.rep(s,n)返回将字符串s重复n遍的结果。可以通过调用string.rep(“a”,$2^{20}$)创建一个1MB大小的字符串。函数string.reverse用于字符串翻转。函数string.lower(s)返回一份s的副本，其中所有的大写字母都被转换成小写字母，而其他字符则保持不变。函数string.upper与之相反，该函数会将小写字母转换成大写字母。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>)			<span class="comment">-- 游戏开发abcabc</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">reverse</span>(<span class="string">&quot;A Long Line!&quot;</span>)	<span class="comment">-- !eniL gnoL A</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">lower</span>(<span class="string">&quot;A Long Line!&quot;</span>)		<span class="comment">-- a long line!</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">upper</span>(<span class="string">&quot;A Long Line!&quot;</span>)		<span class="comment">-- A LONG LINE!</span></span><br></pre></td></tr></table></figure>
<p>作为一种典型的应用，我们可以使用如下代码在忽略大小写差异的原则下比较两个字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">lower</span>(a) &lt; <span class="built_in">string</span>.<span class="built_in">lower</span>(b)</span><br></pre></td></tr></table></figure>
<p>函数string.sub(s,i,j)从字符串s中提取第i个到第j个字符。该函数也支持负数索引，负数索引从字符串的结尾开始计数：索引-1代表字符串的最后一个字符，索引-2代表倒数第二个字符，依此类推。这样，对字符串s调用函数string.sub(s,1,j)得到的是字符串s中长度为j的前缀，调用string.sub(s,j,-1)得到的是字符串s从第j个字符开始的后缀，调用string.sub(s,2,-2)返回的是去掉字符串s中第一个和最后一个字符的结果。<br>请注意，Lua语言中的字符串是不可变的。和Lua语言中的所有其他函数一样，函数string.sub不会改变原有字符串的值，它只会返回一个新字符串。一种常见的误解是以为string.sub(s,2,-2)返回的是修改后的s。如果需要修改原字符串，那么必须把心的值赋值给它：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">sub</span>(s,<span class="number">2</span>,<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p>函数string.char 和string.byte用于转换字符串及其内部数值表示。函数string.char接收零个或多个证书作为参数，然后将每个整数转换成对应的字符，最后返回由这些字符连接而成的字符串。函数string.byte(s,i)返回字符串s中第i 个字符的内部数值表示，该函数的第二个参数是可选的。调用string.byte(s)返回字符串s中第一个字符的内部数值表示。在下面例子中，假定字符串是用ASCII表示的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">97</span>))			<span class="comment">-- a</span></span><br><span class="line">i = <span class="number">99</span>; <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(i,i+<span class="number">7</span>,i+<span class="number">2</span>))		<span class="comment">-- cde</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>))			<span class="comment">-- 97</span></span><br><span class="line">pring(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span> , <span class="number">2</span>))		<span class="comment">-- 98</span></span><br><span class="line">pring(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span> , <span class="number">-1</span>))		<span class="comment">-- 99</span></span><br></pre></td></tr></table></figure>
<p>在最后一行中，使用负数索引来访问字符串的最后一个字符。<br>调用string.byte(s,i,j)返回索引i到j之间的所有字符的数字表示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">1</span>,<span class="number">2</span>)     <span class="comment">-- 97 98</span></span><br></pre></td></tr></table></figure>
<p>一种常见的写法是{string.byte(s,1,-1)}，该表达式会创建一个由字符串s中的所有字符代码组成的表。<br>函数string.format是用于进行字符串格式化和将数值输出为字符串的强大工具，该函数会返回一个参数的副本，其中的每一个指示符都会被替换为使用对应格式化后的对应参数。格式化字符串中的指示符与C语言中函数printf的规则类似，一个指示符由一个百分号和一个代表格式化方式的字母组成：d代表一个十进制整数、x代表一个十六进制整数、f代表一个浮点数、s代表字符串等等。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;x = %d y = %d&quot;</span>,<span class="number">10</span> ,<span class="number">20</span>)			<span class="comment">-- x = 10 y = 20</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;x = %x&quot;</span>, <span class="number">200</span>)					<span class="comment">-- x = c8</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;x = 0x%x&quot;</span>, <span class="number">200</span>)				<span class="comment">-- x = 0xC8</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;x = %f&quot;</span>, <span class="number">200</span>)					<span class="comment">-- x = 200.000000</span></span><br><span class="line">&gt; tag, title = <span class="string">&quot;h1&quot;</span>, <span class="string">&quot;a title&quot;</span></span><br><span class="line">&gt; <span class="built_in">string</span>.foramt(<span class="string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>,tag,title,tag)	<span class="comment">-- &lt;h1&gt; a title&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure>
<p>在百分号和字母之间可以包含用于控制格式细节的其他选项。例如，可以指定一个浮点数中小数的位数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.foramt(<span class="string">&quot;pi = %.4f&quot;</span>, <span class="built_in">math</span>.<span class="built_in">pi</span>))			<span class="comment">-- pi = 3.1416</span></span><br><span class="line">d = <span class="number">5</span>; m = <span class="number">11</span>; y = <span class="number">1990</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%02d/%02d/%04d&quot;</span>, d, m, y))		<span class="comment">-- 05/11/1990</span></span><br></pre></td></tr></table></figure>
<p>在上例中，%.4f表示小数点后保留4位小数；%02d表示一个十进制数至少由两个数字组成，不足两个数字的用0补齐，而%2d则表示用空格来补齐。关于这些指示符的完整描述可以参考C语言printf函数的相关文档。<br>可以使用冒号操作符像调用字符串的一个方法那样调用字符串中标准库中的所有函数。例如，string.sub(s,i,j)可以重写成s:sub(i,j)，string.upper(s)可以重写成s:supper()。<br>字符串标准库还包括了几个基于模式匹配的函数。函数string.find用于在指定的字符串中进行模式搜索：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;hello world&quot;</span> , <span class="string">&quot;wor&quot;</span>)		<span class="comment">-- 7 9</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;hello world&quot;</span> , <span class="string">&quot;war&quot;</span>)		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>如果该函数在指定的字符串中找到了匹配的模式，则返回模式的开始和结束位置，否则返回nil。函数string.gsub(Global SUBstitution)则把所有匹配的模式用另一个字符串替换：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;l&quot;</span> , <span class="string">&quot;.&quot;</span>)			<span class="comment">-- he..o wor.d 3</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;ll&quot;</span> , <span class="string">&quot;..&quot;</span>)       <span class="comment">-- he..o world 1</span></span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;.&quot;</span>)			<span class="comment">-- hello world 0</span></span><br></pre></td></tr></table></figure>
<p>该函数还会在第二个返回值中返回发生替换的次数。</p>
<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>UTF-8是Web环境中用于Unicode的主要编码之一。由于UTF-8编码娱ASCII编码部分兼容，所以UTF-8对于Lua来说是一种理想的编码方式。这种兼容性保证了用于ASCII字符串的一些字符操作技巧无须修改就可以用于UTF-8字符串。<br>UTF-8使用变长的多个字节来编码一个Unicode字符。例如，UTF-8编码使用一个字节的65来代表A，使用两个字节的215-144代表希伯来语字符Aleph。UTF-8使用一个字节表示所有ASCII范围内的字符（小于128）。对于其他字符，则使用字节序列表示，其中第一个字节的范围时[194,244]，而后续的字节范围时[128,191]。更准确地说，对于两个字节组成的序列，第一个字节的范围是[194,223]；对于三个字节组成的序列来说，第一个字节的范围是[224,239]；对于四个字节组成的序列来说，第一个字节的范围是[240,224]，这些范围互相之间均不重叠。这种特点保证了任意字符对应的字节序列不会在其他字符对应的字节序列中出现。特别地，一个小于128的字节永远不会在多字节序列中，它只会代表与之对应的ASCII字符。<br>Lua语言中的一些机制对UTF-8字符串来说同样“有效”。由于Lua语言使用8个字节来编码字符，所以可以像操作其他字符串一样读写和存储UTF-8字符串。字符串常量也可以包含UTF-8数据。字符串连接UTF-8字符串同样适用。对字符串比较会按照Unicode编码中的字符代码顺序进行。<br>Lua语言的操作系统库和输入输出库是与对应系统之间的主要接口，所以它们是否支持UTF-8取决于对应的操作系统。例如，在Linux操作系统下文件名要使用UTF-8编码，而在Windows操作系统下文件名使用UTF-16编码。因此，如果要在Windows操作系统中处理Unicode文件名，要么使用额外的库，要么就修改Lua语言的标准库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/08/Lua%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="clw7ne0x8002c4sad9fi9eqth" data-title="Lua连续教程之Lua字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua中的数值" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/06/Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/" class="article-date">
  <time class="dt-published" datetime="2020-04-06T15:56:01.000Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/06/Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/">Lua连续教程之Lua中的数值</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>我们可以使用科学计数法（一个可选的十进制部分外加一个可选的十进制指数部分）书写数值常量，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">4</span>             <span class="comment">--4</span></span><br><span class="line">&gt; <span class="number">0.4</span>			<span class="comment">--0.4</span></span><br><span class="line">&gt; <span class="number">4.57e-3</span>		<span class="comment">--0.00457</span></span><br><span class="line">&gt; <span class="number">0.3e12</span>		<span class="comment">--3.0000000000.0</span></span><br><span class="line">&gt; <span class="number">5E+20</span>			<span class="comment">--5e+20</span></span><br></pre></td></tr></table></figure>
<p>具有十进制小数或者指数的数值会被当做浮点型值，否则会被当做整数值。<br>整型数和浮点数的类型都是<code>number</code>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="number">3</span>)			<span class="comment">--number</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="number">3.5</span>)			<span class="comment">--number</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="number">3.0</span>)			<span class="comment">--number</span></span><br></pre></td></tr></table></figure>
<p>由于整型值和浮点型值的类型都是”number”，所以它们是可以互相转换的。同时，具有相同算术值的整型值和浮点值在Lua语言中是相等的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span> == <span class="number">1.0</span> 			<span class="comment">--true</span></span><br><span class="line">&gt;<span class="number">-3</span> == <span class="number">-3.0</span> 		<span class="comment">--ture</span></span><br><span class="line">&gt;<span class="number">0.2e3</span>	== <span class="number">200</span> 		<span class="comment">--ture</span></span><br></pre></td></tr></table></figure>
<p>在少数情况下，当需要区分整型值和浮点型值时，可以使用函数math.type:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">3</span>)			<span class="comment">--integer</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">3.0</span>)			<span class="comment">--float</span></span><br></pre></td></tr></table></figure>
<p>在Lua5.3中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">3</span>			<span class="comment">--3</span></span><br><span class="line">&gt;<span class="number">3.0</span>		<span class="comment">--3.0</span></span><br><span class="line">&gt;<span class="number">1000</span>		<span class="comment">--1000</span></span><br><span class="line">&gt;<span class="number">1e3</span>		<span class="comment">--1000.0</span></span><br></pre></td></tr></table></figure>
<p>Lua语言还像其他语言一样也支持0x开头的十六进制常量。与其他很多变成语言不通，Lua语言还支持十六进制的浮点数，这种十六进制浮点数部分由小数部分和以p或P开头的指数部分组成。例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">0xff</span>		<span class="comment">--255</span></span><br><span class="line">&gt;<span class="number">0x1A3</span>		<span class="comment">--419</span></span><br><span class="line">&gt;<span class="number">0x0</span><span class="number">.2</span>		<span class="comment">--0.125</span></span><br><span class="line">&gt;<span class="number">0x1</span>p<span class="number">-1</span>		<span class="comment">--0.5</span></span><br><span class="line">&gt;<span class="number">0</span>x.bp2		<span class="comment">--42.75</span></span><br></pre></td></tr></table></figure>
<p>可以使用参数%a参数，通过函数string.format对这种格式进行格式化输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%a&quot;</span>,<span class="number">419</span>)		<span class="comment">--0x1.a3p+8</span></span><br><span class="line">&gt;<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%a&quot;</span>,<span class="number">0.1</span>)		<span class="comment">--0x1.999999999999ap-4</span></span><br></pre></td></tr></table></figure>
<p>虽然这种格式很难阅读，但是这种格式可以保留所有浮点数的精度，并且比十进制的转换速度更快。</p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>除了加减乘除、取负数等常见的算术运算外，Lua语言还支持取整除法、取模和指数运算。<br>两个整数型值进行加减乘除和取负操作的结果仍然是整型值。对于这些算术运算而言，操作数是用整型还暗示浮点型表示的整数都没有区别：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">13</span> + <span class="number">15</span> 		<span class="comment">--28</span></span><br><span class="line">&gt;<span class="number">13.0</span> + <span class="number">15.0</span> 	<span class="comment">--28.0</span></span><br></pre></td></tr></table></figure>
<p>如果两个操作数都是整型值，那么结果也是整型值；否则，结果就是浮点型值。当操作数一个是整型值一个是浮点型值时，Lua语言会在进行算术运算前将整型值转换为浮点型值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">13.0</span> + <span class="number">25</span> 		<span class="comment">--38.0</span></span><br><span class="line">&gt;-(<span class="number">3</span> * <span class="number">6.0</span>)		<span class="comment">--18.0</span></span><br></pre></td></tr></table></figure>
<p>由于两个整数相除的结果并不一定是整数，因此除法不遵循上述规则。为了避免两个整型值相除和两个浮点型值相除导致不一样的结果，除法运算操作永远是浮点数且产生浮点型值的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;3.0 / 2.0				--1.5</span><br><span class="line">&gt;3 / 2					--1.5</span><br></pre></td></tr></table></figure>
<p>Lua5.3针对整数除法引入了一个称为floor除法的新算术运算符&#x2F;&#x2F;。顾名思义，floor除法会对得到的商向负无穷取整，从而保证结果是一个整数。这样，floor除法就可以与其他算术运算一样遵循同样的规则：如果操作数都是整型值，那么结果就是整型值，否则就是浮点型值</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">3</span> // <span class="number">2</span>			<span class="comment">--1</span></span><br><span class="line">&gt;<span class="number">3.0</span> // <span class="number">2</span>		<span class="comment">--1.0</span></span><br><span class="line">&gt;<span class="number">6</span> // <span class="number">2</span>			<span class="comment">--3</span></span><br><span class="line">&gt;<span class="number">6.0</span> // <span class="number">2.0</span> 	<span class="comment">--3.0</span></span><br><span class="line">&gt;<span class="number">-9</span> // <span class="number">2</span>		<span class="comment">--5</span></span><br><span class="line">&gt;<span class="number">1.5</span> // <span class="number">0.5</span>		<span class="comment">--3.0</span></span><br></pre></td></tr></table></figure>
<p>下面公式是取模运算的定义：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a % b == a - ((a // b ) * b )</span><br></pre></td></tr></table></figure>
<p>如果操作数是整数，那么取模运算的结果也是整数。因此，取模运算也遵从与算术运算相同的规律，即如果两个操作数均是整型值，则结果为整型，否则为浮点型。<br>对于整型操作数而言，取模运算的含义没有什么特别的，其结果的符号永远与第二个操作数的符号保持一致。特别地，对于任意指定的正常数K，即使x是负数，表达式x%K的结果也永远在[0,K-1]之间。例如，对于任意整数值i，表达式i%2的结果均是0或1。<br>对于实数类型的操作数而言，取模运算有一些不同。例如，x-x%0.01恰好是x保留两位小数的结果，x-x%0.001恰好是x保留三位小数的结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;x = <span class="built_in">math</span>.<span class="built_in">pi</span></span><br><span class="line">&gt;x - x%<span class="number">0.01</span>			<span class="comment">--3.14</span></span><br><span class="line">&gt;x - x%<span class="number">0.001</span>		<span class="comment">--3.141</span></span><br></pre></td></tr></table></figure>
<p>再比如，我们可以使用取模运算检查某辆车在拐过了指定的角度后是否能够原路返回。假设使用度作为角度的单位，那么我们可以使用如下的公式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tolerance = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isturnback</span><span class="params">( angle)</span></span></span><br><span class="line">	angle = angle % <span class="number">360</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">math</span>.<span class="built_in">abs</span>(angle - <span class="number">180</span>) &lt; tolerance)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数对负的角度而言也同样适用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(istrunback(-180))			--turn</span><br></pre></td></tr></table></figure>
<p>假设使用弧度作为角度的单位，那么我们只需要简单地修改常量的定义即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tolerance = <span class="number">0.17</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isturnback</span><span class="params">( angle)</span></span></span><br><span class="line">	angle = angle % (<span class="number">2</span> * <span class="built_in">math</span>.<span class="built_in">pi</span>)</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">math</span>.<span class="built_in">abs</span>(angle - <span class="number">180</span>) &lt; tolerance)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>表达式angle%(2*math.pi)实现了将任意范围的角度归一化到[0,2pi]之间。</p>
<p>Lua表达式同意支持幂运算，使用符号<code>^</code>表示，像除法一样，幂运算的操作数也永远是浮点类型（整型值在幂运算时不能整除，例如，$2^{-2}$的结果不是整型数）。我们可以使用$x^{0.5}$来计算x的平方根，使用$x^{1&#x2F;3}$来计算x的立方根。</p>
<h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><p>Lua语言提供了下列关系运算：<br><code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>,<code>==</code>,<code>~=</code><br>这些关系运算的结果都是Boolean类型。<br><code>==</code>用于相等性测试，<code>~=</code>用于不等性测试。这两个运算符可以应用于任意两个值，当这两个值的类型不同时，Lua语言认为它们是不相等的；否则，会根据它们的类型再对两者进行比较。<br>比较数值时应用户忽略数值的子类型，数值究竟是以整型还是浮点型类型表示并无区别，只娱算术有关。</p>
<h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><p>Lua语言提供了标准数学库math。标准数学库由一组标准的数学函数组成，包括三角函数、指数函数、取证函数、最大和最小函数、用于生成伪随机数函数(random)以及常量pi和huge。<br>详情可见链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Silent_F/article/details/86547290">https://blog.csdn.net/Silent_F/article/details/86547290</a><br>所有的三角函数都以弧度为单位，并通过函数deg和rad进行角度和弧度的转换。</p>
<h3 id="随机数发生器"><a href="#随机数发生器" class="headerlink" title="随机数发生器"></a>随机数发生器</h3><p>函数math.random用于生成随机数，共有三种调用方式。当不带参数调用时，该函数将返回一个在[0,1)范围内均匀分布的随机实数。当使用带有一个整型值n的参数调用时，该函数将返回一个在[1,n]范围内的随机整数。例如，我们可以通过调用random(6)来模拟掷骰子的结果。当使用带有两个整数值l和u的参数调用时，该函数返回在[l,u]范围内的随机整数。<br>函数randomseed用于设置随机数发生器的种子，该函数的唯一参数就是数值类型的种子。在一个程序启动时，系统固定使用1为种子初始化随机数发生器。如果不设置其他的种子，那么每次程序运行时都会生成相同的随机数序列。从调试的角度看，这是一个不错的特行，然而，对于一个游戏来说却会导致相同的场景重复地出现。为了解决这个问题，通常调用<code>math.randomsee(os.time())</code>来使当前系统时间作为种子初始化随机数发生器。</p>
<h3 id="取证函数"><a href="#取证函数" class="headerlink" title="取证函数"></a>取证函数</h3><p>数学库提供了三个取证函数:floor、ceil和modf。其中，floor向负无穷取整，ceil向正无穷取整，modf向零取整。当取整结果能够用整型表示时，返回结果为整型值，否则返回浮点型值。处理返回取整后的值义务外，函数modf还会返回小数部分作为第二个结果。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">3.3</span>)		<span class="comment">--3</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">-3.3</span>)		<span class="comment">-- -4</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">ceil</span>(<span class="number">3.3</span>)			<span class="comment">-- 4</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">ceil</span>(<span class="number">-3.3</span>)		<span class="comment">-- -3</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">modf</span>(<span class="number">3.3</span>)			<span class="comment">-- 3 	0.3</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">modf</span>(<span class="number">-3.3</span>)		<span class="comment">-- -3 	-0.3</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">2</span>^<span class="number">70</span>)		<span class="comment">--1.1805916207174e+21</span></span><br></pre></td></tr></table></figure>
<p>如果参数本身就是一个整型值，那么它将被原样返回。<br>如果想将数值x向最近的整数取整，可以对x+0.5调用floor函数。不过，当参数是一个很大的整数时，简单的加法可能会导致错误。例如，考虑如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = x^<span class="number">52</span> + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d %d&quot;</span> , x , <span class="built_in">math</span>.<span class="built_in">floor</span>(x + <span class="number">0.5</span>)))</span><br><span class="line">	<span class="comment">-- 4503599627370497   4503599627370498</span></span><br></pre></td></tr></table></figure>
<p>$2^{52}$ + 1.5的浮点值表示是不精确的，因此内部会以我们不可控制的方式取整。为了避免这个问题，我们可以单独地处理整数值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">round</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="keyword">local</span> f = <span class="built_in">math</span>.<span class="built_in">floor</span>(x)</span><br><span class="line">	<span class="keyword">if</span> x == f <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> f</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">math</span>.<span class="built_in">floor</span>(x + <span class="number">0.5</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上例中的函数总是会向上取整半个整数。如果想进行无偏取整，即向距离最近的偶数取整半个整数，上述公式在x + 0.5是奇数的情况下产生不正确的结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">3.5</span> + <span class="number">0.5</span>) 		<span class="comment">--4 (ok)</span></span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">2.5</span> + <span class="number">0.5</span>)		<span class="comment">--3 (wrong)</span></span><br></pre></td></tr></table></figure>
<p>这时，还是可以利用取整操作来解决上面的问题：表达式<code>(x%2.0 == 0.5)</code>只有在x + 0.5为奇数时为真。基于这些情况，定义一个无偏取整函数就很简单了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">round</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="keyword">local</span> f = <span class="built_in">math</span>.<span class="built_in">floor</span>(x)</span><br><span class="line">	<span class="keyword">if</span> (x == f) <span class="keyword">or</span> (x % <span class="number">2.0</span> == <span class="number">0.5</span>) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> f</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">math</span>.<span class="built_in">floor</span>(x + <span class="number">0.5</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(round(<span class="number">2.5</span>))		<span class="comment">-- 2</span></span><br><span class="line"><span class="built_in">print</span>(round(<span class="number">3.5</span>))		<span class="comment">-- 4</span></span><br><span class="line"><span class="built_in">print</span>(round(<span class="number">-2.5</span>))		<span class="comment">-- -2</span></span><br><span class="line"><span class="built_in">print</span>(round(<span class="number">-1.5</span>))		<span class="comment">-- -2</span></span><br></pre></td></tr></table></figure>

<h2 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h2><p>大多数编程语言使用某些固定长度的比特位来表达数值。因此，数值的表示在范围和精度上都是有限制的。<br>标准Lua使用64个比特位来存储整型值，其最大值为$2^{63}-1$，约等于$10^{19}$；精简Lua使用32个比特位存储整型值，其最大值约为20亿。数学库中的常量定义了整型值的最大值(math.maxinteger)和最小值(math.mininteger)。<br>64位整型值中的最大值是一个很大的数值：全球财富总和（按美分计算）的数千倍和全球人口总数的数十亿倍。尽管这个数值很大，但是仍然有可能发生溢出。当我们在整型数操作时出现比mininteger更小或者比maxinteger更大的数值时，结果就会回环。<br>在数学领域，回环的意思是结果只能在mininteger和maxinteger之间，也就是对$2^{64}$取模的算术结果。在计算机领域，回环的意思是丢弃最高进位。假设最高进位存在，其将是第65个比特位，代表$2^{64}$。因此，忽略第65个比特位不会改变值对$2^{64}$取模的结果。在Lua语言中，这种行为对所有涉及整型值的算术运算都是一致且可预测的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.maxinteger + <span class="number">1</span> == <span class="built_in">math</span>.mininteger			<span class="comment">--ture</span></span><br><span class="line">&gt;<span class="built_in">math</span>.mininteger - <span class="number">1</span> == <span class="built_in">math</span>.maxinteger			<span class="comment">--true</span></span><br><span class="line">&gt;-<span class="built_in">math</span>.mininteger == <span class="built_in">math</span>.mininteger			<span class="comment">--true</span></span><br><span class="line">&gt;<span class="built_in">math</span>.mininteger // <span class="number">-1</span> == <span class="built_in">math</span>.mininteger		<span class="comment">--true</span></span><br></pre></td></tr></table></figure>
<p>最大可以表示的证书是0x7ff…fff，即除最高位（符号位，零为非负整数）外其余比特位均为1.当我们对0x7ff…fff加1时，其结果变为0x800…000，即最小可表示的整数。最小整数比最大整数的表示幅度大1：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.maxinteger		<span class="comment">--9223372036854775807</span></span><br><span class="line">&gt;<span class="number">0x7fffffffffffffff</span>		<span class="comment">--9223372036854775807</span></span><br><span class="line">&gt;<span class="built_in">math</span>.maxinteger		<span class="comment">--9223372036854775808</span></span><br><span class="line">&gt;<span class="number">0x8000000000000000</span>		<span class="comment">--9223372036854775808</span></span><br></pre></td></tr></table></figure>
<p>对于浮点数而言，标准Lua使用双精度。标准Lua使用64个比特位表示所有数值，其中11位为指数。双精度浮点数可以表示具有大致16个有效十进制位的数，范围从$-10^{308}$到$10^{308}$。精简Lua使用32个比特位表示的单精度浮点数，大致具有7个有效十进制位，范围从$-10^{38}$到$10^{38}$。<br>双精度浮点数对于大多数实际应用而言是足够大的，但是我们必须了解精度的限制。如果我们使用十位表示一个数，那么1&#x2F;7会被取整到0.142857142。如果我们使用十位计算1&#x2F;7 * 7，结果会是0.999999994而不是1。此外，用十进制表示的有限小数在用二进制表示时可能是无线小数。例如，12.7 -20 + 7.3即便是用双精度表示也不是0，这是由于12.7和7.3的二进制表示不是有限小数。<br>由于整型值和浮点型值的表示范围不同，因此当超过它们的表示范围时，整型值和浮点型值的算术运算会产生不同的结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.maxinteger + <span class="number">2</span>		<span class="comment">-- -9223372036854775807</span></span><br><span class="line">&gt;<span class="built_in">math</span>.maxinteger + <span class="number">2.0</span>      <span class="comment">-- 9.2233720368548e + 18</span></span><br></pre></td></tr></table></figure>
<p>在上例中，两个结果从数学的角度看都是错误的，而且它们错误的方式不同。第一行对最大可表示整数进行了整型求和，结果发生了回环。第二行对最大可表示整数进行了浮点型求和，结果被取整成了一个近似值，这可以通过如下的比较运算证明：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.maxinteger + <span class="number">2.0</span> == <span class="built_in">math</span>.maxinteger + <span class="number">1.0</span>   <span class="comment">-- true</span></span><br></pre></td></tr></table></figure>
<p>尽管每一种表示方法都有其优势，但是只有浮点型才能表示小数。浮点数的值可以表示很大的范围，但是浮点型能够表示的整数范围被精确地限制[$-2^{53}$,$2^{53}$]之间。在这个范围内，我们基本可以忽略整型和浮点型的区别；超出这个范围后，我们则应该谨慎地思考所使用的表示方式。</p>
<h2 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h2><p>我们可以简单地通过增加0.0的方法将整型值强制转换为浮点型值，一个整型值总是可以被转换成浮点型值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">-3</span> + <span class="number">0.0</span> 				<span class="comment">-- -3.0</span></span><br></pre></td></tr></table></figure>
<p>小于$2^{53}$的所有整型值的表示与双精度浮点型值的表示一样，对于绝对值超过了这个值的整型值而言，在将其强制转换为浮点型值时可能导致精度损失：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">9007199254740991</span> + <span class="number">0.0</span> == <span class="number">90071992547440991</span>		<span class="comment">--true</span></span><br><span class="line">&gt; <span class="number">9007199254740992</span> + <span class="number">0.0</span> == <span class="number">90071992547440992</span>		<span class="comment">--true</span></span><br><span class="line">&gt; <span class="number">9007199254740993</span> + <span class="number">0.0</span> == <span class="number">90071992547440993</span>		<span class="comment">--false</span></span><br></pre></td></tr></table></figure>
<p>在最后一行中，$2^{53} + 1$的结果被取整为$2^{53}$，打破了等式，表达式结果为false。<br>通过与零进行按位或运算，可以把浮点型值强制转换为整型值:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">2</span>^<span class="number">53</span>				<span class="comment">-- 9.007199254741e+15 (浮点型值)</span></span><br><span class="line">&gt; <span class="number">2</span>^<span class="number">53</span>|<span class="number">0</span>			<span class="comment">-- 9007199254730992	  (整型值)</span></span><br></pre></td></tr></table></figure>
<p>在将浮点型值强制转换为整型值时，Lua语言会检查数值是否与整型值表示完全一致，即没有小数部分且其值在整型值的表示范围内，如果不满足条件则会抛出异常：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3.2</span>|<span class="number">0</span>             <span class="comment">--小数部分</span></span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>: number has no integer representation</span><br><span class="line">&gt; <span class="number">2</span>^<span class="number">64</span>|<span class="number">0</span>            <span class="comment">--超出范围</span></span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>: number has no integer representation</span><br><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">3.5</span>)</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>: bad argument #<span class="number">2</span> to <span class="string">&#x27;random&#x27;</span>（数值没有用整型表示）</span><br></pre></td></tr></table></figure>
<p>对小数进行取整必须显示地调用取整函数。<br>另一种把数值强制转换为整型值的方式是使用函数math.tointeger，该函数会在输入参数无法转换为整型值时返回nil:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.tointeger(<span class="number">-258.0</span>)			<span class="comment">-- -258</span></span><br><span class="line">&gt;<span class="built_in">math</span>.tointeger(<span class="number">2</span>^<span class="number">30</span>)			<span class="comment">-- 1073741824</span></span><br><span class="line">&gt;<span class="built_in">math</span>.tointeger(<span class="number">5.01</span>)			<span class="comment">-- nil   (不是整数)</span></span><br><span class="line">&gt;<span class="built_in">math</span>.tointeger(<span class="number">2</span>^<span class="number">64</span>)			<span class="comment">-- nil	 (超出范围)</span></span><br></pre></td></tr></table></figure>
<p>这个函数在需要检查一个数字能否被转换为整型值时尤为有用。例如，以下函数在可能时会将输入参数转换为整型值，否则将保持原来的值不变：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cond2int</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">math</span>.tointerger(x) <span class="keyword">or</span> x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>Lua语言中的运算符优先级如下（从高到低）</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">一元运算符（-  #  ~  <span class="keyword">not</span> )</span><br><span class="line">*    /    //    %</span><br><span class="line">+    -</span><br><span class="line">..(连续)</span><br><span class="line">&lt;&lt;    &gt;&gt; （按位移位）</span><br><span class="line">&amp;（按位与）</span><br><span class="line">~（按位异或）</span><br><span class="line">|（按位或）</span><br><span class="line">&lt;    &gt;    &lt;=    &gt;=    ~=    ==</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br></pre></td></tr></table></figure>
<p>在二元运算符中，除了幂运算和链接操作符是右结合的外，其他运算符都是左结合的。因此，以下表达式的左右两边等价：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a + i &lt; b/<span class="number">2</span> + <span class="number">1</span>     &lt;<span class="comment">--&gt; (a + i) &lt; ((b/2) + 1)</span></span><br><span class="line"><span class="number">5</span> + x^<span class="number">2</span>*<span class="number">8</span>			&lt;<span class="comment">--&gt; 5 + ((x^2) * 8)</span></span><br><span class="line">a &lt; y <span class="keyword">and</span> y &lt;= z    &lt;<span class="comment">--&gt; (a &lt; y) and (y &lt;= z)</span></span><br><span class="line">-x^<span class="number">2</span>				&lt;<span class="comment">--&gt; -(x^2)</span></span><br><span class="line">x^y^z				&lt;<span class="comment">--&gt; x^(y^z)</span></span><br></pre></td></tr></table></figure>
<p>当不能确定某些表达式的运算符优先级时，应该显示地用括号来指定所希望的运算次序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/06/Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC/" data-id="clw7ne0x4001j4sad3rty2sml" data-title="Lua连续教程之Lua中的数值" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua语言入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/01/Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2020-03-31T16:22:31.000Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/01/Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/">Lua语言入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>遵照惯例，我们的第一个Lua程序时通过标准输出打印字符串”Hello World”:<br><code>print(&quot;Hello World&quot;)</code></p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>如果读者使用的是Lua语言独立解释器(stand-alone interpreter)，要运行这第一个程序的话，直接调用解释器运行包含程序代码的文本文件就可以了。例如，如果把上述代码保存为名hello.lua的文件，那么可以通过以下命令运行：<br><code>% lua hello.lua</code></p>
<p>再来看一个稍微复杂点的例子，以下代码定义了一个计算阶乘的函数，该函数先让用户输入一个数，然后打印出这个数的阶乘结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--定义一个计算阶乘的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n)</span></span></span><br><span class="line">	<span class="keyword">if</span> n  == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;enter a number:&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;*n&quot;</span>)  <span class="comment">--读取一个数字</span></span><br><span class="line"><span class="built_in">print</span>(fact(a))</span><br></pre></td></tr></table></figure>

<h2 id="1-1-程序段"><a href="#1-1-程序段" class="headerlink" title="1.1 程序段"></a>1.1 程序段</h2><p>我们将Lua语言执行的每一段代码称为一个*程序段(Chunk)*，即一组命令或表达式组成的序列。<br>程序段既可以简单到只由一句表达式构成，也可以由多句表达式和函数定义（实际是复制表达式，后面会详细介绍）组成（例如计算阶乘的示例）。程序段在大小上并没有限制，事实上，由于Lua语言也可以被用作数据定义语言，所以几MB的程序段也很常见。Lua语言的解释器可以支持非常大的程序段。<br>除了将源码保存成文件外，我们有也可以直接在交互式模式(interactive mode)下运行独立解释器。当不带参数第调用lua时，可以看到如下的输出:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% lua</span><br><span class="line">Lua <span class="number">5.3</span> Copyright(C)<span class="number">1994</span><span class="number">-2016</span> Lua.org, PUC-Rio</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>此后，输入的每一条命令都会在按下回车键后立即执行。我们可以通过输入<code>EPF</code>控制字符，或调用操作系统库的<code>exit</code>函数（执行<code>os.exit()</code>）退出交互模式。<br>从Lua5.3版本开始，可以直接在交互模式下输入表达式，Lua语言会输出表达式的值，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% lua</span><br><span class="line">Lua <span class="number">5.3</span> Copyright(C)<span class="number">1994</span><span class="number">-2016</span> Lua.org, PUC-Rio</span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">pi</span> / <span class="number">4</span>         <span class="comment">--0.78539816339745</span></span><br><span class="line">&gt; a = <span class="number">15</span></span><br><span class="line">&gt; a^<span class="number">2</span>                 <span class="comment">--225</span></span><br><span class="line">&gt; a + <span class="number">2</span>               <span class="comment">--7</span></span><br></pre></td></tr></table></figure>
<p>要以代码段的方式运行代码（不在交互模式下），那么必须把表达式包在函数<code>print</code>的调用中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">4</span>)</span><br><span class="line">a = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(a^<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>在交互模式下，Lua语言解释器一般会把我们输入的每一行当做完整的程序块或表达式解释执行。但是，如果Lua语言解释器发现我们输入的某一行不完成，那么它会等待直到程序块或表达式被输入完整后再进行解释执行。这样，我们也可以直接在交互模式下输入一个像阶乘函数示例那样的由多行组成的多行定义。不过，对于这种较长的函数定义而言，将其保存文件然后再调用独立解释器来执行通常更方便。<br>我们可以使用<code>-i</code>参数让Lua语言解释器在执行完制定的程序段后进入交互模式：<br><code>% lua -i prog</code><br>上述命令会在执行完文件prog中的程序后进入交互模式，这对于调试和手工测试很有用。在本章的最后，我们会学习有关独立解释器的更多参数。<br>另一种运行程序段的方式调用函数<code>dofile</code>，该函数会立即执行一个文件。例如，假设我们有一个如下所示的文件lib1.lua:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">norm</span><span class="params">( x,y )</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">math</span>.<span class="built_in">sqrt</span>(x^<span class="number">2</span> + y^<span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twice</span> <span class="params">(x)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">2.0</span> * x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后，在交互模式下运行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">dofile</span>(<span class="string">&#x27;lib1.lua&#x27;</span>)   <span class="comment">--加载文件</span></span><br><span class="line">&gt;n = norm(<span class="number">3.4</span>,<span class="number">1.0</span>)</span><br><span class="line">&gt;twice(n)             <span class="comment">--7.088018058677</span></span><br></pre></td></tr></table></figure>
<p>函数dofile在开发阶段也非常有用。我们可以同时打开两个窗口，一个窗口中使用文件编辑器编辑代码，另一个窗口中使用交互模式运行Lua语言解释器。当修改完代码并保存后，只要在Lua语言交互模式的提示符下执行dofile(“prog.lua”)就可以加载新代码，然后就可以观察新代码的函数调用和执行结果了。</p>
<h2 id="1-2-一些语法规范"><a href="#1-2-一些语法规范" class="headerlink" title="1.2 一些语法规范"></a>1.2 一些语法规范</h2><p>Lua语言中的标识符是由任意字母、数字和下划线组成的字符串（注意不能用数字开头），例如：<br><code>i</code>,<code>j</code>,<code>i1</code>,<code>j1</code>,<code>_i</code>,<code>abc</code><br>“下划线 + 大写字母”组成的标识符通过被Lua语言用作特殊用途，应避免将其用作其他用途。我们通常将“下划线 + 小写字母”用作哑变量。<br>以下是Lua语言的保留字，它们不能被用作标识符：<br><code>and</code>,<code>brask</code>,<code>do</code>,<code>else</code>,<code>elseif</code>,<code>end</code>,<code>false</code>,<code>goto</code>,<code>for</code>,<code>function</code>,<code>if</code>,<code>in</code>,<code>local</code>,<code>nil</code>,<code>not</code>,<code>or</code>,<code>repeat</code>,<code>return</code>,<code>then</code>,<code>true</code>,<code>until</code>,<code>while</code><br>Lua语言是对大小写敏感的，因而<code>and</code>是保留字，但是<code>And</code>和<code>AND</code>就是两个不同的标识符。<br>Lua语言中使用两个连续的连字符（–）表示单行注释，使用两个连续的连字符加两对左方括号表示长注释或多行注释的开始，指导两个连续的右括号为止，中间都是注释，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[多行</span></span><br><span class="line"><span class="comment">长注释</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure>
<p>在注释一段代码时，一个常见的技巧是将这些代码放入–[[和–]]之间，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">print(10)   --无动作，被注释掉了</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>
<p>当我们需要重新启用这段代码时，只需要在第一行行首添加一个连字符即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---[[</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>)      <span class="comment">--10</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>
<p>在第一个示例中，第一行的–[[表示一段多行注释的开始，直到两个连续的右括号这段多行注释才会结束，因而尽管最后一行有两个连续的连字符，但由于这两个连字符在最后两个右括号之前，所以仍然被注释掉了。在第二个示例中，由于第一行的–[[实际是单行注释，因此最后一行实际上也是一条独立的单行注释（最后的两个连续右方括号没有与之匹配的–[[），print并没有被注释掉。<br>在Lua语言中，连续语句之间的分隔符并不是必需的，如果有需要的话可以使用分号来进行分割。在Lua语言中，表达式之间的换行也不起任何作用。例如，以下4个程序段都是合法且等价的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> </span><br><span class="line">b = a * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>; b = a * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span> b = a * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这个根据个人习惯来。</p>
<h2 id="1-3-全局变量"><a href="#1-3-全局变量" class="headerlink" title="1.3 全局变量"></a>1.3 全局变量</h2><p>在Lua语言中，全局变量无须声明即可使用，使用未经初始化的全局变量也不会导致错误。当使用未经初始化的全局变量时，得到的结果是<code>nil</code>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; b      <span class="comment">-- nil</span></span><br><span class="line">&gt; b = <span class="number">10</span> </span><br><span class="line">&gt; b      <span class="comment">--10</span></span><br></pre></td></tr></table></figure>
<p>当把<code>nil</code>赋值给全局变量时，Lua会回收改全局变量（就像该全局变量从来没有出现过一样），例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; b = <span class="literal">nil</span></span><br><span class="line">&gt; b         			<span class="comment">--nil</span></span><br></pre></td></tr></table></figure>
<p>Lua语言不区分为初始化变量和被赋值为nil的变量。在上述赋值语句执行后，Lua语言会最终回收该变量占用的内存。</p>
<h2 id="1-4类型和值"><a href="#1-4类型和值" class="headerlink" title="1.4类型和值"></a>1.4类型和值</h2><p>Lua语言是一种动态类型的语言，在这种语言中没有类型定义，每个值都带有其自身的类型信息。<br>Lua语言中有8个基本类型：nil（空）、bloolean（布尔）、number（数值）、string（字符串）、userdata（用户数据）、function（函数）、thread（线程）和table（表）。使用函数type可获取一个值对应的类型名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="literal">nil</span>)			<span class="comment">-- nil</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="literal">true</span>)			<span class="comment">-- boolean</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>)		<span class="comment">--number</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="string">&quot;Hello World&quot;</span>)<span class="comment">--string</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">io</span>.<span class="built_in">stdin</span>)		<span class="comment">--userdata</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">print</span>)		<span class="comment">--function</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">type</span>)			<span class="comment">--thread</span></span><br><span class="line">&gt;<span class="built_in">type</span>(&#123;&#125;)			<span class="comment">--table</span></span><br><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">type</span>(X))		<span class="comment">--string</span></span><br></pre></td></tr></table></figure>
<p>不管X是什么，最后一行返回的永远是“string”。这是因为函数type的返回值永远是一个字符串。<br>userdata类型允许把任意的C语言数据保存在Lua语言变量中。在Lua语言中，用户数据类型除了赋值和相等性测试外，没有其他预定义的操作。用户数据被用来表示由应用或C语言编写的库所创建的新类型。例如，标准I&#x2F;O库使用用户数据来表示打开的文件。我们会在后面设计C API时再讨论更多的相关内容。<br>变量没有预定义的类型，任何变量都可以包含任何类型的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(a)		<span class="comment">-- nil(a没有初始化)</span></span><br><span class="line">&gt;a = <span class="number">10</span></span><br><span class="line">&gt;<span class="built_in">type</span>(a)		<span class="comment">--number</span></span><br><span class="line">&gt;a = <span class="string">&quot;a string!&quot;</span></span><br><span class="line">&gt;<span class="built_in">type</span>(a)		<span class="comment">--string</span></span><br><span class="line">&gt;a = <span class="literal">nil</span> </span><br><span class="line">&gt;<span class="built_in">type</span>(a)		<span class="comment">--nil</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，将一个变量用作不同类型时会导致代码的可读性不佳；但是，在某些情况下谨慎地使用这个特行可能会带来一定程度的便利。例如，当代码发生异常时可以返回一个nil以区别于其他正常情况下的返回值。</p>
<h3 id="1-4-1-nil"><a href="#1-4-1-nil" class="headerlink" title="1.4.1 nil"></a>1.4.1 nil</h3><p>nil是一种只有一个nil值的类型，它的主要作用就是与其他所有值进行区分。Lua语言使用nil来表示无效值的情况。像我们所学习的其他语言，一个全局变量在第一次被赋值前的默认值就是nil，而将nil赋值给全局变量则相当于将其删除。</p>
<h3 id="1-4-2-boolean"><a href="#1-4-2-boolean" class="headerlink" title="1.4.2 boolean"></a>1.4.2 boolean</h3><p>boolean类型具有两个值，<em>true</em>和<em>false</em>，它们分别代表了传统布尔值。不过，在Lua语言中，Boolean值并非是用于条件测试的唯一方式，任何值都可以表示条件。在Lua语言中，条件测试将除Boolean值false和nil外的所有其他值视为真。特别的是，在条件检测中Lua语言把零和空字符串也都视为真。<br>Lua语言支持常见的逻辑运算符：<code>and</code>,<code>or</code>和<code>not</code>。和条检测试一样，所有的逻辑运算将Boolean类型的false和nil当做假，而把其他值当作真。</p>
<h2 id="1-5-独立解释器"><a href="#1-5-独立解释器" class="headerlink" title="1.5 独立解释器"></a>1.5 独立解释器</h2><p>独立解释器是一个可以直接使用Lua语言的小程序。<br>如果源代码文件第一行以井号（#）开头，那么解释器在加载该文件时会忽略这一行。这个特征主要是为了方便在POSIX系统中将Lua作为一种脚本解释器来使用。假设独立解释器位于&#x2F;usr&#x2F;local&#x2F;bin下，当使用下列脚本:<br><code>#!/usr/local/bin/lua</code><br>或<br><code>#!/usr/bin/env lua</code><br>时，不需要显式地调用Lua语言解释器也可以直接运行Lua脚本。<br>lua命令的完整参数如：<br><code>lua [options] [script [args]]</code><br>其中，所有的参数都是可选的。如前所述，当不使用任何参数调用lua时，就会直接进入交互模式。<br> -e参数允许我们直接在命令行中输入代码，例如</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% lua -e <span class="string">&quot;print(math.sin(12))&quot;</span> </span><br></pre></td></tr></table></figure>
<p>请注意，在POSIX系统下需要使用双引号，以防止Shell错误第解析括号。<br>-l参数用于加载库。正如之前提到的那样，-i参数用于在运行完其他命令行参数后进入交互模式。因此，下面的命令会首先加载lib库，然后执行x&#x3D;10的赋值语句，并最终进入交互模式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% lua -i -llib -e <span class="string">&quot;x = 10&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果在交互模式下输入表达式，那么解释器会输出表达式求值后的结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">3</span>)</span><br><span class="line">&gt; a = <span class="number">30</span> </span><br><span class="line">&gt; a 			<span class="comment">--30</span></span><br></pre></td></tr></table></figure>
<p>请记住，这个特征只在Lua5.3及之后的版本中才有效。在之前的版本中，必须在表达式前加上一个等号。如果不想输出结果，那么可以在行末加上一个分号：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">io</span>.<span class="built_in">flush</span>()	<span class="comment">--true</span></span><br><span class="line">&gt; <span class="built_in">io</span>.<span class="built_in">flush</span>();</span><br></pre></td></tr></table></figure>
<p>分号使得最后一行在语法上变成了无效的表达式，但可以被当作有效命令执行。<br>解释器在处理参数前，会查找名为<code>LUA_INIT_5_3</code>的环境变量，如果找不到，就会再查找名为<code>LUA_INIT</code>的环境变量。如果这两个环境变量中的任意一个存在，并且其内容为<code>@filename</code>，那么解释器就会运行相应的文件；如果这两个环境变量存在，但是不以@开头，那么解释器就会认为其包含Lua代码，并会对其进行解释执行。由于可以通过上面的方法完整地配置Lua，因而LUA_INIT使得我们可以灵活地配置独立解释器。例如，我们可以预先加载程序包、修改路径、定义自定义函数、对函数进行重命名或删除函数，等等。<br>我们可以通过预先定义的全局变量arg来获取解释器传入的参数。例如，当执行如下命令时：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% lua script a b c</span><br></pre></td></tr></table></figure>
<p>编辑器在运行代码前或创建一个名为arg的表，其中存储了所有的命令行参数。索引0中保存的内容为脚本名，索引1中保存的内容为第一个参数，以此类推；而在脚本之前的所有选项则位于负数索引上，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% lua -e <span class="string">&quot;sin = math.sin&quot;</span> script a b</span><br></pre></td></tr></table></figure>
<p>解释器按照如下的方式获取参数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arg</span>[<span class="number">-3</span>] = <span class="string">&quot;lua&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">-2</span>] = <span class="string">&quot;-e&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">-1</span>] = <span class="string">&quot;sin = math.sin&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">0</span>]  = <span class="string">&quot;script&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">1</span>]  = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">2</span>]  = <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，脚本只会用到索引为证书的参数。<br>Lua语言也支持可变长参数，可以通过可变长参数表达式来获取。在脚本文件中，表达式…（3个点）表示传递给脚本的所有参数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/01/Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" data-id="clw7ne0xi003o4saddbo4hgyh" data-title="Lua语言入门" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua的深拷贝和浅拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/27/Lua%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2020-03-27T11:49:31.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/27/Lua%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">Lua的深拷贝和浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天在写游戏的时候，遇到了一个数据问题，就开始查资料</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>代码如下</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- Deep copies a table into a new table.</span></span><br><span class="line"><span class="comment">-- Tables used as keys are also deep copied, as are metatables</span></span><br><span class="line"><span class="comment">-- @param orig The table to copy</span></span><br><span class="line"><span class="comment">-- @return Returns a copy of the input table</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">deep_copy</span><span class="params">(orig)</span></span></span><br><span class="line">  <span class="keyword">local</span> copy</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span>(orig) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">    copy = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> orig_key, orig_value <span class="keyword">in</span> <span class="built_in">next</span>, orig, <span class="literal">nil</span> <span class="keyword">do</span></span><br><span class="line">      copy[deep_copy(orig_key)] = deep_copy(orig_value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(copy, deep_copy(<span class="built_in">getmetatable</span>(orig)))</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    copy = orig</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> copy</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- Copies a table into a new table.</span></span><br><span class="line"><span class="comment">-- neither sub tables nor metatables will be copied.</span></span><br><span class="line"><span class="comment">-- @param orig The table to copy</span></span><br><span class="line"><span class="comment">-- @return Returns a copy of the input table</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">shallow_copy</span><span class="params">(orig)</span></span></span><br><span class="line">  <span class="keyword">local</span> copy</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span>(orig) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">    copy = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> orig_key, orig_value <span class="keyword">in</span> <span class="built_in">pairs</span>(orig) <span class="keyword">do</span></span><br><span class="line">      copy[orig_key] = orig_value</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="comment">-- number, string, boolean, etc</span></span><br><span class="line">    copy = orig</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> copy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>例子如下：<br>深拷贝</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123; aa = <span class="number">1</span>, bb = <span class="number">2</span>, cc = &#123; dd = &#123; ee = <span class="number">3</span> &#125; &#125; &#125;</span><br><span class="line"><span class="comment">--local b = deep_copy(a)</span></span><br><span class="line"><span class="keyword">local</span> b = shallow_copy(a)</span><br><span class="line">b.cc.dd.ee = <span class="number">111</span></span><br><span class="line">b.bb = <span class="number">111</span></span><br><span class="line">ngx.say(cjson.encode(a))</span><br><span class="line">ngx.say(cjson.encode(b))</span><br></pre></td></tr></table></figure>
<p>结果：{“aa”:1,”bb”:2,”cc”:{“dd”:{“ee”:111}}}<br>{“aa”:1,”bb”:111,”cc”:{“dd”:{“ee”:111}}}</p>
<p>浅拷贝</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> men = &#123; mkey = <span class="number">555</span> &#125;</span><br><span class="line"><span class="keyword">local</span> a = &#123; aa = <span class="number">1</span>, bb = <span class="number">2</span>, cc = &#123; dd = &#123; ee = &#123; ff = <span class="number">3</span> &#125; &#125; &#125; &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(a, &#123; <span class="built_in">__index</span> = men &#125;)</span><br><span class="line"><span class="keyword">local</span> b = deep_copy(a)</span><br><span class="line"></span><br><span class="line">ngx.say(a.cc.dd.ee.ff)</span><br><span class="line">ngx.say(a.mkey)</span><br><span class="line">ngx.say(b.mkey)</span><br></pre></td></tr></table></figure>
<p>3<br>555<br>555</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/27/Lua%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="clw7ne0xf003e4sadezspdeta" data-title="Lua的深拷贝和浅拷贝" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-git强制拉取远程项目覆盖本地项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/15/git%E5%BC%BA%E5%88%B6%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E9%A1%B9%E7%9B%AE%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2019-11-15T10:12:38.000Z" itemprop="datePublished">2019-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">开发工具的使用</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/15/git%E5%BC%BA%E5%88%B6%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E9%A1%B9%E7%9B%AE%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/">git强制拉取远程项目覆盖本地项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近在工作中经常需要从git拉取到一些项目到本地，但是因为本地项目被我自己修改，所以无法用传统的方式将远程仓库的项目拉取下来。下面介绍一种远程仓库强制拉取项目到本地的方法。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<blockquote>
<p>除非必须强制，不要轻易使用。</p>
</blockquote>
<p><strong>需要将这些更新取回本地，用命令<code>git fetch</code>.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br></pre></td></tr></table></figure>
<p><strong>撤销本地、暂存区、版本库(用远程服务器的origin&#x2F;master替换本地、暂存区、版本库)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>

<p><strong>git pull来从远程仓库”同步”代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p>或者用下面一行命令<br><strong>git强制覆盖本地命令（单条执行）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/15/git%E5%BC%BA%E5%88%B6%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E9%A1%B9%E7%9B%AE%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/" data-id="clw7ne0yl00aj4sad1dra64i1" data-title="git强制拉取远程项目覆盖本地项目" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-python实现微信自动聊天" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/16/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E8%81%8A%E5%A4%A9/" class="article-date">
  <time class="dt-published" datetime="2019-07-16T10:46:18.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/">日常代码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/07/16/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E8%81%8A%E5%A4%A9/">python实现微信自动聊天</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>闲着无聊，在网上找了一些好玩的代码，比如用Python实现微信自动回消息<br>之前弄了一个定时自动给好友发天气或者发心灵鸡汤的脚本，下载链接：<a target="_blank" rel="noopener" href="https://download.csdn.net/download/silent_f/11162951">https://download.csdn.net/download/silent_f/11162951</a></p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>今天这里就介绍几个微信接入图灵机器人，自动和好友聊天的脚本</p>
<h3 id="1、自动和所有好友聊天，只要好友发消息来，就会给好友回复"><a href="#1、自动和所有好友聊天，只要好友发消息来，就会给好友回复" class="headerlink" title="1、自动和所有好友聊天，只要好友发消息来，就会给好友回复"></a>1、自动和所有好友聊天，只要好友发消息来，就会给好友回复</h3><p>这里笔者用的是3.6版本python ,安装itchat,<br>用下面命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install itchat </span><br></pre></td></tr></table></figure>
<p>然后去图灵机器人官网注册账号，获取一个key</p>
<p>具体代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">import</span> importlib,sys </span><br><span class="line">importlib.reload(sys)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_response</span>(<span class="params">_info</span>):</span><br><span class="line">    <span class="built_in">print</span>(_info)                                       <span class="comment"># 从好友发过来的消息</span></span><br><span class="line">    api_url = <span class="string">&#x27;http://www.tuling123.com/openapi/api&#x27;</span>   <span class="comment"># 图灵机器人网址</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;466856743b3442bf95acb1e21a5218e2&#x27;</span>,     <span class="comment"># 如果这个 apiKey 如不能用，那就注册一次</span></span><br><span class="line">        <span class="string">&#x27;info&#x27;</span>: _info,                                 <span class="comment"># 这是我们从好友接收到的消息 然后转发给图灵机器人</span></span><br><span class="line">        <span class="string">&#x27;userid&#x27;</span>: <span class="string">&#x27;wechat-robot&#x27;</span>,                      <span class="comment"># 这里你想改什么都可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.post(api_url, data=data).json()       <span class="comment"># 把data数据发</span></span><br><span class="line">    <span class="built_in">print</span>(r.get(<span class="string">&#x27;text&#x27;</span>))                               <span class="comment"># 机器人回复给好友的消息</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">itchat.content.TEXT</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text_reply</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + get_response(msg[<span class="string">&quot;Text&quot;</span>])[<span class="string">&quot;text&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    itchat.auto_login()                  <span class="comment"># hotReload = True, 保持在线，下次运行代码可自动登录  hotReload=True</span></span><br><span class="line">    itchat.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、和指定好友聊天"><a href="#2、和指定好友聊天" class="headerlink" title="2、和指定好友聊天"></a>2、和指定好友聊天</h3><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> Bot,Tuling,embed,ensure_one</span><br><span class="line">bot = Bot()</span><br><span class="line">my_friend = ensure_one(bot.search(<span class="string">&#x27;张三&#x27;</span>))  <span class="comment">#想和机器人聊天的好友的备注</span></span><br><span class="line">tuling = Tuling(api_key=<span class="string">&#x27;466856743b3442bf95acb1e21a5218e2&#x27;</span>)     <span class="comment">#这里是图灵机器人申请后的api</span></span><br><span class="line"><span class="meta">@bot.register(<span class="params">my_friend</span>)  </span><span class="comment"># 使用图灵机器人自动与指定好友聊天</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reply_my_friend</span>(<span class="params">msg</span>):</span><br><span class="line">    tuling.do_reply(msg)</span><br><span class="line">embed()</span><br></pre></td></tr></table></figure>

<h3 id="3、在指定微信群里聊天"><a href="#3、在指定微信群里聊天" class="headerlink" title="3、在指定微信群里聊天"></a>3、在指定微信群里聊天</h3><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> Bot,Tuling,embed</span><br><span class="line">bot = Bot(cache_path=<span class="literal">True</span>)</span><br><span class="line">my_group = bot.groups().search(<span class="string">&#x27;8个人儿? ? ? ? ?&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 更改为自己的群聊名称</span></span><br><span class="line">tuling = Tuling(api_key=<span class="string">&#x27;466856743b3442bf95acb1e21a5218e2&#x27;</span>)  <span class="comment"># 图灵机器人申请的apikey</span></span><br><span class="line"><span class="meta">@bot.register(<span class="params">my_group, except_self=<span class="literal">False</span></span>)  </span><span class="comment"># 使用图灵机器人自动在指定群聊天</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reply_my_friend</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(tuling.do_reply(msg))</span><br><span class="line">embed()</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/07/16/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E8%81%8A%E5%A4%A9/" data-id="clw7ne0yv00bw4sad8gjf1075" data-title="python实现微信自动聊天" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua中“-”和“-”区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/03/17/Lua%E4%B8%AD%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E2%80%9D%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2019-03-17T05:09:04.000Z" itemprop="datePublished">2019-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/03/17/Lua%E4%B8%AD%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E2%80%9D%E5%8C%BA%E5%88%AB/">Lua中“.”和“:”区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>初学lua，可能会对<code>.</code>和<code>:</code>这两个符号的用法产生疑问，很多时候都会因为这个出错，这里笔者简单介绍下笔者在使用cocos2dx游戏开发中对这两者的认识</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>冒号的作用：定义函数时，给函数添加隐藏的第一个参数<code>self</code>，调用函数时，默认把当前调用者作为第一个参数传递进去。<br>使用冒号后，就相当于我们使用了点号，只是我们不再需要显示的定义<code>self</code>参数以及主动低传递参数。</p>
<p>在cocos2dx 开发过程中，大部分时候都是使用的冒号</p>
<p>一般我们在定义函数时会用下面写法</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainScene:onCreate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>等同于下面写法</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainScene.onCreate</span><span class="params">(self)</span></span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>笔者个人看法，欢迎大家更正</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/03/17/Lua%E4%B8%AD%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E2%80%9D%E5%8C%BA%E5%88%AB/" data-id="clw7ne0x2001b4sad33c0405o" data-title="Lua中“.”和“:”区别" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/16/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Autodesk3dMax/">Autodesk3dMax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/algolia/">algolia</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web-Development/">Web Development</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/Visual-Studio/">Visual Studio</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/android-ndk/">android ndk</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/">cocos Creator</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/">json</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/js/">js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/js/node/">node</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/js/node/TypeScript/">TypeScript</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-creator/">cocos creator</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">小程序开发</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/https/">https</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssh/">ssh</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/">创意编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97/">蓝牙模块</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/">工具脚本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E8%A7%81bug/">常见bug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%BF%E5%91%8A/">广告</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">开发工具的使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/">日常代码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/">Python应用</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E5%BE%AE%E4%BF%A1/">微信</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E5%BE%AE%E4%BF%A1/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/">数据抓取</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/">俄罗斯方块</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E7%BB%98%E5%9B%BE/">Python绘图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E7%BB%98%E5%9B%BE/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/">创意编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E7%BB%98%E5%9B%BE/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/%E6%8A%96%E9%9F%B3%E7%83%AD%E9%97%A8/">抖音热门</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/">工作生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/Python%E5%BA%94%E7%94%A8/">Python应用</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/Python%E5%BA%94%E7%94%A8/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/">服务器搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/">虚拟专用网络</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">电脑使用技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/">破解软件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E7%BC%96%E7%A8%8B/">Lua编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/">网页设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/">节日祝福</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/">课程设计</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E9%80%9A%E4%BF%A1%E5%B7%A5%E7%A8%8B/">通信工程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E9%80%9A%E4%BF%A1%E5%B7%A5%E7%A8%8B/%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A/">实习报告</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%9A%E4%BF%A1%E7%A7%91%E6%8A%80%E4%BA%BA%E5%91%98%E8%81%8C%E4%B8%9A%E9%81%93%E5%BE%B7/">通信科技人员职业道德</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/" rel="tag">1024程序员节</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/404/" rel="tag">404</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Autodesk3dMax/" rel="tag">Autodesk3dMax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Creator/" rel="tag">Cocos Creator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ImageView/" rel="tag">ImageView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sprite/" rel="tag">Sprite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thinter/" rel="tag">Thinter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Word/" rel="tag">Word</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/" rel="tag">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ndk/" rel="tag">android ndk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos/" rel="tag">cocos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos-Creator/" rel="tag">cocos Creator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos-creator/" rel="tag">cocos creator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2dx/" rel="tag">cocos2dx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/facebook/" rel="tag">facebook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/" rel="tag">https</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lua/" rel="tag">lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/" rel="tag">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ndkr10e/" rel="tag">ndkr10e</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quick-Cocos/" rel="tag">quick Cocos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/" rel="tag">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tolua/" rel="tag">tolua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/" rel="tag">ts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeScript/" rel="tag">typeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vsCode/" rel="tag">vsCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/" rel="tag">创意编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E6%80%A7%E8%83%BD/" rel="tag">游戏性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="tag">电脑使用技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A1%AC%E4%BB%B6/" rel="tag">硬件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/" rel="tag">粒子特效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%B9%E7%90%86/" rel="tag">纹理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%B9%E7%90%86%E4%BC%98%E5%8C%96/" rel="tag">纹理优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%98%E5%9B%BE/" rel="tag">绘图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E6%95%AC/" rel="tag">致敬</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%82%E6%97%A5/" rel="tag">节日</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%B7%E6%B1%82/" rel="tag">请求</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/" style="font-size: 10px;">1024程序员节</a> <a href="/tags/404/" style="font-size: 10px;">404</a> <a href="/tags/Android/" style="font-size: 12.22px;">Android</a> <a href="/tags/Autodesk3dMax/" style="font-size: 10px;">Autodesk3dMax</a> <a href="/tags/C/" style="font-size: 14.44px;">C</a> <a href="/tags/Cocos-Creator/" style="font-size: 12.22px;">Cocos Creator</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/ImageView/" style="font-size: 10px;">ImageView</a> <a href="/tags/Java/" style="font-size: 14.44px;">Java</a> <a href="/tags/Lua/" style="font-size: 20px;">Lua</a> <a href="/tags/Mac/" style="font-size: 11.11px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Sprite/" style="font-size: 10px;">Sprite</a> <a href="/tags/Thinter/" style="font-size: 10px;">Thinter</a> <a href="/tags/TypeScript/" style="font-size: 16.67px;">TypeScript</a> <a href="/tags/Word/" style="font-size: 10px;">Word</a> <a href="/tags/Xcode/" style="font-size: 11.11px;">Xcode</a> <a href="/tags/android/" style="font-size: 11.11px;">android</a> <a href="/tags/android-ndk/" style="font-size: 10px;">android ndk</a> <a href="/tags/cocos/" style="font-size: 10px;">cocos</a> <a href="/tags/cocos-Creator/" style="font-size: 18.89px;">cocos Creator</a> <a href="/tags/cocos-creator/" style="font-size: 10px;">cocos creator</a> <a href="/tags/cocos2dx/" style="font-size: 17.78px;">cocos2dx</a> <a href="/tags/facebook/" style="font-size: 10px;">facebook</a> <a href="/tags/git/" style="font-size: 11.11px;">git</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/https/" style="font-size: 10px;">https</a> <a href="/tags/java/" style="font-size: 11.11px;">java</a> <a href="/tags/lua/" style="font-size: 13.33px;">lua</a> <a href="/tags/mac/" style="font-size: 11.11px;">mac</a> <a href="/tags/ndkr10e/" style="font-size: 10px;">ndkr10e</a> <a href="/tags/python/" style="font-size: 15.56px;">python</a> <a href="/tags/quick-Cocos/" style="font-size: 11.11px;">quick Cocos</a> <a href="/tags/shader/" style="font-size: 11.11px;">shader</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/tolua/" style="font-size: 10px;">tolua</a> <a href="/tags/ts/" style="font-size: 10px;">ts</a> <a href="/tags/typeScript/" style="font-size: 10px;">typeScript</a> <a href="/tags/vsCode/" style="font-size: 11.11px;">vsCode</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a> <a href="/tags/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">创意编程</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" style="font-size: 10px;">游戏开发</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E6%80%A7%E8%83%BD/" style="font-size: 10px;">游戏性能</a> <a href="/tags/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 11.11px;">电脑使用技巧</a> <a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 13.33px;">硬件</a> <a href="/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/" style="font-size: 10px;">粒子特效</a> <a href="/tags/%E7%BA%B9%E7%90%86/" style="font-size: 10px;">纹理</a> <a href="/tags/%E7%BA%B9%E7%90%86%E4%BC%98%E5%8C%96/" style="font-size: 10px;">纹理优化</a> <a href="/tags/%E7%BB%98%E5%9B%BE/" style="font-size: 10px;">绘图</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 10px;">编码</a> <a href="/tags/%E8%87%B4%E6%95%AC/" style="font-size: 10px;">致敬</a> <a href="/tags/%E8%8A%82%E6%97%A5/" style="font-size: 10px;">节日</a> <a href="/tags/%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">请求</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/15/cocos2dx%E4%BD%BF%E7%94%A8%E5%B8%A7%E5%8A%A8%E7%94%BB/">cocos2dx使用帧动画</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx_lua%E9%94%AE%E7%9B%98%E7%9B%91%E5%90%AC/">cocos2dx_lua键盘监听</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx-lua%E8%AE%BE%E7%BD%AE%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7/">cocos2dx-lua设置节点层级</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx-lua%E5%AF%B9%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%BC%A9%E6%94%BE/">cocos2dx-lua对图片进行九宫格缩放</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx-Lua%E4%B8%ADLabel%E6%96%87%E6%9C%AC%E8%B6%85%E8%BF%87%E7%89%B9%E5%AE%9A%E9%95%BF%E5%BA%A6%E4%BD%BF%E7%94%A8...%E4%BB%A3%E6%9B%BF/">cocos2dx-Lua中Label文本超过特定长度使用...代替</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>