<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-用python检测微信好友是否删除自己" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/%E7%94%A8python%E6%A3%80%E6%B5%8B%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%E6%98%AF%E5%90%A6%E5%88%A0%E9%99%A4%E8%87%AA%E5%B7%B1/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T13:14:12.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/">日常代码</a>►<a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/">Python应用</a>►<a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E5%BE%AE%E4%BF%A1/">微信</a>►<a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E5%BE%AE%E4%BF%A1/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/">数据抓取</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/%E7%94%A8python%E6%A3%80%E6%B5%8B%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%E6%98%AF%E5%90%A6%E5%88%A0%E9%99%A4%E8%87%AA%E5%B7%B1/">用python检测微信好友是否删除自己</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们在平时生活中使用微信发现微信中有很多已经将自己删除了的好友，如何在不打扰别人的情况下知道哪些好友删除了自己了？下面我们就用python程序来实现。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<blockquote>
<p>使用该程序有个前提条件：那就是自己的微信能够登录网页版微信，不然无法使用哦~<br>开发环境：python2</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> urllib, urllib2</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># from gevent import monkey</span></span><br><span class="line"></span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">MAX_GROUP_NUM = <span class="number">35</span> <span class="comment"># 每组人数</span></span><br><span class="line"></span><br><span class="line">QRImagePath = os.getcwd() + <span class="string">&#x27;/qrcode.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line">tip = <span class="number">0</span></span><br><span class="line">uuid = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">base_uri = <span class="string">&#x27;&#x27;</span></span><br><span class="line">redirect_uri = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">skey = <span class="string">&#x27;&#x27;</span></span><br><span class="line">wxsid = <span class="string">&#x27;&#x27;</span></span><br><span class="line">wxuin = <span class="string">&#x27;&#x27;</span></span><br><span class="line">pass_ticket = <span class="string">&#x27;&#x27;</span></span><br><span class="line">deviceId = <span class="string">&#x27;e000000000000000&#x27;</span></span><br><span class="line"></span><br><span class="line">BaseRequest = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ContactList = []</span><br><span class="line">My = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getUUID</span>():</span><br><span class="line">  <span class="keyword">global</span> uuid</span><br><span class="line"></span><br><span class="line">  url = <span class="string">&#x27;https://login.weixin.qq.com/jslogin&#x27;</span></span><br><span class="line">  params = &#123;</span><br><span class="line">    <span class="string">&#x27;appid&#x27;</span>: <span class="string">&#x27;wx782c26e4c19acffb&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fun&#x27;</span>: <span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;lang&#x27;</span>: <span class="string">&#x27;zh_CN&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;_&#x27;</span>: <span class="built_in">int</span>(time.time()),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url, data = urllib.urlencode(params))</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># window.QRLogin.code = 200; window.QRLogin.uuid = &quot;oZwt_bFfRg==&quot;;</span></span><br><span class="line">  regx = <span class="string">r&#x27;window.QRLogin.code = (\d+); window.QRLogin.uuid = &quot;(\S+?)&quot;&#x27;</span></span><br><span class="line">  pm = re.search(regx, data)</span><br><span class="line"></span><br><span class="line">  code = pm.group(<span class="number">1</span>)</span><br><span class="line">  uuid = pm.group(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> code == <span class="string">&#x27;200&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showQRImage</span>():</span><br><span class="line">  <span class="keyword">global</span> tip</span><br><span class="line"></span><br><span class="line">  url = <span class="string">&#x27;https://login.weixin.qq.com/qrcode/&#x27;</span> + uuid</span><br><span class="line">  params = &#123;</span><br><span class="line">    <span class="string">&#x27;t&#x27;</span>: <span class="string">&#x27;webwx&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;_&#x27;</span>: <span class="built_in">int</span>(time.time()),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url, data = urllib.urlencode(params))</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line"></span><br><span class="line">  tip = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  f = <span class="built_in">open</span>(QRImagePath, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">  f.write(response.read())</span><br><span class="line">  f.close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> sys.platform.find(<span class="string">&#x27;darwin&#x27;</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">    os.system(<span class="string">&#x27;open %s&#x27;</span> % QRImagePath)</span><br><span class="line">  <span class="keyword">elif</span> sys.platform.find(<span class="string">&#x27;linux&#x27;</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">    os.system(<span class="string">&#x27;xdg-open %s&#x27;</span> % QRImagePath)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    os.system(<span class="string">&#x27;call %s&#x27;</span> % QRImagePath)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;请使用微信扫描二维码以登录&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waitForLogin</span>():</span><br><span class="line">  <span class="keyword">global</span> tip, base_uri, redirect_uri</span><br><span class="line"></span><br><span class="line">  url = <span class="string">&#x27;https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?tip=%s&amp;uuid=%s&amp;_=%s&#x27;</span> % (tip, uuid, <span class="built_in">int</span>(time.time()))</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url)</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># window.code=500;</span></span><br><span class="line">  regx = <span class="string">r&#x27;window.code=(\d+);&#x27;</span></span><br><span class="line">  pm = re.search(regx, data)</span><br><span class="line"></span><br><span class="line">  code = pm.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> code == <span class="string">&#x27;201&#x27;</span>: <span class="comment">#已扫描</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;成功扫描,请在手机上点击确认以登录&#x27;</span></span><br><span class="line">    tip = <span class="number">0</span></span><br><span class="line">  <span class="keyword">elif</span> code == <span class="string">&#x27;200&#x27;</span>: <span class="comment">#已登录</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;正在登录...&#x27;</span></span><br><span class="line">    regx = <span class="string">r&#x27;window.redirect_uri=&quot;(\S+?)&quot;;&#x27;</span></span><br><span class="line">    pm = re.search(regx, data)</span><br><span class="line">    redirect_uri = pm.group(<span class="number">1</span>) + <span class="string">&#x27;&amp;fun=new&#x27;</span></span><br><span class="line">    base_uri = redirect_uri[:redirect_uri.rfind(<span class="string">&#x27;/&#x27;</span>)]</span><br><span class="line">  <span class="keyword">elif</span> code == <span class="string">&#x27;408&#x27;</span>: <span class="comment">#超时</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># elif code == &#x27;400&#x27; or code == &#x27;500&#x27;:</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">  <span class="keyword">global</span> skey, wxsid, wxuin, pass_ticket, BaseRequest</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = redirect_uri)</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    &lt;error&gt;</span></span><br><span class="line"><span class="string">      &lt;ret&gt;0&lt;/ret&gt;</span></span><br><span class="line"><span class="string">      &lt;message&gt;OK&lt;/message&gt;</span></span><br><span class="line"><span class="string">      &lt;skey&gt;xxx&lt;/skey&gt;</span></span><br><span class="line"><span class="string">      &lt;wxsid&gt;xxx&lt;/wxsid&gt;</span></span><br><span class="line"><span class="string">      &lt;wxuin&gt;xxx&lt;/wxuin&gt;</span></span><br><span class="line"><span class="string">      &lt;pass_ticket&gt;xxx&lt;/pass_ticket&gt;</span></span><br><span class="line"><span class="string">      &lt;isgrayscale&gt;1&lt;/isgrayscale&gt;</span></span><br><span class="line"><span class="string">    &lt;/error&gt;</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  doc = xml.dom.minidom.parseString(data)</span><br><span class="line">  root = doc.documentElement</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> node <span class="keyword">in</span> root.childNodes:</span><br><span class="line">    <span class="keyword">if</span> node.nodeName == <span class="string">&#x27;skey&#x27;</span>:</span><br><span class="line">      skey = node.childNodes[<span class="number">0</span>].data</span><br><span class="line">    <span class="keyword">elif</span> node.nodeName == <span class="string">&#x27;wxsid&#x27;</span>:</span><br><span class="line">      wxsid = node.childNodes[<span class="number">0</span>].data</span><br><span class="line">    <span class="keyword">elif</span> node.nodeName == <span class="string">&#x27;wxuin&#x27;</span>:</span><br><span class="line">      wxuin = node.childNodes[<span class="number">0</span>].data</span><br><span class="line">    <span class="keyword">elif</span> node.nodeName == <span class="string">&#x27;pass_ticket&#x27;</span>:</span><br><span class="line">      pass_ticket = node.childNodes[<span class="number">0</span>].data</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print &#x27;skey: %s, wxsid: %s, wxuin: %s, pass_ticket: %s&#x27; % (skey, wxsid, wxuin, pass_ticket)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> skey == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> wxsid == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> wxuin == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> pass_ticket == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  BaseRequest = &#123;</span><br><span class="line">    <span class="string">&#x27;Uin&#x27;</span>: <span class="built_in">int</span>(wxuin),</span><br><span class="line">    <span class="string">&#x27;Sid&#x27;</span>: wxsid,</span><br><span class="line">    <span class="string">&#x27;Skey&#x27;</span>: skey,</span><br><span class="line">    <span class="string">&#x27;DeviceID&#x27;</span>: deviceId,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">webwxinit</span>():</span><br><span class="line"></span><br><span class="line">  url = base_uri + <span class="string">&#x27;/webwxinit?pass_ticket=%s&amp;skey=%s&amp;r=%s&#x27;</span> % (pass_ticket, skey, <span class="built_in">int</span>(time.time()))</span><br><span class="line">  params = &#123;</span><br><span class="line">    <span class="string">&#x27;BaseRequest&#x27;</span>: BaseRequest</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url, data = json.dumps(params))</span><br><span class="line">  request.add_header(<span class="string">&#x27;ContentType&#x27;</span>, <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>)</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> DEBUG == <span class="literal">True</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(os.getcwd() + <span class="string">&#x27;/webwxinit.json&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    f.write(data)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">global</span> ContactList, My</span><br><span class="line">  dic = json.loads(data)</span><br><span class="line">  ContactList = dic[<span class="string">&#x27;ContactList&#x27;</span>]</span><br><span class="line">  My = dic[<span class="string">&#x27;User&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  ErrMsg = dic[<span class="string">&#x27;BaseResponse&#x27;</span>][<span class="string">&#x27;ErrMsg&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(ErrMsg) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> ErrMsg</span><br><span class="line"></span><br><span class="line">  Ret = dic[<span class="string">&#x27;BaseResponse&#x27;</span>][<span class="string">&#x27;Ret&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> Ret != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">webwxgetcontact</span>():</span><br><span class="line">  </span><br><span class="line">  url = base_uri + <span class="string">&#x27;/webwxgetcontact?pass_ticket=%s&amp;skey=%s&amp;r=%s&#x27;</span> % (pass_ticket, skey, <span class="built_in">int</span>(time.time()))</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url)</span><br><span class="line">  request.add_header(<span class="string">&#x27;ContentType&#x27;</span>, <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>)</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> DEBUG == <span class="literal">True</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(os.getcwd() + <span class="string">&#x27;/webwxgetcontact.json&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    f.write(data)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  dic = json.loads(data)</span><br><span class="line">  MemberList = dic[<span class="string">&#x27;MemberList&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 倒序遍历,不然删除的时候出问题..</span></span><br><span class="line">  SpecialUsers = [<span class="string">&#x27;newsapp&#x27;</span>, <span class="string">&#x27;fmessage&#x27;</span>, <span class="string">&#x27;filehelper&#x27;</span>, <span class="string">&#x27;weibo&#x27;</span>, <span class="string">&#x27;qqmail&#x27;</span>, <span class="string">&#x27;fmessage&#x27;</span>, <span class="string">&#x27;tmessage&#x27;</span>, <span class="string">&#x27;qmessage&#x27;</span>, <span class="string">&#x27;qqsync&#x27;</span>, <span class="string">&#x27;floatbottle&#x27;</span>, <span class="string">&#x27;lbsapp&#x27;</span>, <span class="string">&#x27;shakeapp&#x27;</span>, <span class="string">&#x27;medianote&#x27;</span>, <span class="string">&#x27;qqfriend&#x27;</span>, <span class="string">&#x27;readerapp&#x27;</span>, <span class="string">&#x27;blogapp&#x27;</span>, <span class="string">&#x27;facebookapp&#x27;</span>, <span class="string">&#x27;masssendapp&#x27;</span>, <span class="string">&#x27;meishiapp&#x27;</span>, <span class="string">&#x27;feedsapp&#x27;</span>, <span class="string">&#x27;voip&#x27;</span>, <span class="string">&#x27;blogappweixin&#x27;</span>, <span class="string">&#x27;weixin&#x27;</span>, <span class="string">&#x27;brandsessionholder&#x27;</span>, <span class="string">&#x27;weixinreminder&#x27;</span>, <span class="string">&#x27;wxid_novlwrv3lqwv11&#x27;</span>, <span class="string">&#x27;gh_22b87fa7cb3c&#x27;</span>, <span class="string">&#x27;officialaccounts&#x27;</span>, <span class="string">&#x27;notification_messages&#x27;</span>, <span class="string">&#x27;wxid_novlwrv3lqwv11&#x27;</span>, <span class="string">&#x27;gh_22b87fa7cb3c&#x27;</span>, <span class="string">&#x27;wxitil&#x27;</span>, <span class="string">&#x27;userexperience_alarm&#x27;</span>, <span class="string">&#x27;notification_messages&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(MemberList) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    Member = MemberList[i]</span><br><span class="line">    <span class="keyword">if</span> Member[<span class="string">&#x27;VerifyFlag&#x27;</span>] &amp; <span class="number">8</span> != <span class="number">0</span>: <span class="comment"># 公众号/服务号</span></span><br><span class="line">      MemberList.remove(Member)</span><br><span class="line">    <span class="keyword">elif</span> Member[<span class="string">&#x27;UserName&#x27;</span>] <span class="keyword">in</span> SpecialUsers: <span class="comment"># 特殊账号</span></span><br><span class="line">      MemberList.remove(Member)</span><br><span class="line">    <span class="keyword">elif</span> Member[<span class="string">&#x27;UserName&#x27;</span>].find(<span class="string">&#x27;@@&#x27;</span>) != -<span class="number">1</span>: <span class="comment"># 群聊</span></span><br><span class="line">      MemberList.remove(Member)</span><br><span class="line">    <span class="keyword">elif</span> Member[<span class="string">&#x27;UserName&#x27;</span>] == My[<span class="string">&#x27;UserName&#x27;</span>]: <span class="comment"># 自己</span></span><br><span class="line">      MemberList.remove(Member)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MemberList</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createChatroom</span>(<span class="params">UserNames</span>):</span><br><span class="line">  MemberList = []</span><br><span class="line">  <span class="keyword">for</span> UserName <span class="keyword">in</span> UserNames:</span><br><span class="line">    MemberList.append(&#123;<span class="string">&#x27;UserName&#x27;</span>: UserName&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  url = base_uri + <span class="string">&#x27;/webwxcreatechatroom?pass_ticket=%s&amp;r=%s&#x27;</span> % (pass_ticket, <span class="built_in">int</span>(time.time()))</span><br><span class="line">  params = &#123;</span><br><span class="line">    <span class="string">&#x27;BaseRequest&#x27;</span>: BaseRequest,</span><br><span class="line">    <span class="string">&#x27;MemberCount&#x27;</span>: <span class="built_in">len</span>(MemberList),</span><br><span class="line">    <span class="string">&#x27;MemberList&#x27;</span>: MemberList,</span><br><span class="line">    <span class="string">&#x27;Topic&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url, data = json.dumps(params))</span><br><span class="line">  request.add_header(<span class="string">&#x27;ContentType&#x27;</span>, <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>)</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  dic = json.loads(data)</span><br><span class="line">  ChatRoomName = dic[<span class="string">&#x27;ChatRoomName&#x27;</span>]</span><br><span class="line">  MemberList = dic[<span class="string">&#x27;MemberList&#x27;</span>]</span><br><span class="line">  DeletedList = []</span><br><span class="line">  <span class="keyword">for</span> Member <span class="keyword">in</span> MemberList:</span><br><span class="line">    <span class="keyword">if</span> Member[<span class="string">&#x27;MemberStatus&#x27;</span>] == <span class="number">4</span>: <span class="comment">#被对方删除了</span></span><br><span class="line">      DeletedList.append(Member[<span class="string">&#x27;UserName&#x27;</span>])</span><br><span class="line"></span><br><span class="line">  ErrMsg = dic[<span class="string">&#x27;BaseResponse&#x27;</span>][<span class="string">&#x27;ErrMsg&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(ErrMsg) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> ErrMsg</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (ChatRoomName, DeletedList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deleteMember</span>(<span class="params">ChatRoomName, UserNames</span>):</span><br><span class="line">  url = base_uri + <span class="string">&#x27;/webwxupdatechatroom?fun=delmember&amp;pass_ticket=%s&#x27;</span> % (pass_ticket)</span><br><span class="line">  params = &#123;</span><br><span class="line">    <span class="string">&#x27;BaseRequest&#x27;</span>: BaseRequest,</span><br><span class="line">    <span class="string">&#x27;ChatRoomName&#x27;</span>: ChatRoomName,</span><br><span class="line">    <span class="string">&#x27;DelMemberList&#x27;</span>: <span class="string">&#x27;,&#x27;</span>.join(UserNames),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url, data = json.dumps(params))</span><br><span class="line">  request.add_header(<span class="string">&#x27;ContentType&#x27;</span>, <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>)</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  dic = json.loads(data)</span><br><span class="line">  ErrMsg = dic[<span class="string">&#x27;BaseResponse&#x27;</span>][<span class="string">&#x27;ErrMsg&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(ErrMsg) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> ErrMsg</span><br><span class="line"></span><br><span class="line">  Ret = dic[<span class="string">&#x27;BaseResponse&#x27;</span>][<span class="string">&#x27;Ret&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> Ret != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addMember</span>(<span class="params">ChatRoomName, UserNames</span>):</span><br><span class="line">  url = base_uri + <span class="string">&#x27;/webwxupdatechatroom?fun=addmember&amp;pass_ticket=%s&#x27;</span> % (pass_ticket)</span><br><span class="line">  params = &#123;</span><br><span class="line">    <span class="string">&#x27;BaseRequest&#x27;</span>: BaseRequest,</span><br><span class="line">    <span class="string">&#x27;ChatRoomName&#x27;</span>: ChatRoomName,</span><br><span class="line">    <span class="string">&#x27;AddMemberList&#x27;</span>: <span class="string">&#x27;,&#x27;</span>.join(UserNames),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url = url, data = json.dumps(params))</span><br><span class="line">  request.add_header(<span class="string">&#x27;ContentType&#x27;</span>, <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>)</span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line">  data = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print data</span></span><br><span class="line"></span><br><span class="line">  dic = json.loads(data)</span><br><span class="line">  MemberList = dic[<span class="string">&#x27;MemberList&#x27;</span>]</span><br><span class="line">  DeletedList = []</span><br><span class="line">  <span class="keyword">for</span> Member <span class="keyword">in</span> MemberList:</span><br><span class="line">    <span class="keyword">if</span> Member[<span class="string">&#x27;MemberStatus&#x27;</span>] == <span class="number">4</span>: <span class="comment">#被对方删除了</span></span><br><span class="line">      DeletedList.append(Member[<span class="string">&#x27;UserName&#x27;</span>])</span><br><span class="line"></span><br><span class="line">  ErrMsg = dic[<span class="string">&#x27;BaseResponse&#x27;</span>][<span class="string">&#x27;ErrMsg&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(ErrMsg) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> ErrMsg</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> DeletedList</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">  opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookielib.CookieJar()))</span><br><span class="line">  urllib2.install_opener(opener)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> getUUID() == <span class="literal">False</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;获取uuid失败&#x27;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  showQRImage()</span><br><span class="line">  time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> waitForLogin() != <span class="string">&#x27;200&#x27;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  os.remove(QRImagePath)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> login() == <span class="literal">False</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;登录失败&#x27;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> webwxinit() == <span class="literal">False</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;初始化失败&#x27;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  MemberList = webwxgetcontact()</span><br><span class="line"></span><br><span class="line">  MemberCount = <span class="built_in">len</span>(MemberList)</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;通讯录共%s位好友&#x27;</span> % MemberCount</span><br><span class="line"></span><br><span class="line">  ChatRoomName = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">int</span>(math.ceil(MemberCount / <span class="built_in">float</span>(MAX_GROUP_NUM)))):</span><br><span class="line">    UserNames = []</span><br><span class="line">    NickNames = []</span><br><span class="line">    DeletedList = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, MAX_GROUP_NUM):</span><br><span class="line">      <span class="keyword">if</span> i * MAX_GROUP_NUM + j &gt;= MemberCount:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      Member = MemberList[i * MAX_GROUP_NUM + j]</span><br><span class="line">      UserNames.append(Member[<span class="string">&#x27;UserName&#x27;</span>])</span><br><span class="line">      NickNames.append(Member[<span class="string">&#x27;NickName&#x27;</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;第%s组...&#x27;</span> % (i + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;, &#x27;</span>.join(NickNames)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;回车键继续...&#x27;</span></span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 新建群组/添加成员</span></span><br><span class="line">    <span class="keyword">if</span> ChatRoomName == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">      (ChatRoomName, DeletedList) = createChatroom(UserNames)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      DeletedList = addMember(ChatRoomName, UserNames)</span><br><span class="line"></span><br><span class="line">    DeletedCount = <span class="built_in">len</span>(DeletedList)</span><br><span class="line">    <span class="keyword">if</span> DeletedCount &gt; <span class="number">0</span>:</span><br><span class="line">      result += DeletedList</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;找到%s个被删好友&#x27;</span> % DeletedCount</span><br><span class="line">    <span class="comment"># raw_input()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除成员</span></span><br><span class="line">    deleteMember(ChatRoomName, UserNames)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># todo 删除群组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  resultNames = []</span><br><span class="line">  <span class="keyword">for</span> Member <span class="keyword">in</span> MemberList:</span><br><span class="line">    <span class="keyword">if</span> Member[<span class="string">&#x27;UserName&#x27;</span>] <span class="keyword">in</span> result:</span><br><span class="line">      NickName = Member[<span class="string">&#x27;NickName&#x27;</span>]</span><br><span class="line">      <span class="keyword">if</span> Member[<span class="string">&#x27;RemarkName&#x27;</span>] != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        NickName += <span class="string">&#x27;(%s)&#x27;</span> % Member[<span class="string">&#x27;RemarkName&#x27;</span>]</span><br><span class="line">      resultNames.append(NickName.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;---------- 被删除的好友列表 ----------&#x27;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span>.join(resultNames)</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;-----------------------------------&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows下编码问题修复</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnicodeStreamFilter</span>: </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, target</span>): </span><br><span class="line">    self.target = target </span><br><span class="line">    self.encoding = <span class="string">&#x27;utf-8&#x27;</span> </span><br><span class="line">    self.errors = <span class="string">&#x27;replace&#x27;</span> </span><br><span class="line">    self.encode_to = self.target.encoding </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, s</span>): </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(s) == <span class="built_in">str</span>: </span><br><span class="line">      s = s.decode(<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">    s = s.encode(self.encode_to, self.errors).decode(self.encode_to) </span><br><span class="line">    self.target.write(s) </span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> sys.stdout.encoding == <span class="string">&#x27;cp936&#x27;</span>: </span><br><span class="line">  sys.stdout = UnicodeStreamFilter(sys.stdout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;本程序的查询结果可能会引起一些心理上的不适,请小心使用...&#x27;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;回车键继续...&#x27;</span></span><br><span class="line">  raw_input()</span><br><span class="line">  <span class="comment"># monkey.patch_all()</span></span><br><span class="line">  main()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;回车键结束&#x27;</span></span><br><span class="line">  raw_input()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/%E7%94%A8python%E6%A3%80%E6%B5%8B%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%E6%98%AF%E5%90%A6%E5%88%A0%E9%99%A4%E8%87%AA%E5%B7%B1/" data-id="clw7ne0zb00fa4sad7z0t064u" data-title="用python检测微信好友是否删除自己" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线程和状态" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/23/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%8A%B6%E6%80%81/" class="article-date">
  <time class="dt-published" datetime="2020-07-23T12:36:53.000Z" itemprop="datePublished">2020-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E7%BC%96%E7%A8%8B/">Lua编程</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/23/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%8A%B6%E6%80%81/">Lua连续教程之Lua线程和状态</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Lua语言不支持真正的多线程，即不支持共享内存的抢占式线程。原因有两个，其一是IOS C没有提供这样的功能，因此也没有可移植的方法能在Lua中实现这种机制：</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>其二，也是更重要的原因，在于我们认为在Lua中引入多线程不是一个好主意。<br>多线程一般用于底层编程。像信号量和监视器这样的同步机制一般都是操作系统上下文提供的，而非应用程序提供。要查找和纠正多线程相关的bug是很困难的，其中有些Bug还会导致安全隐患。此外，程序中的一些需要同步的临界区还可能由于同步而导致性能问题。<br>多线程的这些问题源于线程抢占和共享内存，因此如果使用非抢先式的线程后者不使用共享内存就可以避免这些问题。Lua语言同时支持这两种方案。Lua语言的线程是协作式的，因此可以避免因不可预知的线程切换而带来的问题。另一方面，Lua状态之间不共享内存，因此也为Lua语言中实现并行化提供了良好基础。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>在Lua语言中，协程的本质就是线程。我们可以认为协程是带有良好编程接口的线程，也可以认为线程是带有底层API的协程。<br>从C API的角度来看，把线程当作一个栈会比较有用；而从实现的角度来看，栈实际上就是线程。每个站都保存着一个线程中挂起的函数调用信息，外加每个函数调用的参数和局部变量。换句话说，一个栈包括了一个线程得以继续运行所需的所有信息。因此，多个线程就意味着多个独立的栈。<br>Lua语言中 CAPI的大多数函数操作的特定的栈，Lua是如何知道应该使用哪个栈的呢？当调用lua_pushnumber时，是怎么制定将数字压入何处的呢？秘密在于lua_State类型，即这些函数的第一个参数，它不仅表示一个Lua状态，还表示带有该状态的一个线程。<br>当创建一个Lua状态时，Lua就会自动用这个状态创建一个主线程，并返回代表该线程的lua_State。这个主线程永远不会被垃圾回收，它只会调用lua_close关闭状态时随着状态一起释放。与线程无关的程序会在这个主线程中运行所有的代码。<br>调用lua_newthread可以在一个状态中创建其他的线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_State *<span class="title function_">lua_newthread</span> <span class="params">(lua_State *L)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数会将新线程作为一个”thread”类型的值压入栈中，并返回一个表示新线程的lua_State类型的指针。例如，考虑如下的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L1 = lua_newthread(L);</span><br></pre></td></tr></table></figure>
<p>执行上述代码后，我们就有了两个线程L1和L，它们都在内部引用了相同的Lua状态。每个线程都有其自己的栈。新线程L1从空栈开始运行，而老线程L在其栈顶会引用这个新线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lua_gettop(L1));  -- <span class="number">0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,luaL_typename(L,<span class="number">-1</span>));   -- thread</span><br></pre></td></tr></table></figure>
<p>除主线程以外，线程和其他的Lua对象一样都是垃圾回收的对象。当新建一个线程时，新创建的线程会被压入栈中，这样就保证了新线程不会被垃圾收集。永远不要使用未被正确锚定在Lua状态中的线程。所有对LuaAPI的调用都有可能回收未锚定的线程，即使是在正在使用这个线程的函数调用。例如，考虑如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_State *L1 = lua_newthread(L);</span><br><span class="line">lua_pop(L,<span class="number">1</span>);</span><br><span class="line">lua_pushstring(L1,<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>调用lua_pushstring可能会触发垃圾收集器并回收L1，从而导致应用崩溃，尽管L1正在被使用。要避免这种情况，应该在诸如一个已锚定线程的栈、注册表或Lua变量中保留一个对使用中线程的引用。<br>一旦拥有一个新线程，我们就可以像使用主线程一样来使用它了。我们可以将元素压入栈中，或者从栈中弹出元素，还可以用它来调用函数等等。例如，如下代码在新线程中调用了f(5)，然后将结果传递到老线程中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lua_getglobal(L1,<span class="string">&quot;f&quot;</span>);  <span class="comment">/* 假设&#x27;f&#x27;是一个全局函数 */</span></span><br><span class="line">lua_pushinteger(L1,<span class="number">5</span>);</span><br><span class="line">lua_call(L1,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">lua_xmove(L1,L,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>函数lua_xmove可以在同一个Lua状态的两个栈之间移动Lua值。一个形如lua_xmove(F,T,n)的调用会从栈F中弹出n个元素，并将它们压入栈T中。<br>不过，对于这类用法，我们不需要用新线程，用主线程就足够了。使用多线程的主要目的是实现协程，从而可以挂起某些协程的执行，并在之后恢复执行。因此，我们需要用到函数lua_resume：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lua_resume</span> <span class="params">(lua_State *L,lua_State *from, <span class="type">int</span> narg)</span>;</span><br></pre></td></tr></table></figure>
<p>要启动一个协程，我们可以像使用lua_pcall一样使用lua_resume：将待调用函数压入栈，然后压入协程的参数，并以参数的数量作为参数narg调用lua_resume（参数from是正在执行调用的线程，或为NULL）。这个行为与lua_pcall类似，但有三个不同点。首先，lua_resume中没有表示期望结果数量的参数，它总是返回被调用函数的额所有结果。其次，它没有表示错误处理函数的参数，发生错误时不会进行栈展开，这样我们就可以在错误发生后检查栈的情况。最后，如果正在运行的哈数被挂起，lua_resume就会返回代码LUA_YIELD,并将线程置于一个可以后续再恢复执行的状态中。<br>当lua_resume返回LUA_YIELD时，线程栈中的可见部分只包含传递给yield的值。调用lua_gettop会返回这些值的个数。如果要将这些值转移到另一个线程，可以使用lua_xmove。<br>要恢复一个挂起的线程，可以再次调用lua_resume。在这种调用中，Lua假设栈中所有的值都会被调用的yield返回。例如，如果在一个lua_resume返回后到再次调用lua_resume时不改变线程的栈，那么yield会原样返回它产生的值。<br>通常，我们会把一个Lua函数作为协程启动协程。这个Lua函数可以调用其他Lua函数，并且其中任意一个函数都可以挂起，从而结束对lua_resume的调用。例如，假设有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">foo</span><span class="params">(x)</span> coroutine.<span class="title function_">yield</span><span class="params">(<span class="number">10</span>,x)</span> end</span><br><span class="line">function <span class="title function_">foo1</span><span class="params">(x)</span> <span class="title function_">foo</span><span class="params">(x + <span class="number">1</span>)</span>; <span class="keyword">return</span> <span class="number">3</span> end</span><br></pre></td></tr></table></figure>
<p>现在运行一下C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lua_State *L1 = lua_newthread(L);</span><br><span class="line">lua_getglobal(L1,<span class="string">&quot;foo1&quot;</span>);</span><br><span class="line">lua_pushinteger(L1,<span class="number">20</span>);</span><br><span class="line">lua_Resume(L1,L,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>调用lua_resume会返回LUA_YIELD，表示线程已交出了控制权。此时，L1的栈便有了位yield指定的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lua_gettpo(L1));			--&gt; <span class="number">2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,lua_tointeger(L1,<span class="number">1</span>));   --&gt; <span class="number">10</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,lua_tointeger(L1,<span class="number">2</span>));   --&gt; <span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>当恢复此线程时，它会从挂起的地方（即调用yield的地方）继续执行。此时，foo会返回到foo1，foo1继而又返回到lua_resume:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_resume(L1,L,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lua_gettpo(L1));   --&gt; <span class="number">1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,lua_tointeger(L1,<span class="number">1</span>));  --&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>第二次调用lua_resume是会返回NULL_OK，表示一个正常的返回。<br>一个协程也可以调用C语言函数，而C语言函数又可以反过来调用其他Lua函数。我们已经讨论过如何使用延续来让这些Lua函数交出控制权。C语言函数也可以交出控制权。在这这种情况下，它必须提供一个在线恢复时被调用的延续函数。要交出控制权，C语言函数必须调用如下的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lua_yield</span> <span class="params">(lua_State *L, <span class="type">int</span> nresults, <span class="type">int</span> ctx, lua_CFunction k)</span>;</span><br></pre></td></tr></table></figure>
<p>在返回语句中我们应该始终使用这个函数，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> inf <span class="title function_">myCfunction</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> lua_yieldk(L,nreseults,ctx, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个调用会立即挂起正在运行的协程。参数nresults是将要返回给对应的lua_resume的栈中的值的个数；参数ctx是传递给延续的上下文信息；参数k是延续函数。当协程恢复运行时，控制权会直接交给延续函数k；当协程交出控制权后，myCfunction就不会再有其他任何动作，它必须将所有后续的工作委托给延续函数处理。<br>让我们看一个典型的例子。假设要编写一个读取数据的函数，如果无数据可读则交出控制权。我们可能会用C语言写出一个这样的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readK</span> <span class="params">(lua_State *L,<span class="type">int</span> status, lua_KContext ctx)</span>&#123;</span><br><span class="line">	(<span class="type">void</span>)status;(<span class="type">void</span>)ctx; <span class="comment">/* 未使用的参数 */</span></span><br><span class="line">	<span class="keyword">if</span> (something_to_read())&#123;</span><br><span class="line">		lua_pushstring(L,read_some_data());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> lua_yieldk(L,<span class="number">0</span>,<span class="number">0</span>,&amp;readK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">prim_read</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> readK(L,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，prim_read无须做任何初始化，因此它可以直接调用延续函数。如果有数据可读。readK会读取并返回数据；否则，它会交出控制权。当线程恢复时，prim_read会再次调用延续函数，该延续函数会再次尝试读取数据。<br>如果C语言函数在交出控制权之后什么都不做，那么它可以不带延续函数调用lua_yieldk或者使用宏lua_yield:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> lua_yield(L,nres);</span><br></pre></td></tr></table></figure>
<p>在这一句调用之后，当线程恢复时，控制权会返回到名为myCfunction的函数中。</p>
<h2 id="Lua状态"><a href="#Lua状态" class="headerlink" title="Lua状态"></a>Lua状态</h2><p>每次调用luaL_newstate(或lua_newstate)都会创建一个新的Lua状态。不同的Lua状态之间是完全独立的，它们根本不共享数据。也就是说，无论在一个Lua状态中发生了什么，都不会影响其他Lua状态。这也意味着Lua状态之间不能直接通信，因而必须借助一些C语言代码的帮助。例如，给定两个状态L1和L2，如下命令会将L1栈顶的字符串压入L2的栈中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_pushstring(L2,lua_tostring(L1,<span class="number">-1</span>));</span><br></pre></td></tr></table></figure>
<p>由于所有数据必须由C语言进行传递，因此Lua状态之间只能交换能够使用C语言表示的类型，例如字符串和数值。其他诸如表之类的类型必须序列化后才能传递。<br>在支持多线程的系统中，一种有趣的设计是为每个线程创建一个独立的Lua状态。这种设计使得线程类似于POSIX进程，它实现了非共享内存的并发。在本节中，我们会根据这种方法开发一个多线程的原型实现。在这个实现中，将会使用POSIX线程。因为这些代码只使用了一些基础功能，所以将它们移植到其他线程系统中并不难。<br>我们要开发的系统很简单，其主要目的是演示一个多线程环境中使用多个Lua状态。在这个系统开始运行之后，我们可以为它添加几个高级功能。我们把这个库称为lproc，它只提供4个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lproc.start(chunk)</span><br></pre></td></tr></table></figure>
<p>启动一个新进程来运行指定的代码段（一个字符串）。这个库将Lua进程实现为一个C语言进程外加与其相关联的Lua状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lproc.send(channel,val1,val2,...)</span><br></pre></td></tr></table></figure>
<p>将所有指定值（应为字符串）发送给指定的、由名称（也是一个字符串）标识的通道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lproc.receive(channel)</span><br></pre></td></tr></table></figure>
<p>接收发送给指定通道的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lproc.<span class="built_in">exit</span>()</span><br></pre></td></tr></table></figure>
<p>结束一个进程。只有主进程需要这个函数。如果主程序不调用lproc.exit就直接结束，那么整个程序会终止，而不会等待其他进程结束。<br>这个库通过字符串标识不同的通道，并通过字符串来匹配发送者和接收这。一个发送操作可以发送任意数量的字符串，这些字符串由对应的接收操作返回。所有的通信都是同步的，向通道发送消息的进程会一直阻塞，知道有进程从该通道接收信息，从而通道接收信息的进程会一直阻塞，直至有进程向其发送消息。<br>lproc的实现像其接口一样简单，它使用了两个循环双向链表，一个用于等待发送消息的进程，另一个用于等待接收消息的进程。lproc使用一个互斥量来控制对着两个链表的访问。每个进程有一个关联的条件变量。当进程要向通道发送一条消息时，它会遍历接收链表以查找一个在该通道上等到的进程。如果找到了这样的进程，它会将该进程从等待链表中删除，并将消息的值从自身转移到找到的进程中，然后通知其他进程；否则，它就将自己插入发送链表，然后等待其条件变量发生变化。接收消息的操作也与此基本类似。<br>在这种实现中，主要的元素之一就是表示进程的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proc</span>&#123;</span></span><br><span class="line">	lua_State *L;</span><br><span class="line">	<span class="type">pthread_t</span> thread;</span><br><span class="line">	<span class="type">pthread_cond_t</span> cond;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *channel;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proc</span> *<span class="title">previous</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;Proc;</span><br></pre></td></tr></table></figure>
<p>前两个字段表示进程使用的Lua状态和运行该进程的C线程。第三个字段cond是条件变量，线程会在等待匹配的发送&#x2F;接收时用它来使自己进入则塞状态。第四个字段保存了进程正在等待的通过。最后两个字段previous和next将进程的结构体组成等待链表。<br>下面的代码声明了两个等待链表及关联的互斥量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Proc *waitsend = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> Proc *waitreceive = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> kernel_access = PTHERAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>每个进程都需要一个Proc结构体，并且进程脚本调用send或receive时就需要访问这个结构体。这些函数接收的唯一参数就是进程的Lua状态；因此，每个进程都应该将其Proc结构体保存在其Lua状态中。在我们的实现中，每个状态都将其对应的Proc结构体作为完整的用户数据存储在注册表中，关联的键为”_SELF”。辅助函数getself可以从指定的状态中获取相关联的Prco结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Proc *<span class="title function_">getself</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	Proc *p;</span><br><span class="line">	lua_getfield(L&lt;LUA_REGISTRYINDEX,<span class="string">&quot;_SELF&quot;</span>);</span><br><span class="line">	p = (Proc *)lua_touserdata(L,<span class="number">-1</span>);</span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个函数，movevalues，将值从发送进程移动到接收进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">movevalues</span><span class="params">(lua_State *send, lua_State *rec)</span>&#123;</span><br><span class="line">	<span class="type">int</span> n = lua_gettop(send);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	lua_checkstack(rec,n,<span class="string">&quot;too many results&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		lua_pushstring(rec,lua_tostring(send,i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数将发送进程的栈中所有的值移动到接收进程的栈中。请注意，在压入任意数量的元素时，需要检查栈空间。<br>示例定义了函数searchhmatch,该函数会遍历列表以寻找等待指定通道的进程。</p>
<blockquote>
<p>示例 用于寻找等待通道的进程的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Proc *<span class="title function_">serachmatch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *channel, Proc **<span class="built_in">list</span>)</span>&#123;</span><br><span class="line">	Proc *node;</span><br><span class="line">	<span class="keyword">for</span> (node = *<span class="built_in">list</span>; node != <span class="literal">NULL</span>; node = node -&gt;next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(channel, node -&gt;channel) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (*<span class="built_in">list</span> == node)</span><br><span class="line">				*<span class="built_in">list</span> = (node-&gt;next == node)?<span class="literal">NULL</span>:node-&gt;next;</span><br><span class="line">			node-&gt;provious-&gt;next = node -&gt;next;</span><br><span class="line">			node-&gt;next-&gt;previous = node -&gt;previous;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果找到一个进程，那么该函数会将这个进程从列表中移除并返回该进程；否则，该函数会返回NULL。<br>当找不到匹配的进程时，会调用最后的辅助函数，参见下例</p>
<blockquote>
<p>示例 用于在等待列表中新增一个进程的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">waitonlist</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *channel, Proc **<span class="built_in">list</span>)</span>&#123;</span><br><span class="line">	Proc *p = getself(L);</span><br><span class="line">	<span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		*<span class="built_in">list</span> = p;</span><br><span class="line">		p-&gt;previous = p-&gt;next = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		p-&gt;previous = (*<span class="built_in">list</span>)-&gt; previous;</span><br><span class="line">		p-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line">		p-&gt;previous-&gt;next = p-&gt;next-&gt;previous = p;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;channel = channel;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		pthread_cond_wait(&amp;p-&gt;cond,&amp;kernel_access);</span><br><span class="line">	&#125;<span class="keyword">while</span>(p-&gt;channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，进程会将自己链接到相应等待链表的末尾，然后进入等待状态，知道另一个进程与之匹配并将其唤醒。当一个进程唤醒另一个进程时，它会将另一个进程的channel字段设置为NULL。因此，如果p-&gt;channel不是NULL，那就表示尚未出现与进程p匹配的进程，所以需要继续等待。<br>有了这些辅助函数，我们就可以编写send和receive了</p>
<blockquote>
<p>示例 用于发送和接收消息的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ll_send</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	Proc *p;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *channel = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">	pthread_mutex_lock(&amp;kernel_access);</span><br><span class="line">	p = searchmatch(channel,&amp;waitreceive);</span><br><span class="line">	<span class="keyword">if</span>(p)&#123;</span><br><span class="line">		movevalues(L,p-&gt;L);</span><br><span class="line">		p-&gt;channel = <span class="literal">NULL</span>;</span><br><span class="line">		pthread_cond_signal(&amp;p-&gt;cond);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		waitonlist(L,channel,&amp;waitsend);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_unlock(&amp;kernel_access);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ll_receive</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	Proc *p;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *channel = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">	lua_settop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;kernel_access);</span><br><span class="line">	p = searchmatch(channel,&amp;waitsend);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p)&#123;</span><br><span class="line">		movevalues(p-&gt;L,L);</span><br><span class="line">		p-&gt;channel = <span class="literal">NULL</span>;</span><br><span class="line">		pthread_cond_signal(&amp;p-&gt;cond);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		waitonlist(L,channel,&amp;waitreceive);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_unlock(&amp;kernel_access);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lua_gettop(L) <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数ll_send先获取通道，然后锁住互斥量并搜索匹配的接收进程。如果找到了，就把待发送的值传递给这个接收进程，然后将接收进程标记为就绪状态并唤醒接收进程。否则，发送进程就将自己放入等待链表。当操作完成后，ll_send解锁互斥量且不向Lua返回任何值。函数ll_receive与之类似，但它会返回所有接收到的值。<br>现在，让我们看一下如何创建新进程。新进程需要一个新的POSIX线程，而POSIX线程的运行需要一个线程体。我们会在后面的内容中定义这个线程体。在此，先看一下它的原型，这是pthreads所需求的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">ll_thread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<p>要创建并运行一个新进程，我们开发的系统必须创建一个新的Lua状态，启动一个新线程，编译指定的代码段，调用该代码段，最后释放其资源。原线程会完成前面三个任务，而新线程则负责其余任务。<br>函数ll_start可以创建一个新的进程。</p>
<blockquote>
<p>示例 用于创建进程的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ll_start</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> thread;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *chunk = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">	lua_State *L1 = luaL_newstate();</span><br><span class="line">	<span class="keyword">if</span>(L1 == <span class="literal">NULL</span>)</span><br><span class="line">		lua_error(L,<span class="string">&quot;unable to create new state&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (luaL_loadstring(L1,chunk) ！= <span class="number">0</span>)</span><br><span class="line">		luaL_error(L,<span class="string">&quot;error in thread body:%s&quot;</span>,lua_tostring(L1,<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pthread_create(&amp;thread,<span class="literal">NULL</span>,ll_thread,L1)!=<span class="number">0</span>)</span><br><span class="line">		luaL_error(L,<span class="string">&quot;unable to create new thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pthread_detach(thread);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数创建了一个新的Lua状态L1，并在其中编译了指定的代码段。如果有错误发生，该函数会把错误传递给原来的状态L。然后，该函数使用ll_thread作为线程体创建一个新线程，同时将新状态L1作为参数传递给这个线程体。最后，该函数调用pthread_detach通知系统我们不需要该线程的任何运行结果。<br>每个新线程的线程体都是函数ll_thread，它接手相应的Lua状态，这个Lua状态的栈中只含有预编译的主代码段。</p>
<blockquote>
<p>示例  新线程的线程体</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaopen_lproc</span><span class="params">(lua_State *L)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">ll_thread</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	lua_State *L = (lua_State *) arg;</span><br><span class="line">	Proc *self;</span><br><span class="line"></span><br><span class="line">	openlibs(L);</span><br><span class="line">	luaL_requiref(L,<span class="string">&quot;lproc&quot;</span>,luaopen_lproc,<span class="number">1</span>);</span><br><span class="line">	lua_pop(L,<span class="number">1</span>);</span><br><span class="line">	self = (Proc *)lua_newuserdata(L,<span class="keyword">sizeof</span>(Proc));</span><br><span class="line">	lua_setfield(L,LUA_REGISTRYINDEX, <span class="string">&quot;_SELF&quot;</span>);</span><br><span class="line">	self-&gt;L = L;</span><br><span class="line">	self-&gt;thread = pthread_self();</span><br><span class="line">	self-&gt;channel = <span class="literal">NULL</span>;</span><br><span class="line">	pthread_cond_init(&amp;self-&gt;cond,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,)!=<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;thread error: %s&quot;</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">	pthread_cond_destroy(&amp;getself(L)-&gt;cond);</span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该函数打开Lua标准库和库lproc；之后，它创建并初始化其自身的控制块；然后，调用主代码段；最后，销毁其条件变量并关闭Lua状态。<br>请注意使用luaL_requiref打开库lproc的用法。这个函数在某种意义上等价于require，但它用指定函数来打开库而没有搜索打开函数。在调用这个打开函数后，luaL_requiref会在表package.loaded中注册结果，这样以后再调用require加载这个库时就无须再次打开库了。当luaL_requiref的最后一个参数为真时，该函数还会在相应的全局变量中注册这个库。<br>示例演示了这个模块中的最后一个函数</p>
<blockquote>
<p>示例 模块lproc的其他函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> inti <span class="title function_">ll_exit</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">l_funcs</span>[] =</span>&#123;</span><br><span class="line">	&#123;<span class="string">&quot;start&quot;</span>,ll_start&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;send&quot;</span>,ll_send&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;receive&quot;</span>,ll_receive&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;exit&quot;</span>,ll_exit&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_lproc</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newlib(L,ll_funcs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数都很简单。函数ll_exit应该只能在主进程结束时由主进程调用，以避免整个程序立即结束。函数luaopen_lproc是用于打开这个模块的标准函数。<br>正如笔者之前说过的，在Lua语言中这种进程的实现方式非常简单。我们可以对它进行各种改进，这里简单介绍几种。<br>第一种显而易见的改进是改变对匹配通道的线性查找，更好的选择是用哈希表来寻找通道，并为每个通道设置一个独立的等待列表。<br>另一种改进涉及创建进程的效率。创建一个新的Lua状态时一个轻量级操作，但打开所有的标准库可不是轻量级的，并且大部分进程可能并不需要用到所有的标准库。我们可以通过对库进行预注册来避免打开无用的库。相对于为每个标准库调用luaL_requiref，使用这种方法时我们只需要将库的打开函数放入表package.preload中即可。当且仅当进程调用require”lib”时，require才会调用这个与库相关的函数来打开库。</p>
<blockquote>
<p>示例 注册按需打开的库</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">registerlib</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *name,lua_CFunction f)</span>&#123;</span><br><span class="line">	lua_getglobal(L,<span class="string">&quot;package&quot;</span>);</span><br><span class="line">	lua_getfield(L,<span class="number">-1</span>,<span class="string">&quot;preload&quot;</span>);</span><br><span class="line">	lua_pushcfunction(L,f);</span><br><span class="line">	lua_setfield(L,<span class="number">-2</span>,name);</span><br><span class="line">	lua_pop(L,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">openlibs</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_requiref(L,<span class="string">&quot;_G&quot;</span>,luaopen_base,<span class="number">1</span>);</span><br><span class="line">	lua_requiref(L,<span class="string">&quot;package&quot;</span>,luaopen_package,<span class="number">1</span>);</span><br><span class="line">	lua_pop(L,<span class="number">2</span>);</span><br><span class="line">	registerlib(L,<span class="string">&quot;coroutine&quot;</span>,luaopen_coroutine);</span><br><span class="line">	registerlib(L,<span class="string">&quot;table&quot;</span>,luaopen_table);</span><br><span class="line">	registerlib(L,<span class="string">&quot;io&quot;</span>,luaopen_io);</span><br><span class="line">	registerlib(L,<span class="string">&quot;os&quot;</span>,luaopen_os);</span><br><span class="line">	registerlib(L,<span class="string">&quot;string&quot;</span>,luaopen_string);</span><br><span class="line">	registerlib(L,<span class="string">&quot;math&quot;</span>,luaopen_math);</span><br><span class="line">	registerlib(L,<span class="string">&quot;utf8&quot;</span>,luaopen_utf8);</span><br><span class="line">	registerlib(L,<span class="string">&quot;debug&quot;</span>,luaopen_debug);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况都需要打开基础库。另外，我们还需要package库；如果没有package库，就无法通过require来打开其他库。所有其他的库都是可选的。因此，除了调用luaL_openlibs之外，可以在打开新状态时调用我们自己的函数openlibs。当进程需要用到其中任意一个库时，只需显式地调用require，require就会调用相应的luaopen_*函数ll_start可以创建一个新的进程。<br>另一个改进涉及通信原语。例如，为lproc.send和lproc.receive设置一个等待匹配的时间阀值会非常有用。特别的，当等待时间阈值为零时，这两个函数会成为非阻塞的。在POSIX线程中，可以用pthread_cond_timedwait实现这个功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/23/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%8A%B6%E6%80%81/" data-id="clw7ne0ze00g04sad01nleujt" data-title="Lua连续教程之Lua线程和状态" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Mac-Xcode各种目录路径和调试方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/22/Mac-Xcode%E5%90%84%E7%A7%8D%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E5%92%8C%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-07-22T02:54:16.000Z" itemprop="datePublished">2020-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/22/Mac-Xcode%E5%90%84%E7%A7%8D%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E5%92%8C%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/">Mac-Xcode各种目录路径和调试方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>hosts文件所在目录:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/private/etc/</span><br></pre></td></tr></table></figure>

<p>xcode插件目录:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Application</span> <span class="title class_">Support</span>/<span class="title class_">Developer</span>/<span class="title class_">Shared</span>/<span class="title class_">Xcode</span>/<span class="title class_">Plug</span>-ins</span><br></pre></td></tr></table></figure>
<p>模拟器上app应用运行生成缓存文件：删除无影响，可重新生成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">XCPGDevices</span></span><br></pre></td></tr></table></figure>
<p>Xcode对模拟器缓存路径：如果删除下次运行时间会较长，但不影响使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">Xcode</span>/<span class="title class_">DerivedData</span></span><br></pre></td></tr></table></figure>
<p>Xcode中卸载多余模拟器位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/资源库/<span class="title class_">Developer</span>/<span class="title class_">CoreSimulator</span>/<span class="title class_">Profiles</span>/<span class="title class_">Runtimes</span>/</span><br></pre></td></tr></table></figure>
<p>Xcode对真机设备支持: 连接设备时自动生成对应的版本支持文件，如果删除了，再次连接还会重新生成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">Xcode</span>/iOS <span class="title class_">DeviceSupport</span></span><br></pre></td></tr></table></figure>
<p>Xcode6以后的模拟器的位置。每个长串名字的文件夹代表一个模拟器，在它的device.plist文件可以看到具体的哪个模拟器型号。不可恢复。慎重删除，删除之后再用就得重新下载了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">CoreSimulator</span>/<span class="title class_">Devices</span></span><br></pre></td></tr></table></figure>
<p>提交App Store或者Adhoc时打包的ipa文件路径，删除了不可恢复，可重新打包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">Xcode</span>/<span class="title class_">Archives</span></span><br></pre></td></tr></table></figure>
<p>删除多余配置证书路径:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">MobileDevice</span>/<span class="title class_">Provisioning</span> <span class="title class_">Profiles</span></span><br></pre></td></tr></table></figure>
<p>pod缓存路径:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Caches</span>/<span class="title class_">CocoaPods</span>/<span class="title class_">Pods</span>/<span class="title class_">Release</span></span><br></pre></td></tr></table></figure>
<p>XCode来定位循环引用的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）在product－Analyze中使用静态分析来检测代码中可能存在循环引用的问题。</span><br><span class="line"></span><br><span class="line">2）在Xcode－open developer tool－Instruments打开工具集，选择Leaks工具可以对已安装的应用进行内存泄漏检测，此工具能检测静态分析不会提示，但是到运行时才会出现的内存泄漏问题。</span><br></pre></td></tr></table></figure>
<p>Xcode来定位及分析僵尸对象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ）在product－scheme－edit scheme－diagnostics中将enable zombie objects勾选上。</span><br><span class="line"></span><br><span class="line">2）在Xcode－open developer tool－Instruments打开工具集，选择Zombies工具可以对已安装的应用进行僵尸对象检测。</span><br></pre></td></tr></table></figure>
<p>存在多Xcode 时，更改默认路径：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Xcode</span> &gt; <span class="title class_">Preferences</span> &gt; <span class="title class_">Locations</span>路径查看到正在使用的版本和该版本路径。可下拉选择需要版本。</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/22/Mac-Xcode%E5%90%84%E7%A7%8D%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E5%92%8C%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/" data-id="clw7ne0xm00464sadg5gsfxjy" data-title="Mac-Xcode各种目录路径和调试方法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xcode/" rel="tag">Xcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mac/" rel="tag">mac</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-资源管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/22/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-07-21T16:52:38.000Z" itemprop="datePublished">2020-07-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/22/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">Lua连续教程之Lua资源管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>函数dir会遍历目录并返回一张包含指定目录下所有内容的表。这里对dir新的实现会返回一个迭代器，每次调用这个迭代器时它都会返回一个新元素。通过这种实现，我们就能使用如下的循环来遍历目录：</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> <span class="built_in">dir</span>.<span class="built_in">open</span>(<span class="string">&quot;.&quot;</span>)do</span><br><span class="line">	<span class="built_in">print</span>(fname)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>要在C语言中遍历一个目录，我们需要用到DIR结构体。DIR的实例由opendir创建，且必须通过调用closedir显示地释放。在之前的实现中，我们将DIR的示例当做局部变量，并在或获取最后一个文件名后释放了它。而在新的实现中，由于必须通过多次调用来查询该值，因此不能把DIR的实例保存到局部变量中。此外，不能在获取最后一个文件名后再释放DIR的示例，因为如果程序从循环中跳出，那么迭代器永远不会获取最后一个文件名。因此，为了确保DIR的实例能被正确释放，需要把该实例的地址存入一个用户数据中，并且用这个用户数据的远方__gc来释放该结构体。<br>尽管用户数据在我们实现中处于核心地位，但这个表示目录数据并不一定需要对Lua可见。函数dir.open会返回一个Lua可见的迭代函数，而目录可以作为迭代函数的一个上值。这样，迭代函数能直接访问这个结构体，而Lua代码则不能。<br>总之，我们需要三个C语言函数。首先，我们需要函数dir.open，该函数是一个工厂函数，Lua调用该函数来创建迭代器；它必须打开一个DIR结构体，并将这个结构体作为上值创建一个迭代函数的闭包。其次，我们需要迭代函数。最后，我们需要__gc元方法，该元方法用于释放DIR结构体。通常情况下，我们还需要一个额外的函数进行一些初始化工作，例如为目录创建和初始化元表。<br>先来看函数dir.open，参加下面示例</p>
<blockquote>
<p>示例 工厂函数dir.open</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*迭代函数的前向声明*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dir_iter</span><span class="params">(lua_State *L)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_dir</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">/*创建一个保存DIR结构体的用户数据*/</span></span><br><span class="line">	DIR **d = (DIR **)lua_newuserdata(L,<span class="keyword">sizeof</span>(DIR *));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 预先初始化*/</span></span><br><span class="line">	*d = <span class="literal">NULL</span>；</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*设置元表*/</span></span><br><span class="line">	luaL_getmetatable(L,<span class="string">&quot;LuaBook.dir&quot;</span>);</span><br><span class="line">	lua_setmetatable(L,<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*尝试打开指定目录*/</span></span><br><span class="line">	*d = opendir(path);</span><br><span class="line">	<span class="keyword">if</span> (*d == <span class="literal">NULL</span>)  <span class="comment">/* 打开目录失败*/</span></span><br><span class="line">		luaL_error(L, <span class="string">&quot;cannot open %s:%s&quot;</span>,path,strerror(errno));</span><br><span class="line">	<span class="comment">/*创建并返回迭代函数；该函数唯一的上值，即代表目录的用户数据本身就位于栈顶*/</span></span><br><span class="line">	lua_pushcclosure(L,dir_iter,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中要注意的是，必须在打开目录前先创建用户数据。如果先打开目录再调用lua_newuserdata，那么会引发内存错误，该函数会丢失并泄露DIR结构体。如果顺序正确，DIR结构体一旦被创建就会立即与用户数据相关联；无论此后发生什么，元方法__gc最终都会将其释放。<br>另一个需要注意的点是用户数据的一致性。一旦设置了元表，元方法__gc就一定会被调用。因此，在设置元表前，我们需要使用NULL预先初始化用户数据，以确保用户数据具有定义明确的值。<br>下一个函数dir_iter也就是迭代器本身。</p>
<blockquote>
<p>示例 dir库中的其他函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dir_iter</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	DIR *d = *(DIR **)lua_touserdata(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span> =</span> readdir(d);</span><br><span class="line">	<span class="keyword">if</span> (entry != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		lua_pushstring(L,entry -&gt;d_name);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 遍历完成*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dir_gc</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">	DIR *d = *(DIR **)lua_touserdata(L,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(d) closedir(d);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">dirlib</span> [] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;open&quot;</span>,l_dir&#125;,</span><br><span class="line">	(<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_dir</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newmetatable(L,<span class="string">&quot;luaBook.dir&quot;</span>);</span><br><span class="line">	<span class="comment">/*设置__gc字段*/</span></span><br><span class="line">	lua_pushcfunction(L,dir_gc);</span><br><span class="line">	lua_setfield(L,<span class="number">-2</span>,<span class="string">&quot;__gc&quot;</span>);</span><br><span class="line">	<span class="comment">/*创建库*/</span></span><br><span class="line">	luaL_newlib(L,dirlib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码很简单，它从上值中获取DIR结构体的地址，然后调用readdir读取下一个元素。<br>函数dir_gc就是元方法__gc，该元方法用于关闭目录。正如之前提到的，该元方法必须做好防御措施：如果初始化出现错误，那么目录可能会是NULL。<br>整个示例中还有一点需要注意。dir_gc似乎应该检查其参数是否为一个目录以及目录是否已经被关闭；否则，恶意用户可能会用其他类型的用户数据来调用dir_gc或者关闭一个目录两次，这样会造成灾难性后果。然而，Lua程序时无法访问这个函数的：该函数被保存在目录的元表中，而用户数据又被保存为迭代函数的上值，因此Lua代码无法访问这些目录。</p>
<h2 id="XML解析器"><a href="#XML解析器" class="headerlink" title="XML解析器"></a>XML解析器</h2><p>接下来，我们介绍一种使用Lua语言编写的Expat绑定的简单实现，称为lxp。Expat是一个用C语言编写的开源XML1.0解析器，实现了SAX，即<em>Simple API for XML</em>。SAX是一套基于事件的API，这就意味着一个SAX解析器在读取XML文档时会边读取边通过回调函数向应用上报读取到的内容。例如，如果让Expat解析形如”<tag cap="5">hi</tag>“的字符串，那么Expat会生成三个事件：当读取到子串”<tag cap ="5">“时，生成开始元素事件；当读取到”hi”时，生成文本事件，也称为字符数据事件；当读取到”</tag>“时，生成结束元素事件。每个事件都会调用应用中相应的回调处理器。<br>在此我们不会介绍整个Expat库，只关注于那些用于演示与Lua交互的新技术部分。虽然Expat可以处理很多不同的事件，但我们只考虑前面示例中所提到的三个事件（开始元素、结束元素和文本事件）。<br>本例中用到的Expat API很少。首先，我们需要用于创建和销毁Expat解析器的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XML_Parser <span class="title function_">XML_ParserCreate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *encoding)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">XML_PaserFree</span><span class="params">(XML_Parser p)</span>;</span><br></pre></td></tr></table></figure>
<p>参数encoding是可选的，本例中将使用NULL。<br>当解析器创建完成后，必须注册回调处理器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XML_SetElementHandler</span><span class="params">(SML_Parser p,XML_StartElementHandler start,XML_EndElementHandler end)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">XML_SetCharacterDataHandler</span><span class="params">(XML_Parser p, XML_CharacterDataHandler hndl)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个函数为开始元素和结束元素事件注册了处理函数，第二个函数为文本（XML术语中的字符数据character data)事件注册了处理函数。<br>所有回调处理函数的第一个参数都是用户数据，开始元素事件的处理函数还能接收标签名（tag name）及其属性（attribute):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*XML_StartElementHandler)</span><span class="params">(<span class="type">void</span> *uData, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> **atts)</span>;</span><br></pre></td></tr></table></figure>
<p>属性是一个以NULL结尾的字符串数组，其中每对连续的字符串保存一个属性的名称和值。结束元素事件处理函数除了用户数据外还有一个额外的参数，即标签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(XML_EndElementHandler)</span><span class="params">(<span class="type">void</span> *uData, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>最后，文本事件处理函数只接收文本作为额外参数，该文本字符串不是以NULL结尾的，它有一个显示的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*XML_CharacterDataHandler)(void *uData, const char *s, int len);</span><br><span class="line">```c</span><br><span class="line">为了将文本输入Expat，可以使用如下的函数：</span><br></pre></td></tr></table></figure>
<p>int XML_Parser(XML_Parser p, const char *s, int len, int isLast);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expat通过连续调用函数XML_Parse一段一段地接收要解析的文档。XML_Parse的最后一个参数，布尔类型的isLast，告知Expat该片段是否是文档的最后一个片段。如果检测到解析错误，XML_返回零。</span><br><span class="line">Expat中要用到的最后一个函数允许我们设置传递给事件处理函数的用户数据：</span><br><span class="line">```c</span><br><span class="line">void XML_SetUserData(XML_Parser p, void *uData);</span><br></pre></td></tr></table></figure>
<p>现在，让我们看一下如何在Lua中使用这个库。第一种方法是一种直接的方法，即简单地把所有函数导出给Lua。另一个更好的方法是让这些函数适配Lua。例如，因为Lua语言不是强类型的，所以不需要为每一种回调函数设置不同的函数。我们可以做得更好，甚至免去所有注册回调函数的函数。我们要做的只是创建解析器时提供一个包含所有事件处理函数的回调函数表，其中每一个键值对是与相应时间对应的键和事件处理函数。例如，如果需要打印出一个文档的布局，可以使用如下的回调函数表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local count = <span class="number">0</span></span><br><span class="line">callbacks = &#123;</span><br><span class="line">	StartElement = function(parser, tagname)</span><br><span class="line">		io.write(<span class="string">&quot;+ &quot;</span>, string.rep(<span class="string">&quot; &quot;</span>,count),tagname,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		count = count + <span class="number">1</span></span><br><span class="line">	end,</span><br><span class="line"></span><br><span class="line">	EndElement = function (parser,tagname)</span><br><span class="line">		count = count - <span class="number">1</span></span><br><span class="line">		io.write(<span class="string">&quot;- &quot;</span>,string.rep(<span class="string">&quot; &quot;</span>,count),tagname,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	end,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入内容”<to><yes/></to>“时，这些事件处理函数会打印出如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ to</span><br><span class="line">+   yes</span><br><span class="line">-   yes</span><br><span class="line">- to</span><br></pre></td></tr></table></figure>
<p>有了这个API，我们就不再需要那些操作回调函数的函数了，可以直接在回调函数表中操作它们。因此，整个API只需用到三个函数：一个用于创建解析器，一个用于解析文本，一个用于关闭解析器。实际上，我们可以将后两个函数实现为解析器对象的方法。该API的典型用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local lxp = require <span class="string">&quot;lxp&quot;</span></span><br><span class="line">p = lxp.new(callbacks)</span><br><span class="line"><span class="keyword">for</span> l in io.lines() <span class="keyword">do</span></span><br><span class="line">	assert(p:parse(l))</span><br><span class="line">	assert(p:parse(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">assert(p:parse())</span><br><span class="line">p:close()</span><br></pre></td></tr></table></figure>
<p>现在，让我们来看看如何实现它。首先要决定如何在Lua语言中表示一个解析器。我们会很自然地想到使用用户数据来包含C语言结构体，但是需要在用户数据中放些什么东西呢？我们至少需要实际的Expat解析器来回调函数表。由于这些解析器对象都是Expat回调函数接收的，并且回调函数需要调用Lua语言，因此还需要保存Lua状态。我们可以直接在C语言结构体中保存Expat解析器和Lua状态；而对于作为Lua语言值的回调函数表，一个选择是在注册表中为其创建引用并保存该引用，另一个选择是使用用户值。每个用户数据都可以有一个与其直接关联的唯一的Lua语言值，这个值就被叫做用户值。要是使用这种方式的话，解析器对象的定义形如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;expat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lxp_userdata</span>&#123;</span></span><br><span class="line">	XML_Parser parser;</span><br><span class="line">	lua_State *L;</span><br><span class="line">&#125;lxp_userdata;</span><br></pre></td></tr></table></figure>
<p>下一步是创建解析器对象的函数lxp_make_parser,参考下例</p>
<blockquote>
<p>示例 创建XML解析器对象的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回调函数的前向声明 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_StartElemnt</span> <span class="params">(<span class="type">void</span> *ud, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> **atts)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_CharData</span><span class="params">(<span class="type">void</span> *ud, <span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lxp_make_parser</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	XML_Parser p;</span><br><span class="line">	<span class="comment">/* 创建解析器对象 */</span></span><br><span class="line">	lxp_userdata *xpu = (lxp_userdata *)lua_newuserdata(L, <span class="keyword">sizeof</span>(lxp_userdata));</span><br><span class="line">	<span class="comment">/* 预先初始化以防止错误发生 */</span></span><br><span class="line">	xpu-&gt;parser = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置元表*/</span></span><br><span class="line">	luaL_getmetatable(L, <span class="string">&quot;Expat&quot;</span>);</span><br><span class="line">	lua_setmetatable(L,<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建Expat解析器 */</span></span><br><span class="line">	p = xpu-&gt; parser = XML_ParserCreate(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">		luaL_error(L,<span class="string">&quot;XML_ParserCreate failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查并保存回调函数表*/</span></span><br><span class="line">	luaL_checktype(L,<span class="number">1</span>,LUA_TTABLE );</span><br><span class="line">	lua_pushvalue(L,<span class="number">1</span>); <span class="comment">/* 回调函数表入栈 */</span></span><br><span class="line">	lua_setuservalue(L,<span class="number">-2</span>); <span class="comment">/* 将回调函数表设置为用户值*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置Expat解析器 */</span></span><br><span class="line">	XML_SetUserData(p,xpu);</span><br><span class="line"></span><br><span class="line">	XML_SetElementHandler(p,f_StartElemnt, f_EndElement);</span><br><span class="line">	XML_SetCharacterDataHandler(p,f_CharData);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数有四个主要步骤。</p>
<ul>
<li>第一步遵循常见的模 式：先创建用户数据，然后使用一致性的值预先初始化用户数据，最后设置用户数据的元表（其中的预先初始化确保如果在初始化过程中发生了错误，解析器能够以一致性的状态处理用户数据）。</li>
<li>第二步中，该函数创建了一个Expat解析器，将其存储到用户数据中，并检查了错误。</li>
<li>第三步保证该函数的第一个参数是一个表（回调函数表），并将其作为用户值赋给了新的用户数据。</li>
<li>最后一步初始化Expat解析器，将用户数据设为传递给回调函数的对象，并设置了回调函数。请注意，这些回调函数对于所有的解析器来说都是相同的；毕竟，用户无法在C语言中动态地创建新函数。不同点在于，这些固定的C语言函数会通过回调函数表来决定每次应该调用哪些Lua函数。<br>接下来是解析函数lxp_parse，该函数用于解析XML数据片段。<blockquote>
<p>示例 解析XML片段的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lxp_parse</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	<span class="type">size_t</span> len;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line">	lxp_userdata *xpu;</span><br><span class="line">	<span class="comment">/* 获取并检查第一个参数 */</span></span><br><span class="line">	xpu = (lxp_userdata *)luaL_checkudata(L,<span class="number">1</span>,<span class="string">&quot;Expat&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查解析器是否已经被关闭了*/</span></span><br><span class="line">	luaL_argcheck(L,xpu-&gt;parser != <span class="literal">NULL</span>, <span class="number">1</span>,  <span class="string">&quot;parser is closed&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取第二个参数*/</span></span><br><span class="line">	s = luaL_optlstring(L,<span class="number">2</span>,<span class="literal">NULL</span>, &amp;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将回调函数表放在栈索引为3的位置 */</span></span><br><span class="line">	lua_settop(L,<span class="number">2</span>);</span><br><span class="line">	lua_getuservalue(L,<span class="number">1</span>);</span><br><span class="line">	xpu-&gt;L = L; <span class="comment">/*设置Lua状态*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*调用Expat解析字符串*/</span></span><br><span class="line">	status = XML_Parse(xpu-&gt;parser , s, (<span class="type">int</span>)len , s == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 返回错误码 */</span></span><br><span class="line">	lua_pushboolean(L,status);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该函数有两个参数，即解析器对象和一个可选的XML数据。如果调用该函数时未传入XML数据，那么它谁通知Expat文档已结束。<br>当lxp_parse调用XML_Parse时，后一个函数会为指定文件片段中找到的每个相关元素调用处理函数。这些处理函数需要访问回调函数表，因此lxp_parse会将这个表放到栈索引为3的位置。在调用XML_Parse时还有一个细节：请注意，该函数的最后一个参数会告诉Expat文本的指定片段是否为最后一个片段。当不带参数调用parse时，s是NULL，这样最后一个参数就为真。<br>现在我们把注意力放到处理回调的f_CharData、f_StartElement和f_EndElement函数上。这三个函数的代码结构类似，它们都会检查回调函数表是否为指定的事情定义了Lua处理函数，如果是，则准备好参数并调用这个处理函数。<br>首先来看实力中的梳理函数f_CharData.<blockquote>
<p>示例 字符数据事件的处理函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_CharData</span><span class="params">(<span class="type">void</span> *ud , <span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">	lxp_userdata *xpu = (lxp_userdata *)ud;</span><br><span class="line">	lua_State *L = xpu -&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从回调函数表中获取处理函数 */</span></span><br><span class="line">	lua_getfield(L,<span class="number">3</span>,<span class="string">&quot;CharacterDara&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (lua_isnil(L,<span class="number">-1</span>)) &#123; <span class="comment">/* 没有处理函数？ */</span></span><br><span class="line">		lua_pop(L,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lua_pushvalue(L,<span class="number">1</span>); <span class="comment">/* 解析器压栈*/</span></span><br><span class="line">	lua_pushlstring(L,<span class="number">1</span>,len); <span class="comment">/* 压入字符数据 */</span></span><br><span class="line">	lua_call(L,<span class="number">2</span>,<span class="number">0</span>); <span class="comment">/* 调用处理函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该函数的代码很简单。由于创建解析器时调用了XML_SetUserData，所以处理函数的第一个参数是lxp_userdata结构体。在获取Lua状态后，处理函数就可以访问由lxp_parse设置的位于栈索引3位置的回调函数表，以及位于栈索引1位置的解析器。然后，该函数就可以用解析器和字符数据作为参数调用Lua中对应的处理函数了。<br>处理函数f_EndElement与f_CharData十分相似，参见示例<blockquote>
<p>示例 结束元素事件的处理函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_EndElement</span><span class="params">(<span class="type">void</span> *ud, <span class="type">const</span> <span class="type">char</span> *name)</span>&#123;</span><br><span class="line">	lxp_userdata *xpu = (lxp_userdata *)ud;</span><br><span class="line">	lua_State *L = xpu -&gt;L;</span><br><span class="line"></span><br><span class="line">	lua_getfield(L,<span class="number">3</span>,<span class="string">&quot;EndElement&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (lua_isnil(L,<span class="number">-1</span>))&#123; <span class="comment">/*没有处理函数？*/</span></span><br><span class="line">		lua_pop(L,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	lua_pushvalue(L,<span class="number">1</span>); <span class="comment">/* 解析器压栈 */</span></span><br><span class="line">	lua_pushstring(L,name); <span class="comment">/* 压入标签名 */</span></span><br><span class="line">	lua_call(L,<span class="number">2</span>,<span class="number">0</span>); <span class="comment">/* 调用处理函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该函数也以解析器和标签名（也是一个字符串，但是以null结尾）作为参数调用相应的Lua处理函数。<br>示例演示了最后一个处理函数f_StartElement.<blockquote>
<p>示例  开始元素事件的处理函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_StartElemnt</span> <span class="params">(<span class="type">void</span> *ud, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> **atts)</span>&#123;</span><br><span class="line">	lxp_userdata *xpu = (lxp_userdata *)ud;</span><br><span class="line">	lua_State *L = xpu-&gt;L;</span><br><span class="line"></span><br><span class="line">	lua_getfield(L,<span class="number">3</span>,<span class="string">&quot;StartElement&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (lua_isnil(L,<span class="number">-1</span>)) &#123; <span class="comment">/* 没有处理函数？ */</span>&#125;</span><br><span class="line">		lua_pop(L,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">	lua_pushvalue(L,<span class="number">1</span>); <span class="comment">/* 解析器压栈 */</span></span><br><span class="line">	lua_pushstring(L,name); <span class="comment">/* 压入标签名*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建并填充属性表 */</span></span><br><span class="line">	lua_newtable(L);</span><br><span class="line">	<span class="keyword">for</span> (; *atts; atts += <span class="number">2</span>)&#123;</span><br><span class="line">		lua_pushstring(L, *(atts + <span class="number">1</span>));</span><br><span class="line">		lua_Setfield(l,<span class="number">-2</span>,*atts); <span class="comment">/* table[*atts] = *(atts + 1) */</span></span><br><span class="line">	&#125;</span><br><span class="line">	lua_call(L,<span class="number">3</span>,<span class="number">0</span>); <span class="comment">/* 调用处理函数 */</span></span><br></pre></td></tr></table></figure>
该函数以解析器、标签名和一个属性列表为参数，调用了Lua处理函数。处理函数f_StartElement比其他的处理函数稍微复杂一点，因为它需要将属性的标签列表转换为Lua语言。f_StartElement使用了一种非常自然的转换方法，即创建一张包含属性名和属性值的表。例如，类似这样的开始标签：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;to method = <span class="string">&quot;post&quot;</span> proirity = <span class="string">&quot;hight&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
会产生如下的属性表：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;method = <span class="string">&quot;post&quot;</span>, priority = <span class="string">&quot;hight&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
解析器的最后一个方法是close，参见示例<blockquote>
<p>示例 关闭XML解析器的方法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lxp_close</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	lxp_userdata *xpu = (lxp_userdata *)luaL_checkudata(L,<span class="number">1</span>,<span class="string">&quot;Expat&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 释放Expat解析器 */</span></span><br><span class="line">	<span class="keyword">if</span> (xpu-&gt;parser)</span><br><span class="line">		XML_ParserFree(xpu-&gt;parser);</span><br><span class="line">	xpu-&gt;parser = <span class="literal">NULL</span>; <span class="comment">/* 避免重复关闭*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当关闭解析器时，必须释放其资源，也就是Expat结构体。请注意，由于在创建解析器时可能会发生错误，解析器可能没有这些资源。此外还需注意，如何像关闭解析器一样，在一致的状态中保存解析器，这样当我们试图再次关闭解析器或者垃圾收集器结束解析器时才不会产生问题。实际上，我们可以将这个函数当做终结器来使用。这样便可以确保，即使程序员没有关闭解析器，每个解析器最终也会释放其资源。<br>下面示例是最后一步，它演示了打开库的luaopen_lxp。luaopen_lxp将前面所有的部分组织到一起。<blockquote>
<p>示例 lxp库的初始化代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">lxp_meths</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;parse&quot;</span>, lxp_parse&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;close&quot;</span>, lxp_close&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;__gc&quot;</span>,  lxp_close&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">lxp_funcs</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,lxp_make_parser&#125;，</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_lxp</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="comment">/*创建元表*/</span></span><br><span class="line">	luaL_newmetatble(L,<span class="string">&quot;Expat&quot;</span>);</span><br><span class="line">	<span class="comment">/* metatable.__index = metatable */</span></span><br><span class="line">	lua_pushvalue(L,<span class="number">-1</span>);</span><br><span class="line">	lua_setfield(L,<span class="number">-2</span>,<span class="string">&quot;__index&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*注册方法*/</span></span><br><span class="line">	luaL_setfuncs(L,lxp_meths,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册（只有lxp.new） */</span></span><br><span class="line">	luaL_newlib(L,lxp_funcs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/22/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" data-id="clw7ne0zi00go4sad2eut4k3d" data-title="Lua连续教程之Lua资源管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-c语言中的用户自定义类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/16/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2020-07-16T15:01:47.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/16/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/">c语言中的用户自定义类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>下面这个示例实现了一种很简单的类型，即布尔类型。选用这个示例的只要动机在于它不涉及复杂的算法，便于我们专注于API的问题。不过尽管如此，这个示例本身还是很有用的。当然，我们可以在Lua中用来表示实现布尔数组。但是，在C语言实现中，可以将每个布尔值存储在一个比特中，所使用的内存量不到使用表方法的3%。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>这个示例需要以下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_WORD (CHAR_BIT * sizeof(unsigned int))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I_WORD(i)     ((unsigned int)(i) / BITS_PER_WORD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I_BIT(i)	  (1 &lt;&lt; ((unsigned int)(i) % BITS_PER_WORD))</span></span><br></pre></td></tr></table></figure>
<p>BITS_PER_WORD表示一个无符号整型数的位数，宏I_WORD用于根据指定的索引来计算存放相应比特位的字，I_BIT用于计算访问这个字中相应比特位要用的掩码。<br>我们可以使用一下的结构体来表示布尔数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitArray</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> values[<span class="number">1</span>];</span><br><span class="line">&#125;BitArray;</span><br></pre></td></tr></table></figure>
<p>由于C89标准不允许分配长度为零的数组，所以我们声明数组values的大小为1，仅有一个占位符；等分配数组时，我们再设置数组的实际大小。下面这个表达式可以计算出拥有n个元素的数组大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(BitArray) * I_WORD(n <span class="number">-1</span>) * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>此处n减去1是因为原结构中已经包含了一个元素的空间。</p>
<h2 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h2><p>在第一个版本中，我们使用显示的调用来设置和获取值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">array</span>.new(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">1000</span> <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">array</span>.<span class="built_in">set</span>(a,i,i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">end</span><br><span class="line">print(<span class="built_in">array</span>.get(a,<span class="number">10</span>))			-- <span class="literal">true</span></span><br><span class="line">print(<span class="built_in">array</span>.get(a,<span class="number">11</span>))			-- fales</span><br><span class="line">paint(<span class="built_in">array</span>.size(a))			-- <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>后续我们将介绍如何同时支持像a:get(i)这样的面向对象风格和像a[i]这样的常见语法。<br>在所有版本中，下列函数是一样的，参加示例。</p>
<blockquote>
<p>示例 操作布尔数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">newarray</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i ;</span><br><span class="line">	<span class="type">size_t</span> nbytes;</span><br><span class="line">	BitArray *a;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">1</span>);</span><br><span class="line">	luaL_argcheck(L, n &gt;= <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">	nbytes = <span class="keyword">sizeof</span>(BitArray) + I_WORD(n<span class="number">-1</span>)*<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	a = (BitArray *)lua_newuserdata(L,nbytes);</span><br><span class="line">	a -&gt; size = n;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= I_WORD(n<span class="number">-1</span>); i++)</span><br><span class="line">		a -&gt; values[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setarray</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = (BitArray *)lua_touserdata(L,<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> index = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	luaL_argcheck(L,a != <span class="literal">NULL</span> , <span class="number">1</span>, <span class="string">&quot;&#x27;array&#x27; expected&quot;</span>);</span><br><span class="line">	luaL_argcheck(L,<span class="number">0</span> &lt;= index &amp;&amp; index &lt; a-&gt;size, <span class="number">2</span> <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line"></span><br><span class="line">	luaL_checkany(L,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lua_toboolean(L,<span class="number">3</span>))</span><br><span class="line">		a -&gt; values[I_WORD(index)] |= I_BIT(index);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		a -&gt; values[I_WORD(index)] &amp;= ~I_BIT(index);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getarray</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = (BitArray *)lua_touserdata(L,<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> index = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	luaL_argcheck(L,a != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;&#x27;array&#x27; expected&quot;</span>);</span><br><span class="line">	luaL_argcheck(L,<span class="number">0</span> &lt;= index &amp;&amp; index &lt;  a-&gt;size , <span class="number">2</span>, <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line"></span><br><span class="line">	lua_pushboolean(L, a-&gt; values[I_WORD(index)] &amp; I_BIT(index));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面让我们一点一点地分析。<br>我们首先关心的是如何在Lua中表示一个C语言结构体。Lua语言专门为这类任务提供了一个名为用户数据的剧本类型。用户数据为Lua语言提供了可以用来存储任何数据的原始内存区域，没有预定义的操作。<br>函数lua_newuserdata分配一块指定大小的内存，然后将相应的用户数据压栈，并返回该块内存的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">lua_newuserdata</span> <span class="params">(lua_State *L, <span class="type">size_t</span> ,size)</span>;</span><br></pre></td></tr></table></figure>
<p>如果因为一些原因需要用其他方法来分配内存，可以很容易地创建一个指针大小的用户数据并在其中存储一个指向真实内存块的指针。<br>示例中第一个函数newarray使用lua_newuserdata创建新的数组。newarray的代码很简单，它检查了其唯一的参数，以字节为单位计算出数组的大小，创建了一个适当大小的用户数据，初始化用户数据的各个字段并将其返回给Lua。<br>第二函数是setarray，它有三个参数：数组、索引和新的值。setarray假定数组索引像Lua语言中的那样是从1开始的。因为Lua可以将任意值当做布尔类型，所以我们用luaL_checkany检查第三个参数，不过luaL_checkany只能确保该参数有一个值。如果用不符合条件的参数调用了setarray，将会收到一条解释错误的信息，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">11</span>,<span class="number">0</span>)</span><br><span class="line">	-- <span class="built_in">stdin</span>:<span class="number">1</span>:bad argument #<span class="number">1</span> to <span class="string">&#x27;set&#x27;</span> (<span class="string">&#x27;array&#x27;</span> expected)</span><br><span class="line"><span class="built_in">array</span>.<span class="built_in">set</span>(a,<span class="number">1</span>)</span><br><span class="line">	-- <span class="built_in">stdin</span>:<span class="number">1</span>:bad argument #<span class="number">3</span> to <span class="string">&#x27;set&#x27;</span> (value expected)</span><br></pre></td></tr></table></figure>
<p>示例中的最后一个函数是getarray，该函数类似于setarray,用于获取元素。<br>我们还需要定义一个获取数组大小的函数和一些初始化库的额外代码，参见示例：</p>
<blockquote>
<p>示例 布尔数组库的额外代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getsize</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = (BitArray *)lua_touserdata(L<span class="number">.1</span>);</span><br><span class="line">	luaL_argcheck(L,a != <span class="literal">NULL</span> , <span class="number">1</span>, <span class="string">&quot;&#x27;array&#x27; expected&quot;</span>);</span><br><span class="line">	lua_pushinteger(L, a -&gt; size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib</span>[] =</span>&#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,newarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;set&quot;</span>,setarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;get&quot;</span>,getarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;size&quot;</span>,getsize&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newlib(L, arraylib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再一次使用了辅助库中的luaL_newlib，该函数创建了一张表，并且用数组arraylib指定的”函数名-函数指针”填充了这张表。</p>
<h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><p>我们当前的额实现有一个重大的漏洞。假设用户泄露一条像array.set(io.stdin,1,false)这样的语句，那么io.stdin的值会是一个带有指向文件流（FILE*）的指针的用户数据，array.set会开心地认为它时一个合法的参数；其后果可能就是内存崩溃。这种行为对于任何一个Lua库而言都是不可接受的。无论你如何使用库，都不应该破坏C语言的数据，也不应该让Lua语言崩溃。<br>要区别不同类型的用户数据，一种常见的方法是为每种类型创建唯一的元表。每次创建用户数据时，用相应的元表进行标记；每当获取用户数据时，检查其是否有正确的元表。由于Lua代码不能改变用户数据的元表，因此不能绕过这些检查。<br>我们还需要有个地方来存储这个新的元表，然后才能用它来创建新的用户数据和检查指定的用户数据是否具有正确的类型。我们之前已经看到过，存储元表有两种方法，即存储在注册表中或者库函数的上值中。在Lua语言中，惯例是将所有新的C原因类型注册到注册表中，用类型名作为索引，以元表作为值。由于注册表中还有其他索引，所以必须谨慎选择类型名以避免冲突。在我们的示例中将使用”LuaBook.array”作为这个新类型的名称。<br>通常，辅助库会提供一些函数来帮忙实现这些内容。我们将使用新的辅助函数包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>		<span class="title function_">luaL_newmetatable</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *tname)</span>;</span><br><span class="line"><span class="type">void</span> 	<span class="title function_">luaL_getmatatable</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *tname)</span>;</span><br><span class="line"><span class="type">void</span>   *<span class="title function_">luaL_checkudata</span>  <span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">const</span> <span class="type">char</span> *tname)</span>;</span><br></pre></td></tr></table></figure>
<p>函数luaL_newmetatable会创建一张新表，然后将其压入栈顶，并将该表与注册表中的指定名称关联起来。函数luaL_getmetatable从注册表中获取与tname关联的元表。最后，luaL_checkudata会检查栈中指定位置上的对象是否是于指定名称的元表匹配的用户数据。如果该对象不是用户数数据，或者该用户数据没有正确的元表，luaL_checkudata就会引发错误；否则，luaL_checkudata就返回这个用户数据的地址。<br>现在让我们开始修改前面的代码。第一步是修改打开库的函数，让该函数为数组创建元表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newmetatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">	luaL_newlib(L,arraylib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是修改newarray使其能为其新建的所有数组设置这个元表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">newarray</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	同前</span><br><span class="line">	luaL_getmatatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">	lua_setmetatable(L,<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数lua_setmetatable会从栈中弹出一个表，并将其设置为指定索引上对象的元表。在本例中这个对象就是新建的用户数据。<br>最后，setarray、getarray和getsize必须检查其第一个参数是否是一个有效的数组。为了简化这项任务，我们定义如下的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> checkarray(L) (BitArray *)luaL_checkudata(L,1,<span class="string">&quot;LuaBook.array&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>有了这个宏，getsize的定义就很简单了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getsize</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = checkarray(L);</span><br><span class="line">	lua_pushinteger(L,a-&gt;size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于setarray和getarray还共享了用来读取和检查它们的第二个参数的代码，所以我们将其通用部分提取出来组成了一个新的辅助函数（getparams）</p>
<blockquote>
<p>示例 setarray&#x2F;getarray的新版本</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> *<span class="title function_">getparams</span> <span class="params">(lua_State *L, <span class="type">unsigned</span> <span class="type">int</span> *mask)</span>&#123;</span><br><span class="line">	BitArray *a = checkarray(L);</span><br><span class="line">	<span class="type">int</span> index = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">2</span>) <span class="number">-1</span> ;</span><br><span class="line">	luaL_argcheck(L,<span class="number">0</span> &lt;= index &amp;&amp; index &lt; a-&gt; size, <span class="number">2</span>, <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">	*mask = I_BIT(index);</span><br><span class="line">	<span class="keyword">return</span> &amp;a -&gt; values[I_WORD(index)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setarray</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *entry = getparams(L,&amp;mask);</span><br><span class="line">	luaL_checkany(L,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (lua_toboolean(L,<span class="number">3</span>))</span><br><span class="line">		*entry |= mask;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*entry &amp;= ~mask;</span><br><span class="line">		reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getarray</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *entry = getparams(L,&amp;mask);</span><br><span class="line">	lua_pushboolean(L,*entry &amp; mask);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个新版本中，setarray和getarray都很简单，参见示例。现在，如果调用他们时使用了无效的用户数据，我们将会收到一条相应的错误信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">array</span>.get(io.<span class="built_in">stdin</span>,<span class="number">10</span>)</span><br><span class="line">-- bad argument #<span class="number">1</span> to <span class="string">&#x27;get&#x27;</span> (LuaBook.<span class="built_in">array</span> expected, got FILE*)</span><br></pre></td></tr></table></figure>

<h2 id="面向对象访问"><a href="#面向对象访问" class="headerlink" title="面向对象访问"></a>面向对象访问</h2><p>下一步是将这种新类型转换成一个对象，以便用普通的面向对象语法来操作其实例。例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = array.new(<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(a:size())			-- <span class="number">1000</span></span><br><span class="line">a:<span class="built_in">set</span>(<span class="number">10</span>,true)</span><br><span class="line"><span class="built_in">print</span>(a:get(<span class="number">10</span>))		-- true</span><br></pre></td></tr></table></figure>
<p>请注意，a:size()等价于a.size(a)。因此，我们必须让表达式a.size返回函数getsize。此处的关键机制在于元方法__index。对于表而言，Lua会在找不到的指定键时调用这个元方法；而对于用户数据而言，由于用户数据根本没有键，所以Lua在每次访问时都会调用该元方法。<br>假设我们运行了一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do </span><br><span class="line">	local metaarry = getmetatable(array.new(<span class="number">1</span>))</span><br><span class="line">	metaarry.__index = metaarry</span><br><span class="line">	metaarry.<span class="built_in">set</span> = array.<span class="built_in">set</span></span><br><span class="line">	metaarry.get = array.get</span><br><span class="line">	metaarry.size = array.sizeo</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在第一行中，我们创建了一个数组用户获取分配给metaarray的元表（我们无法在Lua中设置用户数据的元表，但是可以获取用户数据的元表）。然后，将metaarray.__index设置为metaarray。当对a.size求值时，因为对象a是一个用户数据，所以Lua在对象a中无法找到键”size”。因此，Lua会尝试通过a的元表的__index字段来获取这个值，而这个字段正好就是metaarray。由于metaarray.size就是array.size，所以a.size(a)就是我们想要的array.size(a)。<br>当然，用C语言也可以达到相同的效果，甚至还可以做得更好：既然数组有自己的操作的对象，那么在表array中也就无需包含这些操作了。我们的库只需导出一个用于创建新数组的函数new就行了，所有的其他操作都变成了对象的方法。C语言代码同样可以直接注册这些方法。<br>操作getsize、getarray和setarray无须做任何改变，唯一需要改变的是注册它们的方式。换而言之，我们必须修改打开库的函数。首先，我们需要两个独立的函数列表，一个用户常规的函数，另一个用户方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_f</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,newarray&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_m</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;set&quot;</span>,setarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;get&quot;</span>,getarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;size&quot;</span>,getsize&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新的打开函数luaopen_array必须创建元表，并把它赋给自己的__index字段，然后在元表中注册所有方法，创建和填充表array:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL+newetatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);  <span class="comment">// 创建元表</span></span><br><span class="line">	lua_pushvalue(L,<span class="number">-1</span>);   <span class="comment">// 复制元表</span></span><br><span class="line">	lua_setfield(L,<span class="number">-2</span>,<span class="string">&quot;__index&quot;</span>); <span class="comment">// mt.__index = mt</span></span><br><span class="line">	luaL_setfuncs(L,arraylib_m,<span class="number">0</span>);  <span class="comment">// 注册元方法</span></span><br><span class="line">	luaL_newlib(L,arraylib_f);   <span class="comment">// 创建库</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们再次使用了luaL_setfuncs将列表arraylib_m中的函数赋值到栈顶的元表中。然后，调用luaL_newlib创建一张新表，并在该表中注册来自列表arraylib_f的函数。<br>最后，向新类型中新增一个__tostring元方法，这样print(a)就可以打印出”array”以及用括号括起来的数组的大小了。该函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array2string</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = checkarray(L);</span><br><span class="line">	lua_pushfstring(L.<span class="string">&quot;array(%d)&quot;</span>, a-&gt; size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用lua_pushfstring格式化字符串，并将其保留在栈顶。我们还需要将array2string添加到列表arraylib_m中，以此将函数加入到数组对象的元表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_m</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;__tostring&quot;</span>, array2string&#125;,</span><br><span class="line">	other <span class="title function_">methods</span><span class="params">(其他方法)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组访问"><a href="#数组访问" class="headerlink" title="数组访问"></a>数组访问</h2><p>另一种更好的面向对象的表示方法是，使用普通的数组符号来访问数组。只需要简单地使用a[i]就可以替代a:get(i)。对于上面的是示例，由于函数setarray和getarray本身就是按照传递给相应元方法的参数的顺序来接收参数的，所以很容易做到这一点。一种快速的解决方案就是直接在Lua中定义这些元方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local metaarry = getmetatable(array.new(<span class="number">1</span>))</span><br><span class="line">metaarry.__index = array.get</span><br><span class="line">metaarry.__newindex = array.<span class="built_in">set</span></span><br><span class="line">metaarry.__<span class="built_in">len</span> = array.sizeof</span><br></pre></td></tr></table></figure>
<p>必须在数组原来的实现中运行这段代码，无须修改面向对象的访问。这样，就可以使用标准语法了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = array.new(<span class="number">1000</span>)</span><br><span class="line">a[<span class="number">10</span>] = true 			-- <span class="string">&#x27;setarray&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">10</span>])			-- <span class="string">&#x27;getarray&#x27;</span>		-- true</span><br><span class="line"><span class="built_in">print</span>(<span class="comment">#a)				-- &#x27;getsize&#x27;		-- 1000</span></span><br></pre></td></tr></table></figure>
<p>如果还要更加完美，可以在C语言中注册这些元方法。为此，需要再次修改初始化函数。参见如下示例：</p>
<blockquote>
<p>示例 新的初始化比特数组库的代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_f</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,newarray&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_m</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;__newindex&quot;</span>,setarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;__index&quot;</span>,getarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;__len&quot;</span>,getsize&#125;,</span><br><span class="line">	(<span class="string">&quot;__tostring&quot;</span>,array2string),</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newmetatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">	luaL_setfuncs(L,arraylib_m,<span class="number">0</span>);</span><br><span class="line">	luaL_newlib(L,arraylib_f);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个新版本中，仍然只有一个公有函数new，所有的其他函数都只是特定操作的元方法。</p>
<p>##轻量级用户数据<br>到现在为止，我们使用的用户数据成为完全用户数据。Lua语言还提供了另一种数据，成为轻量级用户数据。<br>轻量级用户数据时一个代表C语言指针的值，即它时一个void*值。因为轻量级用户数据是一个值而不是一个对象，所以无须创建它（就好比我们也不需要创建数组）。要将一个轻量级用户数据放入栈中，可以调用lua_pushlightuserdata:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_pushlightuserdata</span><span class="params">(lua_State *L,<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure>
<p>尽管名字差不多，但实际上轻量级用户数据和完全用户数据之间区别很大。轻量级用户数据不是缓冲区，而只是一个指针，它们也没有元表。与数值一样，轻量级用户数据不受垃圾收集器的管理。<br>有时，人们会将轻量级用户数据当做完全用户数据的一种廉价替代物来使用，但这种用法并不普遍。首先，轻量级用户数数据没有元表，因此没有办法得知其类型。其次，不要“完全”二字所迷惑，实际上完全用户数据的开销也并不大。对于给定的内存大小，完全用户数据与malloc相比值增加了一点开销。<br>轻量级用户数据的真正用途是相等性判断。由于完全用户数据时一个对象，因此它只和自身相等；然而，一个轻量级用户数据表示的是一个C语言指针的值。因此，它与所有表示相同指针的轻量级用户数据相等。因此，我们可以使用轻量级用户数据在Lua语言中查找C语言对象。<br>我们已经见到过轻量级用户数据的一种典型用法，即在注册表中被用作键。在这种情况下，轻量级用户数据的相等性是至关重要的。每次使用lua_pushlightuserdata压入相同的地址时，我们都会得到相同的Lua值，也就是注册表中相同的元素。<br>Lua语言中另一种典型的场景是把Lua语言对象当做对应的C语言对象的代理。例如：输入&#x2F;输出库使用Lua中的用户数据来表示C语言的流。当操作时从Lua语言到C语言时，从Lua对象到C对象的映射很简单。还是以输入&#x2F;输出库为例，每个Lua语言流会保存指向其相应C语言流的指针。不过，当操作时从C语言到Lua语言时，这种映射就可能比较棘手。例如，假设在输入&#x2F;输出系统中有某些回调函数（例如，那些告诉我们还有多少数据需要被读取的函数），回调函数接收它要操作的C语言流，那么如何从中得到其相应的Lua对象呢？由于C语言流是由C语言标准库定义的而不是我们定义的，因此无法在C语言流中存储任何东西。<br>轻量级用户数据为这种映射提供了一种好的解决方案。我们可以保存一张表，其中键是带有流地址的轻量级用户数据，值是Lua中表示流的完全用户数据。在回调函数中，一旦有了流地址，就可以将其作为轻量级用户数据，把它当做这张表的索引来获取对应的Lua对象（这张表很可能得事弱引用的；否则，这些完全用户数据可能永远不会被作为垃圾回收）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/16/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/" data-id="clw7ne0yj00a24sad63ivbcwy" data-title="c语言中的用户自定义类型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-编写C函数的技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/09/%E7%BC%96%E5%86%99C%E5%87%BD%E6%95%B0%E7%9A%84%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2020-07-09T14:45:28.000Z" itemprop="datePublished">2020-07-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/09/%E7%BC%96%E5%86%99C%E5%87%BD%E6%95%B0%E7%9A%84%E6%8A%80%E5%B7%A7/">Lua连续教程之编写C函数的技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Lua中的“数组”就是特殊方式使用的表。像lua-settable和lua-gettable这种用来操作表的通用函数，也可用于操作数组。不过，CAPI为使用整数索引的表的访问和封信提供了专门的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_geti</span> <span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">int</span> key)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_seti</span> <span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">int</span> key)</span>;</span><br></pre></td></tr></table></figure>
<p>Lua5.3之前的版本只提供了这些函数的原始版本，即lua_rawgeti和lua_rawseti。这两个函数类似于lua_geti和lua_seti，但进行的是原始访问。当区别并不明显时，那么原始版本可能会稍微快一点。<br>lua_geti和lua_seti的描述有一点令人困惑，因为其用了两个索引：index表示在栈中的位置，key表示元素在表中的位置。当t为正数时，那么调用lua_geti(L,t,key)等价于如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L,key);</span><br><span class="line">lua_gettable(L,t);</span><br></pre></td></tr></table></figure>
<p>调用lua_seti(L,t,key)等价于如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L,key);</span><br><span class="line">lua_insert(L,<span class="number">-2</span>);</span><br><span class="line">lua_settable(L,t);</span><br></pre></td></tr></table></figure>
<p>作为使用这些函数的具体示例，下面实现了函数map，该函数对数组中的所有元素调用一个指定的函数，然后用词函数返回的结果替换掉对应的数组元素。</p>
<blockquote>
<p>C语言中的函数map</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">l_map</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i , n;</span><br><span class="line">	<span class="comment">/*第一个参数必须是一张表(t) */</span></span><br><span class="line">	luaL_checktype(L,<span class="number">1</span>,LUA_TTABLE);</span><br><span class="line">	<span class="comment">/*第二个参数必须是一个函数(f) */</span></span><br><span class="line">	luaL_checktype(L,<span class="number">2</span>,LUA_TFUNCTION);</span><br><span class="line">	n = luaL_len(L,<span class="number">1</span>);<span class="comment">/*获取表的大小*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;=n; i++)&#123;</span><br><span class="line">		lua_pushvalue(L,<span class="number">2</span>); <span class="comment">/*压入f*/</span></span><br><span class="line">		lua_geti(L,<span class="number">1</span>,i); <span class="comment">/*压入t[i]*/</span></span><br><span class="line">		lua_call(L,<span class="number">1</span>,<span class="number">1</span>); <span class="comment">/*调用f(t[i])*/</span></span><br><span class="line">		lua_seti(L,<span class="number">1</span>,i); <span class="comment">/*t[i] = result */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 没有返回值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例还引入了三个新函数：luaL_checktype、luaL_len和lua_call。<br>函数luaL_checktype确保指定的参数具有指定的类型，否则它会引发一个错误。<br>原始的lua_len类似于长度运算符。由于元方法的存在，该运算符能够返回任意类型的对象，而不仅仅是数字；因此，lua_len会在栈中返回其结果。函数luaL_len会将长度作为整型数返回，如果无法进行强制类型转换则会引发错误。<br>函数lua_call做的是不受保护的调用，该函数类似于lua_pcall，但在发生错误时lua_call会传播错误而不是返回错误码。在一个应用中编写主函数时，不应使用lua_call，因为我们需要捕获所有的错误。不过，编写一个函数时，一般情况下使用lua_call是个不错的注意；如果发生错误，就留给关心错误的人去处理吧。</p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>当C函数接收到一个Lua字符串为参数时，必须遵守两条规则：在使用字符串期间不能从栈中将其弹出，而且不应该修改字符串。<br>当C函数需要创建一个返回给Lua的字符串时，要求则更高。此时，是C语言代码负责缓冲区的分配&#x2F;释放、缓冲区溢出，以及其他对C语言来说比较困难的任务。因此，LuaAPI提供了一些函数来帮助完成这些任务。<br>标准API为两种常用的字符串操作提供了支持，即子串提取和字符串连接。要提取子串，那么基本的操作lua_pushlstring可以获取字符串长度作为额外的参数。因此，如果要把字符串s从i到j（包含）的子串传递给Lua，就必须：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_pushlstring(L,s+i,j-i+1);</span><br></pre></td></tr></table></figure>
<p>举个例子，假设需要编写一个函数，该函数根据指定的分隔符来分隔字符串，并返回一张包含子串的表。例如，调用split(“hi:ho:there”,”:”)应该返回表{“hi”,”ho”,”there”}。下面示例演示了该函数的一种简单实现：</p>
<blockquote>
<p>分隔字符串</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_split</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *sep = luaL_checkstring(L,<span class="number">2</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *e;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	lua_newtable(L); <span class="comment">/*结果表*/</span></span><br><span class="line">	<span class="comment">/* 依次处理每个分隔符*/</span></span><br><span class="line">	<span class="keyword">while</span> ((e = <span class="built_in">strchr</span>(s,*sep)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		lua_pushlstring(L,s,e - s); <span class="comment">/*压入子串*/</span></span><br><span class="line">		lua_rawseti(L,<span class="number">-2</span>,i++); <span class="comment">/* 向表中插入*/</span></span><br><span class="line">		s = e + <span class="number">1</span>; <span class="comment">/*跳过分隔符*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 插入最后一个子串*/</span></span><br><span class="line">	lua_pushstring(L,s);</span><br><span class="line">	lua_rawseti(L,<span class="number">-2</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">/*将结果表返回*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数无须缓冲区，并能处理任意长度的字符串，Lua语言会负责处理所有的内存分配。<br>要连接字符串，Lua提供了一个名为lua_concat的特殊函数，该函数类似于Lua中的连接操作符(..)，它会将数字转换为字符串，并在必要时调用元方法。此外，该函数还能一次连接两个以上的字符串。调用lua_concat(L,n)会连接栈最顶端的n个值，并将结果压入栈。<br>另一个有帮助的函数是lua_pushfstring:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">lua_pushfstring</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数在某种程度上类似于C函数sprintf，它们都会根据格式字符串和额外的参数来创建字符串。然而，与sprintf不同，使用lua_pushfstring时不需要提供缓冲区。不管字符串有多大，Lua都会动态地为我们创建。lua_pushfstring会将结果字符串压入栈中并返回一个指向它的指针，该函数能够接受如下所示字符。</p>
<hr>
<p>%s 						插入一个以\0结尾的字符串<br>%d						插入一个int<br>%f 						插入一个Lua语言的浮点数<br>%p 						插入一个浮点数<br>%I 						插入一个Lua语言的整型数<br>%c 						插入一个以int表示的单字节字符<br>%U						插入一个以int表示的UTF-8字节序列<br>%%						插入一个百分号</p>
<hr>
<p>该函数不能使用诸如宽度或者精度之类的修饰符。<br>当只需要连接几个字符串时，lua_concat和lua_pushfstring都很有用。不过，如果需要连接很多字符串，此时，我们可以用由辅助库提供的缓冲机制。<br>缓冲机制的简单用法只包含两个函数：一个用于在组装字符串时提供任意大小的缓冲区；另一个用于将缓冲区中的内容转换为一个Lua字符串。下面示例用源文件lstrlib.c中string.upper的实现演示了这些函数。</p>
<blockquote>
<p>函数string.upper</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">str_upper</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">size_t</span> l;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	luaL_Buffer b;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s = luaL_checklstring(L,<span class="number">1</span>,&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="type">char</span> *p = luaL_buffinitsize(L,&amp;b,l);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; l; i++)</span><br><span class="line">		p[i] = <span class="built_in">toupper</span>(uchar(s[i]));</span><br><span class="line">	luaL_pushresultsize(&amp;b,l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用辅助库中缓冲区的第一步是声明一个luaL_Buffer类型的变量。第二步是调用luaL_buffinitsize获取一个指向指定大小缓冲区的指针，之后就可以自由地使用该缓冲区来创建字符串了。最后需要调用luaL_pushresultsize将缓冲区中的内容转换为一个新的Lua字符串，并将该字符串压栈。其中，第二步调用时就确定了字符串的最终长度。通常情况下，像我们的示例一样，字符串的最终大小与缓冲区大小相等，但也可能更小。加入我们并不知道返回字符串的准确长度，但知道其最大不超过多少，那么可以操守地为其分配一个较大的空间。<br>请注意，luaL_pushresultsize并未获取Lua状态作为其第一个参数。在初始化之后，缓冲区保存了对Lua状态的引用，因此在调用其他操作缓冲区的函数时无需再传递该状态。<br>加入不知道返回结果大小的上限值，我们还可以通过逐步增加内容的方式来使用辅助库的缓冲区。辅助库提供了一个用于缓冲区中增加内容的函数：luaL_addvalue用于在栈顶增加一个Lua字符串，luaL_addlstring用于增加一个长度明确的字符串，luaL_addstring用于增加一个以\0结尾的字符串，luaL_addchar用于增加一单个字符。这些函数的原型如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void luaL_buffinit   (lua_State *L, luaL_Buffer *B);</span><br><span class="line">void luaL_addvalue   (luaL_Buffer *B);</span><br><span class="line">void lua_addlstring  (luaL_Buffer *B, const <span class="built_in">char</span> *s, size_t l);</span><br><span class="line">void lua_addstring   (luaL_Buffer *B, const <span class="built_in">char</span> *s);</span><br><span class="line">void luaL_addchar	(luaL_Buffer *B, <span class="built_in">char</span> c);</span><br><span class="line">void luaL_pushresult (luaL_Buffer *B);</span><br></pre></td></tr></table></figure>
<p>下面示例通过函数table.concat的一个简化的实现演示了这些函数的使用。</p>
<blockquote>
<p>示例 函数table.concat的一个简化的实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tconcat</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_Buffer b;</span><br><span class="line">	<span class="type">int</span> i , n;</span><br><span class="line">	luaL_checktype(L,<span class="number">1</span>,LUA_TTABLE);</span><br><span class="line">	n = luaL_len(L,<span class="number">1</span>);</span><br><span class="line">	luaL_buffinit(L,&amp;b);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		lua_geti(L,<span class="number">1</span>,i);</span><br><span class="line">		luaL_addvalue(b);</span><br><span class="line">	&#125;</span><br><span class="line">	luaL_pushresult(&amp;b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中，首先调用luaL_buffinti来初始化缓冲区。然后，向缓冲区中逐个增加元素，本例中用的是luaL_addvalue。最后，luaL_pushresult刷新缓冲区并在栈顶留下最终的结果字符串。<br>在使用辅助库的缓冲区时，我们必须注意一个细节。初始化一个缓冲区后，Lua栈可能还会保留某些内部数据。因此，我们不能假设在使用缓冲区之前栈顶仍然停留在最初的位置。此外，尽管使用缓冲区时我们可以将该栈用于其他用途，但在访问栈之前，对栈的压入和弹出次数必须平衡。唯一的例外是luaL_addvalue，该函数会假设要添加到缓冲区的字符串是位于栈顶的。</p>
<h2 id="在C函数中保存状态"><a href="#在C函数中保存状态" class="headerlink" title="在C函数中保存状态"></a>在C函数中保存状态</h2><p>通常情况下，C函数需要保存一些非局部数据，即生存时间超出C函数执行时间的数据。在C语言中，我们通常使用全局变量或静态变量来满足这种需求。然而，当我们为Lua编写库函数时，这并不是一个好办法。首先，我们无法在一个C语言变量中保存普通的Lua值。其次，使用这类变量的库无法用于多个Lua状态。<br>更好的办法是从Lua语言中寻求帮助。Lua函数有两个地方可用于存储非局部数据，即全局变量和非局部变量，而CAPI也提供了两个类似的地方来存储非局部数据，即注册表和上值。</p>
<h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><p>注册表是一张只能被C代码访问的全局表。通常情况下，我们使用注册表来存储多个模块间共享的数据。<br>注册表总是位于伪索引LUA_REGISTRYINDEX中。伪索引就像是一个栈中的索引，但它所关联的值不在栈中。LuaAPI中大多数接受索引作为参数的函数也能将伪索引作为参数，像lua_remove和lua_insert这种操作栈本身的函数除外。例如，要获取注册表中键为”key”的值，可以使用如下的调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_getfield(L,LUA_REGISTRYINDEX,<span class="string">&quot;Key&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注册表是一个普通的Lua表，因此可以使用除nil外的任意Lua值来检索它。不过，由于所有的C语言模块共享的是同一个注册表，为了避免冲突，我们必须谨慎地选择作为键的值。当允许其他独立的库访问我们的数据时，字符串类型的键尤为有用，因为这些库只需知道键的名字就可以了。对于浙西键，选择名字时没有一种可以绝对避免冲突的方法；不过，诸如避免使用常见的名字，以及用库名或类似的东西作为键名的前缀，仍然是好的做法。<br>在注册表中不能使用数值类型的键，因为Lua语言将其用作引用系统的保留字。引用系统由辅助库中的一对函数组成，有了这两个函数，我们在表中存储值时不必担心如何创建唯一的键。函数luaL_ref用于创建新的引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ref = luaL_ref(L,LUA_REGISTRYINDEX);</span><br></pre></td></tr></table></figure>
<p>上述调用会从栈中弹出一个值，然后分配一个新的整型的键，使用这个键将从栈中弹出的值保存到注册表中，最后返回该整型键，而这个键就被称为引用。<br>顾名思义，我们主要是在需要一个C语言结构体中保存一个指向Lua值的引用时使用引用。正如我们之前所看到的，不应该将指向Lua字符串的指针保存在获取该指针的函数之外。此外，Lua语言甚至没有提供指向其他对象的指针。因此，我们无法通过指针来引用Lua对象。当需要这种指针时，我们可以创建一个引用并将其保存在C语言中。<br>要将于引用ref关联的值压入栈中，只要这样写就行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_rawgeti(L,LUA_REGISTRYINDEX,ref);</span><br></pre></td></tr></table></figure>
<p>最后，要释放值和引用，我们可以调用luaL_unref:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luaL_unref(L,LUA_REGISTRYINDEX,ref);</span><br></pre></td></tr></table></figure>
<p>在这句调用后，再次调用luaL_ref会再次返回相同的引用。<br>引用系统将nil视为一种特殊情况。无论何时为一个nil值调用luaL_ref都不会创建新的引用，而是会返回一个常量引用LUA_REFNIL。如下的调用没什么好处：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luaL_unref(L,LUA_REGISTRYINDEX,LUA_REFNIL);</span><br></pre></td></tr></table></figure>
<p>而如下的代码则会像我们期望地一样像栈中压入一个nil：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_rawgeti(L,LUA_REGISTRYINDEX,LUA_REFNIL);</span><br></pre></td></tr></table></figure>
<p>引用系统还定义了一个常量LUA_NOREF，这是一个不同于其他合法引用的整数，它可以用于表示无效的引用。<br>当创建Lua状态时，注册表中有两个预定义的引用：<br>LUA_RIDX_MAINTHREAD<br>指向Lua状态本身，也就是其主线程。<br>LUA_RIDX_GLOBALS<br>指向全局变量。<br>另一种在注册表中创建唯一键的方法是，使用代码中静态变量的地址，C语言的链接编辑器会确保键在所有已加载的库中的唯一性。要使用这种方法，需要用到函数lua_pushlightuserdata，该函数会在栈中压入一个表示C语言指针的值。下面的代码演示了如何使用这种方法在注册表中保存和获取字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*具有唯一地址的变量*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> Key = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="comment">/* 保存字符串*/</span></span><br><span class="line">lua_pushlightuserdata(L,(<span class="type">void</span> *)&amp;Key); <span class="comment">/* 压入地址*/</span></span><br><span class="line">lua_pushstring(L,myStr); <span class="comment">/*压入值*/</span></span><br><span class="line">lua_settable(L,LUA_REGISTRYINDEX); <span class="comment">/* registry[&amp;Key] = myStr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取字符串*/</span></span><br><span class="line">lua_pushlightuserdata(L,(<span class="type">void</span> *)&amp;Key); <span class="comment">/* 压入地址*/</span></span><br><span class="line">lua_gettbale(L,LUA_REGISTRYINDEX); <span class="comment">/* 获取值 */</span></span><br><span class="line">myStr = lua_tostring(L,<span class="number">-1</span>); <span class="comment">/*转换为字符串*/</span></span><br></pre></td></tr></table></figure>
<p>为了简化将变量地址用作唯一键的方法，Lua5.2中引入了两个新函数：lua_rawgetp和lua_rawsetp。这两个函数类似于lua_rawgeti和lua_rawseti，但它们使用C语言指针作为键。使用这两个函数，可以将上面的代码重写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> Key = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="comment">/* 保存字符串 */</span></span><br><span class="line">lua_pushstring(L,myStr);</span><br><span class="line">lua_rawsetp(L,LUA_REGISTRYINDEX,(<span class="type">void</span> *)&amp;Key);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取字符串*/</span></span><br><span class="line">lua_rawgetp(L,LUA_REGISTRYINDEX,(<span class="type">void</span> *)&amp;Key);</span><br><span class="line">myStr = lua_toshtring(L,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>这两个函数都使用了原始访问。由于注册表没有元素，因此原始访问和普通访问相同，而且效率还会稍微高一些。</p>
<h3 id="上值"><a href="#上值" class="headerlink" title="上值"></a>上值</h3><p>注册表提供了全局变量，而上值则实现了一种类似于C语言静态变量的机制。每一次在Lua中创建新的C函数时，都可以将任意数量的上值与这个函数相关联，而每个上值都可以保存一个Lua值。后面在调用该函数时，可以通过伪索引来自由地访问这些上值。<br>我们将这种C函数与其上值的关联称为闭包。C语言闭包类似于Lua语言闭包。 特别的，可以用相同的函数代码来创建不同的闭包，每个闭包可以拥有不同的上值。<br>接下来看一个简单的示例，让我们用C语言创建一个函数newCounter。该函数是一个工厂函数，每次调用都会返回一个新的计数函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = newCounter()</span><br><span class="line">print(c1(),c1(),c1())			-- <span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></span><br><span class="line">c2 = newCounter()</span><br><span class="line">print(c2(),c2(),c2())			-- <span class="number">1</span>	<span class="number">2</span>	<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>尽管所有的计数器都适用相同的C语言代码，但它们各自都保留了独立的计数器。工厂函数的代码形如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">counter</span> <span class="params">(lua_State *L)</span>;  <span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">newCounter</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	lua_pushinteger(L,<span class="number">0</span>);</span><br><span class="line">	lua_pushcclosure(L,&amp;counter,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键函数是lua_pushcclosure，该函数会创建一个新的闭包。lua_pushcclosure的第二个参数是一个基础函数，第三个参数是上值的数量。在创建一个新的闭包前，我们必须将上值的初始值压栈。在此示例中，我们压入了零作为唯一一个上值的初始值。正如我们预想的那样，lua_pushcclosure会将一个新的闭包留在栈中，并将其作为newCounter的返回值。<br>现在，来看一下counter的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">counter</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val = lua_tointeger(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">	lua_pushinteger(L,++val);<span class="comment">/*新值*/</span></span><br><span class="line">	lua_copy(L,<span class="number">-1</span>,lua_upvalueindex(<span class="number">1</span>)); <span class="comment">/*更新上值*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/*返回新值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键是宏lua_upvalueindex,它可以生成上值的伪索引。特别的，表达式lua_upvalueindex(1)给出了正在运行的函数的第一个上值的伪索引，该为索引同其他的栈索引一样，唯一区别的是它不存在与栈中。因此，调用lua_tointeger会以整型返回一个上值的当前值。然后，函数counter将新值++val压栈，并将其复制一份作为新上值的值，再将其返回。<br>接下来是一个更高级的示例，我们将使用上值来实现元组。元组是一种具有匿名字段的常量结构，我们可以用一个数值索引来获取某个特定的字段，或者一次性地获取所有字段。在我们的实现中，将元组表示为函数，元组的值存储在函数的上值中。当使用数值参数来调用该函数时，函数会返回特定的字段。当不使用参数来调用该函数时，则返回所有字段。一下代码演示了元组的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = tuple.new(<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>,&#123;&#125;,<span class="number">3</span>)</span><br><span class="line">print(x(<span class="number">1</span>))			-- <span class="number">10</span></span><br><span class="line">print(x(<span class="number">2</span>))			-- hi</span><br><span class="line">print(x(<span class="number">3</span>))			-- <span class="number">10</span> hi table:ox8087878 <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在C语言中，我们会用同一个函数t_tuple来表示所有的元组，代码参考下示例。</p>
<blockquote>
<p>元组的实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">t_tuple</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	lua_Integer op = luaL_optinteger(L,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (op == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; !lua_isnone(L,lua_upvalueindex(i)); i++)</span><br><span class="line">			lua_pushvalue(L,lua_upvalueindex(i));</span><br><span class="line">		<span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		luaL_argcheck(L,<span class="number">0</span>&lt;op &amp;&amp; op &lt;= <span class="number">256</span>,<span class="number">1</span>,<span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (lua_isnone(L,lua_upvalueindex(op)))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		lua_pushvalue(L,lua_upvalueindex(op));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">t_new</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> top = lua_gettop(L);</span><br><span class="line">	luaL_argcheck(L, top&lt; <span class="number">256</span>, top ,<span class="string">&quot;too many fields&quot;</span>);</span><br><span class="line">	lua_pushcclosure(L,t_tuple,top);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">tuplelib</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,t_new&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_tuple</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newlib(L,tuplelib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于调用元组时既可以使用数字作为参数也可以不用数字作为参数，因此t_tuple使用luaL_optinteger来获取可选参数。该函数类似于luaL_checkinteger,但当参数不存在时不会报错，而是返回指定的默认值。<br>C语言函数中最多可以有255个上值，而lua_upvaluindex的最大索引值是256。因此，我们使用luaL_argcheck来确保这些范围的有效性。<br>当访问一个不存在的上值时，结果是一个类型为LUA_TNONE的伪值。函数t_tuple使用lua_isnone测试指定的上值是否存在。不过，我们永远不应该使用负数或者超过256的索引值来调用lua_upvalueindex，因此必须对用户提供索引进行检查。函数luaL_argcheck可用于检查给定的条件，如果条件不符合，则会引发错误并返回一条友好的错误信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; t = tuple.new(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&gt; t(<span class="number">300</span>)</span><br><span class="line">--&gt; <span class="built_in">stdin</span>:<span class="number">1</span>:bad argument #<span class="number">1</span> to <span class="string">&#x27;t&#x27;</span> (index out of range)</span><br></pre></td></tr></table></figure>
<p>luaL_argcheck的第三个参数表示错误信息的参数编号，第四个参数表示对信息的不出。<br>创建元组的函数t_new很简单，由于其参数已经在栈中，因此该函数先检查字段的数量是否符合闭包中上值个数的限制，然后将所有上值作为参数调用lua_pushcclosure来创建一个t_tuple的闭包。最后，数组tuplelib和函数luaopen_tuple是创建tuple库的标准代码，该库只有一个函数new。</p>
<h3 id="共享的上值"><a href="#共享的上值" class="headerlink" title="共享的上值"></a>共享的上值</h3><p>我们经常需要同一个库的所有函数之间共享某些值或变量，虽然可以用注册表来完成这个任务，但也可以使用上值。<br>与Lua语言的闭包不同，C语言的闭包不能共享上值，每个闭包都有其独立的上值。但是，我们可以设置不同函数的上值指向一张共同的表，这张表就成为了一个共同的环境，函数在其中能够共享数据。<br>Lua语言提供了一个函数，该函数可以简化同一个库中所有函数间共享上值的任务。我们已经使用luaL_newlib打开了C语言库。Lua将这个函数实现为如下的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> luaL_newlib(L,lib) \ (luaL_newlibtable(L,lib),(luaL_setfuncs(L,lib,0))</span></span><br></pre></td></tr></table></figure>
<p>宏luaL_newlibtable只是为库创建了一张新表。然后，函数luaL_setfuncs将列表lib中的函数添加到位于栈顶的新表中。<br>我们这里感兴趣的是luaL_setfuncs的第三个参数，这个参数给出了库中的新函数共享的上值个数。当调用lua_pushcclosure时，这些上值的初始值应该位于栈顶。因此，如果要创建一个库，这个库中的所有函数共享一张表作为它们唯一的上值，则可以使用如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 创建库的表*/</span><br><span class="line">luaL_newlibtable(L,lib);</span><br><span class="line">/* 创建共享上值 */</span><br><span class="line">lua_newtable(L);</span><br><span class="line">/*将表&#x27;lib&#x27;中的函数加入到新库中，将之前的表共享为上值*/</span><br><span class="line">luaL_setfuncs(L,lib,1);</span><br></pre></td></tr></table></figure>
<p>最后一个函数调用从栈中删除了这张共享表，只留下了新库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/09/%E7%BC%96%E5%86%99C%E5%87%BD%E6%95%B0%E7%9A%84%E6%8A%80%E5%B7%A7/" data-id="clw7ne0zf00g24sadhxke6f6v" data-title="Lua连续教程之编写C函数的技巧" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在Lua中调用C语言" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/28/%E5%9C%A8Lua%E4%B8%AD%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80/" class="article-date">
  <time class="dt-published" datetime="2020-06-27T17:00:51.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/28/%E5%9C%A8Lua%E4%B8%AD%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80/">在Lua中调用C语言</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们说用Lua可以调用C语言函数，但这并不意味着Lua可以调用所有的C函数。当C语言调用Lua函数时，该函数必须遵循一个简单的规则来传递参数和获取结果。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>同样，当Lua调用C函数时，这个C函数也必须遵循某种规则来获取参数和返回结果。此外，当Lua调用C函数时，我们必须注册该函数，即必须以一种恰当的方式为Lua提供该C函数的地址。<br>Lua调用C函数时，也使用一个与C语言调用Lua函数时相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。<br>此处的重点在于，这个栈不是一个全局结构；每个函数都有其私有的局部栈。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置。即使一个C函数调用了Lua代码，而且Lua代码又再次调用了同一个C函数，这些调用每一次都只会看到本次调用自己的私有栈，其中索引为1的位置上就是一个参数。</p>
<h2 id="C函数"><a href="#C函数" class="headerlink" title="C函数"></a>C函数</h2><p>先举一个例子，让我们实现一个简化版本的正弦函数，该函数返回某个给定数的正弦值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_sin</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">double</span> d = lua_tonumber(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushnumber(L,<span class="built_in">sin</span>(d));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有在Lua中注册的函数都必须使用一个相同的原型，该原型就是定义在lua.h中的lua_CFunction:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*lua_CFunction)</span><span class="params">(lua_State *L)</span>;</span><br></pre></td></tr></table></figure>
<p>从C语言的角度看，这个函数只有一个指向Lua状态类型的指针作为参数，返回值为一个整型数，代表压入栈中的返回值的个数。因此，该函数在压入结果前无须清空栈。在该函数返回后，Lua会自动保存返回值并清空整个栈。<br>在Lua中，调用这个函数前，还必须通过lua_pushcfunction注册该函数。函数lua_pushcfunction会获取一个指向C函数的指针，然后在Lua中创建一个”function”类型，代表待注册的函数。一旦完成注册，C函数就可以像其他Lua函数一样行事了。<br>一种快速测试函数l_sin的方法是，将其代码放到简单解释器中，并将下列代码添加到luaL_openlibs调用的后面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_pushcfunction(L,l_sin);</span><br><span class="line">lua_setglobal(L,<span class="string">&quot;mysin&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码的第一行压入一个函数类型的值，第二行将这个值赋给全局变量mysin。完成这些修改后，我们就可以在Lua脚本中使用新函数mysin了。<br>要编写一个更专业的正弦函数，必须检查其参数的类型，而辅助库可以帮助我们完成这个任务。函数luaL_checknumber可以检查指定的参数是否为一个数字：如果出现错误，该函数会抛出一个告知性的错误信息；否则，返回这个数字。只需对上面这个正弦函数稍作修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_sin</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">double</span> d = luaL_checknumber(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushnumber(L,<span class="built_in">sin</span>(d));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了上述修改后，如果调用mysin(‘a’)就会出现如下的错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad argument #<span class="number">1</span> to <span class="string">&#x27;mysin&#x27;</span> (number expected, got <span class="built_in">string</span>)</span><br></pre></td></tr></table></figure>
<p>函数luaL_checknumber会自动用参数的编号(#1)、函数名(“mysin”)、期望的参数类型及实际的参数类型来填写错误信息。<br>下面是一个更复杂的示例，编写一个函数返回指定目录下的内容。由于ISO C中没有具备这种功能的函数，因此Lua没有在标准库中提供这样的函数。这里，我们假设使用一个POSIX兼容的操作系统。这个函数以一个目录路径字符串作为参数，返回一个列表，列出该目录下的内容。例如，调用dir(“&#x2F;home&#x2F;lua”)会得到形如{“.”,”..”,”src”,”bin”,”lib”}的表。该函数的完整代码如下：</p>
<blockquote>
<p>一个读取目录的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_dir</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	DIR *dir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path = lual_checkstring(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	dir = opendir(path);</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		lua_pushnil(L);</span><br><span class="line">		lua_pushstring(L,strerror(error));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		lua_newtable(L);</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			lua_pushinteger(L,i++);</span><br><span class="line">			lua_pushstring(L,entry -&gt; d_name);</span><br><span class="line">			lua_settable(L,<span class="number">3</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			closedir(dir);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数先使用与luaL_checknumber类似的函数luaL_checkstring检查目录路径是否为字符串，然后使用函数opendir打开目录。如果无法打开目录，该函数会返回nil以及一条用函数strerror获取的错误信息。在打开目录后，该函数会创建一张新表，然后用目录中的元素填充这张新表。最后，该函数关闭目录并返回1，在C语言中即表示该函数将其栈顶的值返回给了Lua。<br>在某些情况中，l_dir的这种实现可能会造成内存泄露。该函数调用的三个Lua函数均可能由于内存不足而失败。这三个函数中的任意一个执行失败都会引发错误，并中断函数l_dir的执行，进而也就无法调用closedir了。</p>
<h2 id="延续"><a href="#延续" class="headerlink" title="延续"></a>延续</h2><p>通过lua_pcall和lua_call，一个被Lua调用的C函数也可以回调Lua函数。标准库中有一些函数就是这么做的：table.sort调用了排序函数，string.gsub调用了替换函数，pcall和xpcall以保护模式来调用函数。如果你还记得Lua代码本身就是被C代码调用的，那么你应该知道调用顺序类似于：C调用Lua，Lua又调用了C，C又调用了Lua。<br>通常，Lua语言可以处理这种调用顺序；毕竟，与C语言的集成是Lua的一大特点。但是，有一种情况下，这种相互调用会有问题，那就是协程。<br>Lua语言中的每个协程都有自己的栈，其中保存了该协程所挂起调用的信息。具体地说，就是该栈中存储了每一个调用的返回地址、参数及局部变量。对于Lua函数的调用，解释器只需要这个栈即可，我们将其成为软栈。然而，对于C函数的调用，解释器必须使用C语言栈。毕竟，C函数的返回地址是局部变量都位于C语言栈中。<br>对于解释器来说，拥有多个软栈并不难；然而，ISO C的运行时环境却只能拥有一个内部栈。因此，Lua中的协程不能挂起C函数的执行：如果一个C函数位于从resume到对应yield的调用路径中，那么Lua无法保存C函数的状态以便在下次resume时恢复状态。请考虑如下的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.wrap(function()</span><br><span class="line">	<span class="built_in">print</span>(pcall(coroutine.<span class="keyword">yield</span>))</span><br><span class="line">end)</span><br><span class="line">co()</span><br><span class="line"></span><br><span class="line">-- false attempt to <span class="keyword">yield</span> across metamethod/C-call boundary</span><br></pre></td></tr></table></figure>
<p>函数pcall是一个C语言函数；因此，Lua5.1不能将其挂起，因为ISO C无法挂起一个C函数并在之后恢复其运行。<br>在Lua5.2及后续版本中，用延续改善了对这个问题的处理。Lua5.2使用长跳转实现了yield，并使用相同的方式实现了错误信息处理。长跳转简单地丢弃了C语言栈中关于C函数的所有信息，因而无法resume这些函数。但是，一个C函数foo可以指定一个延续函数foo_k，该函数也是一个C函数，在要恢复foo的执行时它就会被调用。也就是说，当解释器发现它应该恢复函数foo的执行时，如果长调转已经丢弃了C语言栈中有关foo的信息，则调用foo_k来替代。<br>为了说得更具体些，我们将pcall的实现作为示例。在Lua5.1中，该函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_pcall</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	luaL_checkany(L,<span class="number">1</span>);</span><br><span class="line">	status = lua_pcall(L,lua_gettop(L) - <span class="number">1</span>, LUA_MULTRET,<span class="number">0</span>);</span><br><span class="line">	lua_pushboolean(L,(status == LUA_OK));</span><br><span class="line">	lua_insert(L,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> lua_gettop(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序正在通过lua_pcall被调用的函数yield，那么后面就不能恢复luaB_pcall的执行。因此，如果我们在保护模式的调用下试图yield时，解释器就会抛出异常。Lua5.3使用基本类似于下面示例中的方式实现了pcall。</p>
<blockquote>
<p>使用延续实现pcall</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">finishpcall</span> <span class="params">(lua_State *L, <span class="type">int</span> status, <span class="type">intptr_t</span> ctx)</span>&#123;</span><br><span class="line">	(<span class="type">void</span>)ctx;</span><br><span class="line">	status = (status != LUA_OK &amp;&amp; status != LUA_YIELD);</span><br><span class="line">	lua_pushboolean (L,(status == <span class="number">0</span> ));</span><br><span class="line">	lua_insert(L,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> lua_gettop(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_pcall</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	luaL_checkany(L,<span class="number">1</span>);</span><br><span class="line">	status = lua_pcall(L,lua_gettop(L) - <span class="number">1</span>, LUA_MULTERT,<span class="number">0</span>,<span class="number">0</span>,finishpcall);</span><br><span class="line">	<span class="keyword">return</span> finsihpcall(L,status,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与Lua5.1中的版本相比，上述实现有三个重要的不同点：首先，新版本用lua_pcallk替换了lua_pcall；其次，新版本在调用完lua_pcallk后把完成的状态传给了新的辅助函数finishpcall；第三，lua_pcallk返回的状态除了LUA_OK或者一个错误外，还可以是LUA_YIELD。<br>如果没有发生yield，那么lua_pcallk的行为与lua_pcall的行为完全一样。但是，如果发生yield，情况则大不相同。如果一个被原来lua_pcall调用的函数想要yield，那么Lua5.3会像Lua5.1版本一样引发错误。但当被新的lua_pcallk调用的函数yield时，则不会出现发生错误：Lua会做一个长跳转并且丢弃C语言栈中有关luaB_pcall的元素，但是会在协程软栈中保存传递给函数lua_pcallk的延续函数的引用。后来，当解释器发现应该返回到luaB_pcall时，它就会调用延续函数。<br>当发生错误时，延续函数finishpcall也可能会被调用。与原来的luaB_pcall不同，finishpcall不能获取lua_pcallk所返回的值。因此，finishpcall通过额外的参数status获取这个结果。当没有错误时，status是LUA_YIELD而不是LUA_OK，因此延续函数可以检查它是如何被调用的。当发生错误时，status还是原来的错误码。<br>除了调用的状态，延续函数还接收一个上下文。lua_pcallk的第5个参数是一个任意的整型数，这个参数被当做延续函数的最后一个参数来传递。这个值允许原来的函数直接向延续函数传递某些任意的信息。<br>Lua5.3的延续体系是一种为了支持yield而设计的精巧机制，但它也不是万能的。某些C函数可能会需要它们的延续传递相当多的上下文。例如，table.sort将C语言栈用于递归，而string.gsub则必须跟踪捕获，还要跟踪和一个用于存放部分结果的缓冲区。虽然这些函数能以”yieldbale”的方式重写，但与增加的复杂性和性能损失相比，这样做似乎并不值得。</p>
<h2 id="C模块"><a href="#C模块" class="headerlink" title="C模块"></a>C模块</h2><p>Lua模块就是一个代码段，其中定义了一些Lua函数并将其存储在恰当的地方。为Lua编写的C语言模块可以模仿这种行为。除了C函数的定义外，C模块还必须定义一个特殊的函数，这个特殊的函数相当于Lua库中的主代码段，用于注册模块中所有的C函数，并将它们存储在恰当的地方。与Lua的主代码段一样，这个函数还应该初始化模块中所有需要初始化的其他东西。<br>Lua通过注册过程感知到C函数。一旦一个C函数用Lua表示和存储，Lua就会通过对其地址的直接引用来调用它。换句话说，一旦一个C函数完成注册，Lua调用它时就不再依赖于其函数名、包的位置以及可见性规则。通常，一个C模块中只有一个用于打开库的公共函数；其他所有的函数都是私有的，在C语言中被声明为static。<br>当我们使用C函数来扩展Lua程序时，将代码设计为一个C模块是个不错的想法。因为即使我们现在只想注册一个函数，但迟早总会需要其他的函数。通常，辅助库为这项工作提供了一个辅助函数。宏luaL_newlib接收一个由C函数及其对应函数名组成的数组，并将这些函数注册到一个新表中。举个例子，假设我们要用之前定义的函数l_dir创建一个库。首先，必须定义这库函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_dir</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	同前</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，声明一个数组，这个数组包含了模块中所有的函数及其名称。数组元素的类型为luaL_Reg，该类型是由两个字段组成的结构体，这两个字段分别是函数名和函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">mylib</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;dir&quot;</span>,l_dir&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，只声明了一个函数。数组的最后一个元素永远是是{NULL,NILL}，并以此标识数组的结尾。最后，我们使用函数luaL_newlib声明一个主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaopen_mylib</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newlib(L,mylib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对函数luaL_newlib的调用会新创建一个表，并使用由数组mylib指定的”函数名-函数指针”填充这个新创建的表。当luaL_newlib返回时，它把这个新创建的表留在栈中，在表中它打开了这个库。然后，函数luaopen_mylib返回1，表示将这个表返回给Lua。<br>编写完这个库以后，我们还必须将其链接到解释器。如果Lua解释器支持动态链接的话，那么最简便的方法是使用动态链接机制。在这种情况下，必须将这个库放到C语言路径中的某个地方。在完成了这些步骤后，就可以使用require在Lua中直接加载这个模块了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local mylib = requrire <span class="string">&quot;mylib&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述的语句会将动态库mylib链接到Lua，查找函数luaopen_mylib，将其注册为一个C语言函数，然后调用它以打开模块。<br>动态链接器必须知道函数luaopen_mylib的名字才能找到它。它总是寻找名为”luaopen + 模块名”这样的函数。因此，如果我们的模块名为mylib，那么该函数应该命名为luaopen_mylib。<br>如果解释器不支持动态链接，就必须连同新库一起重新编译Lua语言。除了重新编译，还需要以某种方式告诉独立解释器，它应该在打开一个新状态时打开这个库。一个简答的做法是把luaopen_mylib添加到由lua_openlibs打开的标住库列表中，这个列表位于文件linit.c中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/28/%E5%9C%A8Lua%E4%B8%AD%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80/" data-id="clw7ne0z300dn4sadhs85963g" data-title="在Lua中调用C语言" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C语言API总览" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/26/C%E8%AF%AD%E8%A8%80API%E6%80%BB%E8%A7%88/" class="article-date">
  <time class="dt-published" datetime="2020-06-26T15:21:06.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/26/C%E8%AF%AD%E8%A8%80API%E6%80%BB%E8%A7%88/">Lua连续教程之C语言API总览</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Lua是一种嵌入式语言，这就意味着Lua并不是一个独立运行的应用，而是一个库，它可以链接到其他应用程序，将Lua的功能融入这些应用。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>因为能够当作库来扩展某个应用程序，所以Lua是一种嵌入式语言。同时，使用了Lua语言的程序也可以在Lua环境中注册新的函数，比如用C语言实现函数，从而增加一些无法直接用Lua语言编写的功能。因此Lua也是一种可扩展的语言。<br>上述两种对Lua语言的定位分别对应C语言和Lua语言之间的两种交互形式。在第一种形式中，C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。在第二种形式中，Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。应用代码和库代码都适用相同的API与Lua语言通信，这些API被称为C API。<br>C API是一个函数、常量和类型组成的集合，有了它，C语言代码就能与Lua语言交互。C API包括读写Lua全局变量的函数、调用Lua函数的函数、运行Lua代码段的函数，以及注册C函数的函数等。通过调用CAPI，C代码几乎可以做Lua代码能够做的所有事情。<br>CAPI遵循C语言的操作模式，与Lua的操作模式由很大的区别。在使用C语言编程时，我们必须注意类型检查、错误恢复、内存分配错误和其他一些复杂的概念。CAPI中的大多数函数都不会检查其参数的正确性，我们必须在调用函数前确保参数的合法性，一旦出错，程序会直接崩溃而不会收到规范的错误信息。此外，CAPI强调的是灵活性和简洁性，某些情况下会以牺牲易用性为代价，即便是常见的需求，也可能需要调用好几个API。这么做虽然有些繁琐，但我们却可以完全控制所有细节。</p>
<h2 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h2><p>首先来学习一个简单的应用程序的例子：一个独立的解释器。</p>
<blockquote>
<p>一个简单地额独立解释器</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	lua_State *L = luaL_newstate();     <span class="comment">/*打开Lua*/</span></span><br><span class="line">	luaL_openlibs(L);				<span class="comment">/*打开标准库*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buff,<span class="keyword">sizeof</span>(buff),<span class="built_in">stdin</span>)!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">		error = luaL_loadstring(L,buff)||lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(error)&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">			lua_pop(L,<span class="number">1</span>);			<span class="comment">/*从栈中弹出错误信息*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头文件lua.h声明了Lua提供的基础函数，其中包括创建新Lua环境的函数、调用Lua函数的函数、读写环境中的全局变量的函数，以及注册供Lua语言调用新函数的函数等等。lua.h中声明的所有内容都有一个前缀lua_。<br>头文件luaxlib.h声明了辅助库所提供的函数，其中所有的声明均以luaL_开头。辅助库使用lua.h提供的基础API来提供更高层次的抽象，特别是对标准库用到的相关机制进行抽象。基础API追求经济性和正交性，而辅助库则追求对常见任务的实用性。当然，要在程序中创建其他所需的抽象也是非常简单的。请记住，辅助库不能访问Lua的内部元素，而只能通过lua.h中声明的官方基础API完成所有工作。辅助库能实现什么，你的程序就能实现什么。<br>Lua标准库没有定义任何C语言全局变量，它将其所有的状态都保存在动态的结构体lua_State中，Lua中的所有函数都接收一个指向该结构的指针作为参数。这种设计使得Lua是可重入的，并且可以直接用于编程多线程代码。<br>顾名思义，函数luaL_newstate用于创建一个新的Lua状态。当它创建一个新状态时，新环境中没有包含预定义的函数，甚至连print也没有。为了保持Lua语言的精炼，所有的标准库都被组织成不同的包，这样我们在不需要使用某些包时可以忽略它们。头文件lualib.h中声明了用于打开这些库的函数。函数luaL_openlibs用于打开所有的标准库。<br>当创建好一个状态并且在其中加载标准库以后，就可以处理用户的输入了。程序会首先调用函数luaL_loadstring来编译用户输入的每一行内容。如果没有错误，则返回零，并向栈中压入编译后得到的函数。然后，程序调用函数lua_pcall从栈中弹出编译后的函数，并以保护模式运行。与函数lua_loadstring类似，如果没有错误发生，函数lua_pcall则返回零；当发生错误时，这两个函数都会向栈中压入一条错误信息。随后我们可以通过函数lua_tostring获取错误信息，并在打印错误信息后使用函数lua_pop将从栈中删除。<br>在C语言中，真是的错误处理可能会相当复杂，并且如何处理错误取决于应用的性质。Lua核不会直接向任何输出流写入数据，它只会通过返回错误信息来提示错误。每个应用可以用其所需的最恰当的方式来处理这些错误信息。为了简化讨论，假设一下示例使用如下简单的错误处理函数，即打印一条错误信息，关闭Lua状态并结束整个应用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error</span> <span class="params">(lua_State *L,<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>&#123;</span><br><span class="line">	va_list argp;</span><br><span class="line">	va_start(argp,fmt);</span><br><span class="line">	<span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>,fmt,argp);</span><br><span class="line">	va_end(argp);</span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Lua既可以作为C代码来编译，也可以作为C++代码来编译，因此lua.h中并没有包含以下这种在C标准库中的常见的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果将Lua作为C代码编译出来后又要在C++中使用，那么可以引入lua.hpp来替代lua.h，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>Lua和C之间通信的主要组件是无处不在的虚拟栈，几乎所有的API调用都是在操作这个栈中的值，Lua与C之间所有的数据交换都是通过这个栈完成的。此外，还可以利用栈保存中间结果。<br>当我们想在Lua和C之间交换数据时，会面对两个问题：第一个问题是动态类型和静态类型体系之间不匹配；第二个问题是自动内存管理和手动内存管理之间不匹配。<br>在Lua中，如果我们写t[k]&#x3D;v，k和v都可以是几种不同类型；由于元表的存在，甚至t也可以有不同的类型。然而，如果要在C语言中提供这种操作，任意给定的settable函数都必须有一个固定的类型。为了实现这样的操作，我们就需要好几十个不同的函数。<br>可以通过在C语言中声明某种联合体类型来解决这个问题，假设这种类型叫lua_Value，它能够表示Lua语言中所有的值，然后，可以把settable声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_settable</span> <span class="params">(lua_Value a,lua_Value k,lua_Value v)</span>;</span><br></pre></td></tr></table></figure>
<p>这种方法有两个缺点。首先，我们很难将如此复杂的类型映射到其他语言中；而在设计Lua时，我们又要求Lua语言不仅能方便地与C&#x2F;C++交互，而且还能与<code>Java</code>、<code>Fortran</code>、<code>C#</code>等其他语言方便地交互。其次，Lua语言会做垃圾收集：由于Lua预压引擎并不知道Lua中的一个表可能会被保存在一个C语言变量中，因此它可能会认为这个表是垃圾并将其收回。<br>因此，LuaAPI中灭有定义任何类似于lua_Value的类型，而是使用栈在Lua和C之间交换数据。栈中的每个元素都能保存Lua中任意类型的值。当我们想要从Lua中获取一个值时，只需要调用Lua，Lua就会将指定的值压入栈中。当想要将一个值传给Lua时，首先要将这个值压入栈，然后调用Lua将其中栈中弹出即可。尽管我们仍然需要一个不同的函数将每种C语言类型的值压入栈，还需要另一个不同函数从栈中弹出每种C语言类型的值，但是避免了过多的组合。另外，由于这个栈是Lua状态的一部分，因此垃圾收集器知道C语言正在使用哪些值。<br>几乎CAPI中的所有函数都会用到栈。正如第一个示例，函数luaL_loadstring将其结果留在栈中；函数lua_pcall从栈中取出要调用的函数，并且也会将错误消息留在栈中。<br>Lua严格地按照LIFO的规则来操作栈。在调用Lua时只有栈顶部的部分会发生改变，而C语言代码则有更大的自由度。更具体地说，C语言可以检视栈中的任何一个元素，甚至可以在栈的任意位置插入或删除元素。</p>
<h3 id="压入元素"><a href="#压入元素" class="headerlink" title="压入元素"></a>压入元素</h3><p>针对每一种能用C语言直接表示的Lua数据类型，CAPI中都有一个对应的亚栈函数：常量nil使用lua_pushnil；布尔值使用lua_pushboolean;双精度浮点数使用lua_pushnumber；整型使用lua_pushinteger；任意字符串使用lua_pushlstring；以\0终止的字符串使用lua_pushstring。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_pushnil</span>         <span class="params">(lua_State *L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushboolean</span>     <span class="params">(lua_State *L, <span class="type">int</span> <span class="type">bool</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushnumber</span>		 <span class="params">(lua_State *L, lua_Number n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushinteger</span>     <span class="params">(lua_State *L, lua_Integer n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushlstring</span>     <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushstring</span>      <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<p>当然，也有向栈中压入C函数和用户数据的函数。<br>类型Lua_Number相当于Lua语言的浮点数类型，默认为double，但可以在编译时配置Lua，让Lua_Number为float甚至long double。类型lua_Integer相当于Lua语言中的整型，通常被定义为long long ，既有符号64位整型。同样，要把Lua语言中的lua_Integer配置为使用int或long也很容易。如果使用float-int组合，也就是32浮点数类型和整型，即我们所说的精简Lua，对于资源受限的机器和硬件而言，相当高效。<br>Lua语言中的额字符串不是以\0结尾的，它们可以包含任意二进制数据。因此，将字符串压栈的基本函数lua_pushlstring需要一个明确的长度作为参数。对于以\0结尾的字符串，也可以使用函数lua_pushstring，该函数通过strlen来计算字符串的长度。Lua语言不会保留指向外部字符串的指针。对于不得不保留的字符串，Lua要么生成一个内部副本，要么复用已有的字符串。因此，一旦上述函数返回，即使立即释放或修改缓冲区也不会出现问题。<br>无论何时向栈内压入一个元素，我们都应该确保栈中有足够的空间。请注意，现在你是一个C语言程序员，Lua语言不会宠着你。当Lua启动时，以及Lua调用C语言时，栈中至少有20个空闲的位置。对于大多数情况，这个空间是完全够用，所以我们一般无须考虑栈空间的问题。不过，有些任务可能会需要更多的栈空间，特备是循环向栈中压入元素时。在这些情况下，就需要调用哈数lua_checkstack来检查栈中是否有足够的空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lua_checkstack (lua_State *L, <span class="built_in">int</span> sz);</span><br></pre></td></tr></table></figure>
<p>这里，sz是我们所需要的额外栈位置的数量。如果可能，函数lua_checkstack会增加栈的大小，以容纳所需的额外空间；否则，该函数返回零。<br>辅助库也提供了一个高层函数来检查栈空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void luaL_checkstack (lua_State *L, <span class="built_in">int</span> sz, const char *msg);</span><br></pre></td></tr></table></figure>
<p>该函数类似于函数lua_checkstack，但是如果栈空间不能满足请求，该函数会使用指定的错误信息抛出异常，而不是返回错误码。</p>
<h3 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h3><p>CAPI使用索引来引用栈中的元素。第一个被压入栈的元素索引为1，第二个被压入的元素索引为2，依次类推。我们还可以以栈顶为参照，使用负数索引来访问栈中的元素，此时，-1表示栈顶元素，-2表示在它之前被压入栈的元素，依次类推。例如，调用lua_tostring(L,-1)会将栈顶的值作为字符串返回。正如你接下来要看到的，有些情况下从栈底对栈进行索引更加自然，而有些情况下则使用负数索引更好。<br>要检查栈中的一个元素是否为特定的类型，CAPI提供了一系列名为lua_is<em>的函数，其中</em>可以是任意一种Lua数据类型。这些函数包括lua_isnil、lua_isnumber、lua_isstring和lua_istable等。所有这些函数都有同样的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lua_is* (lua_State *L, <span class="type">int</span> index);</span><br></pre></td></tr></table></figure>
<p>实际上，函数lua_isnumber不会检查某个值是否为特定类型，而是检查该值是否能被转换为特定类型。函数lua_isstring与之类似，特别之处在于，它接受数字。<br>还有一个函数lua_type，用于返回栈中元素的类型，每一种类型都由一个对应的常量表示，包括LUA_INIT、LUA_TBOOLEAN、LUA_TUMBER、LUA_TSTRING等。还函数一般与switch语句连用。当需要检查字符串和数值是否存在潜在的强制类型转换时，该函数也同样有用。<br>函数lua_to*用于从栈中获取一个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 				<span class="title function_">lua_toboolean</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> 			*<span class="title function_">lua_tolstring</span><span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">size_t</span> *len)</span>;</span><br><span class="line">lua_State           *<span class="title function_">lua_tothread</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line">lua_Number          <span class="title function_">lua_tonumber</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line">lua_Integer         <span class="title function_">lua_tointeger</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<p>即使指定的元素的类型不正确，调用这些函数也不会有问题。函数lua_toboolean适用于所有类型，它可以按照如下的规则将任意Lua值转换为C的布尔值：nil和false转换为0，所有其他的Lua值转换为1.对于类型不正确的值，函数lua_tolstring和lua_tothread返回NULL。不过，数值相关的函数都无法提示数值的类型错误，因此只能简单地返回0。以前我们需要调用函数lua_isnumber来检查类型，但是Lua5.2引入了如下的新函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_Number      lua_tonumberx(lua_State *L, <span class="built_in">int</span> idx, <span class="built_in">int</span> *isnum)</span><br><span class="line">lua_Integer     lua_tointegerx(lua_State *L,<span class="built_in">int</span> idx, <span class="built_in">int</span> *isnum)</span><br></pre></td></tr></table></figure>
<p>出口参数isnum返回了一个布尔值，来表示Lua值是否被强制转换为期望的类型。<br>函数lua_tolstring返回一个指向该字符串内部副本的指针，并将字符串的长度存入到参数len指定的位置。我们无法修改这个内部副本。Lua语言保证，只要对应的字符串还在栈中，那么这个指针就是有效的。当Lua调用的一个C函数返回时，Lua就会清空栈。因此，作为规则，永远不要指向Lua字符串的指针存放到获取该指针的函数之外。<br>函数lua_tolstring返回的所有字符串在其末尾都会有一个额外的\0，不过这些字符串中也可能会有\0，因此可以通过第三个参数len获取字符串的真实长度。特别的，假设栈顶的值是一个字符串，那么如下推断永远成立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s = lua_tolstring(L, <span class="number">-1</span> ,&amp;len); <span class="comment">/*任意Lua字符串*/</span></span><br><span class="line">assert(s[len] == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">assert(<span class="built_in">strlen</span>(s) &lt;= len);</span><br></pre></td></tr></table></figure>
<p>如果不需要长度信息，可以在调用函数lua_tolstring时将第三个参数设为NULL。不过，使用宏lua_tostring会更好，因此这个宏就是用NULL作为第三个参数来调用函数lua_tolstring的。<br>为了掩饰这些函数的用法，示例提供了一个有用的辅助函数，它输出整个栈的内容。</p>
<blockquote>
<p>对栈进行Dump</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void stackDump(lua_State *L)&#123;</span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="built_in">int</span> top = lua_gettop(L); /*栈的深度*/</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;= top;i++)&#123;</span><br><span class="line">		<span class="built_in">int</span> t = lua_type(L,i);</span><br><span class="line">		switch(t)&#123;</span><br><span class="line">			<span class="keyword">case</span> LUA_TSTRING:&#123;</span><br><span class="line">				printf(<span class="string">&quot;&#x27;%s&#x27;&quot;</span>,lua_tostring(L,i));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> LUA_TBOOLEAN:&#123;</span><br><span class="line">				printf(lua_toboolean(L,i)?<span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> LUA_TUNMBER:&#123;</span><br><span class="line">				printf(<span class="string">&quot;%g&quot;</span>,lua_tonumber(L,i));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			default:&#123;</span><br><span class="line">				printf(<span class="string">&quot;%s&quot;</span>,lua_typename(L,t));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数从栈底向栈顶遍历，并根据每个元素的类型打印其值。它打印字符串时会用单引号将其括起来，对数值类型的值则使用格式”%g”输出，对于其他C语言中不存在等价类型的值则只打印出它们的类型。<br>在Lua5.3中，由于整型总是可以被强制转换为浮点型，因此仍然可以用函数lua_tonumber和”%g”的格式打印所有的数值。但是，我们倾向于将整数打印为整型，以避免损失精度。此时，我们可以用新函数lua_isinteger来区分整型和浮点型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LUA_TNUMBER:&#123;</span><br><span class="line">	<span class="keyword">if</span> (lua_isinteger(L,i))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,lua_tointeger(L,i));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%g&quot;</span>,lua_tonumber(L,i));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他栈操作"><a href="#其他栈操作" class="headerlink" title="其他栈操作"></a>其他栈操作</h3><p>除了上述在C语言和栈之间交换数据的函数外CAPI还提供了下列用于通过栈操作的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lua_gettop</span>			<span class="params">(lua_State *L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_settop</span>         <span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushvalue</span>		<span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_rotate</span>			<span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_remove</span>  		<span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_insert</span> 		<span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_replace</span>        <span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_copy</span> 			<span class="params">(lua_State *L, <span class="type">int</span> fromidx,<span class="type">int</span> toidx)</span>;</span><br></pre></td></tr></table></figure>
<p>函数lua_gettop返回栈中元素的个数，也即栈顶元素的索引。函数lua_settop将栈顶设置为一个指定的值，即修改栈中的元素数量。如果之前的栈顶比新设置的更高，那么高出来的这些元素就会被丢弃；反之，该函数会向栈中压入nil来不足大小。特别的，函数lua_settop(L,0)用于清空栈。在调用函数lua_settop时也可以使用负数索引；基于这个功能，CAPI提供了下面的宏，用于从栈中弹出n个元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_pop(L,n)  lua_settop(L,-(n) -1)</span></span><br></pre></td></tr></table></figure>
<p>函数lua_pushvalue用于将指定索引上的元素的副本压入栈。<br>函数lua_rotate是Lua5.3中新引入的。顾名思义，该函数将指定索引的元素向栈顶转动n个位置。若n为整数，表示将元素向栈顶方向转动，而n为负数则表示向相反的方向转动。这是一个非常有用的函数，另外两个CAPI操作实际上是基于使用该函数的宏定义的。其中一个是lua_remove，用于删除指定索引的元素，并将该位置上的所有元素下移以填补空缺，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_remove(L,idx) \ (lua_rotate(L,(idx),-1),lua_pop(L,1))</span></span><br></pre></td></tr></table></figure>
<p>也就是说，该函数会将栈顶转动一格，把想要的那个元素移动到栈顶，然后弹出该元素。另一个宏是lua_insert，用于将栈顶元素移动到指定位置，并上移指定位置之上的所有元素以开辟出一个元素的空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_insert(L,inx)    lua_rotate(L,(idx),1)</span></span><br></pre></td></tr></table></figure>
<p>函数lua_replace弹出一个值，并将栈顶设置为指定索引上的值，而不移动任何元素。最后，函数lua_copy将一个索引上的值复制到另一个索引上，并且原值不受影响。请注意，以下的操作不会对空栈产生影响：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lua_settop(L,<span class="number">-1</span>);<span class="comment">/*将栈顶设为当前值*/</span></span><br><span class="line">lua_insert(L,<span class="number">-1</span>);<span class="comment">/*将栈顶的元素移动到栈顶*/</span></span><br><span class="line">lua_copy(L,x,x);<span class="comment">/*把一个元素复制到它当前的位置*/</span></span><br><span class="line">lua_rotate(L,x,<span class="number">0</span>);<span class="comment">/*旋转零个位置*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例 栈操作示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stackDump</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	参见上面那个示例</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	lua_State *L = luaL_newstate();</span><br><span class="line">	lua_pushboolean(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushnumber(L,<span class="number">10</span>);</span><br><span class="line">	lua_pushnil(L);</span><br><span class="line">	lua_pushstring(L,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	stackDump(L):</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; */</span></span><br><span class="line">	lua_pushvalue(L.<span class="number">-4</span>); stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; true */</span></span><br><span class="line">	lua_replace(L,<span class="number">3</span>); stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; */</span></span><br><span class="line">	lua_settop(L,<span class="number">6</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 true &#x27;hello&#x27; nil nil */</span></span><br><span class="line">	lua_rotate(L,<span class="number">3</span>,<span class="number">1</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil true &#x27;hello&#x27; nil */</span></span><br><span class="line">	lua_remove(L,<span class="number">-3</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; nil*/</span></span><br><span class="line">	lua_settop(L,<span class="number">-5</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true */</span></span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用CAPI进行错误处理"><a href="#使用CAPI进行错误处理" class="headerlink" title="使用CAPI进行错误处理"></a>使用CAPI进行错误处理</h2><p>Lua中所有的结构都是动态的：它们会按需扩展，并且在可能时最后重新收缩。这意味着在Lua中内存分配失败可能无处不在，几乎所有的操作最终都可能会面临内存分配失败。此外，许多操作可能会抛出异常。例如，访问一个全局变量可能会触发__index元方法，而该元方法又可能会抛出异常。最后，分配内存的操作会触发垃圾收集器，而垃圾收集器又可能会调用同样可能抛出异常的析构器。简而言之，Lua API中的绝大部分函数都可能抛出异常。<br>Lua语言使用异常来提示错误，而没有再API的每个操作中使用错误码。与C++或Java不同，C语言没有提供异常处理机制。为了解决这个问题，Lua使用了C语言中的setjmp机制，setjmp营造了一个类似异常处理的机制。因此，大多数API函数都可以跑出异常而不是直接返回。<br>在编写库代码时，由于Lua会捕获所有异常，因此，对我们来说使用longjmp并不是进行额外的操作。不过，在编写应用程序代码时，则必须提供一种捕获异常的方法。</p>
<h3 id="处理应用代码中的错误"><a href="#处理应用代码中的错误" class="headerlink" title="处理应用代码中的错误"></a>处理应用代码中的错误</h3><p>如果应用调用了Lua API中的函数，就可能发生错误。Lua语言通常通过长跳转来提示错误。但是，如果没有相应的setjmp，解释器就无法进行长跳转。此时，API中的任何错误都会导致Lua调用紧急函数，当这个函数返回后，应用就会退出。我们可以通过函数lua_atpanic来设置自己的紧急函数，但作用不大。<br>要正确地处理应用代码中的错误，就必须通过Lua语言调用我们自己的代码，这样Lua语言才能设置适合的上下文来捕获异常，即在setjmp的上下文中运行代码。类似于通过函数pcall在保护模式中运行Lua代码，我们也可以用函数lua_pcall运行C代码。更具体地说，可以把C代码封装到一个函数F中，然后使用lua_pcall调用这个函数F。通过这种方式，我们的C代码会在保护模式下运行。即便发生内存分配失败，函数lua_pcall也会返回一个对应的错误码，是解释器能够保持一致的状态，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	code to run in protected <span class="title function_">mode</span><span class="params">(要以保护模式运行的代码)</span></span><br><span class="line">	<span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">secure_foo</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	lua_pushcfunction(L,foo)<span class="comment">/*将foo作为Lua函数压栈*/</span></span><br><span class="line">	<span class="keyword">return</span> (lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，无论发生什么，调用secure_foo时都会返回一个布尔值，来表示foo执行是否成功。特别的，请注意，栈中已经预先分配了空间，而且函数lua_pushcfunction不会分配内存，这样才不会引发错误。</p>
<h3 id="处理库代码中的错误"><a href="#处理库代码中的错误" class="headerlink" title="处理库代码中的错误"></a>处理库代码中的错误</h3><p>Lua是一种安全的语言。这意味着不管用Lua写什么，也不管写出来的内容多么不正确，我们总能用它自身的机制来理解程序的行为。此外，程序中的错误也是通过Lua语言的机制来检测和解释的。与之相比，许多C语言代码中的错误只能从底层硬件的角度来解释。<br>只要往Lua中加入新的C函数，这种安全性就可能被打破。例如，一个等价于BASIC命令poke的函数就可能导致各种各样的内存崩溃。因此，我们必须确保新加入的内容对Lua语言来说是安全的，并提供妥善的错误处理。<br>正如之前讨论的，C语言程序必须通过lua_pcall设置错误处理。不过，在为lua编写库函数时，通常无须处理错误。库函数抛出的错误要么被Lua中的pcall捕获，要么被应用代码中的lua_pcall捕获。因此，当C语言库中的函数检测到错误时，只需要简单地调用lua_error即可。函数lua_error会收拾Lua系统中的残局，然后跳转回保护模式调用处，并传递错误信息。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Lua语言核心对内存分配不进行任何假设，它既不会调用malloc也不会调用realloc来分配内存。相反，Lua语言核心只会通过一个分配函数来分配和释放内存，当用户创建Lua状态时必须提供该函数。<br>luaL_newstate是一个用默认分配函数来创建Lua状态的辅助函数。该默认分配函数使用了来自C语言标准函数库的标准函数malloc-realloc-free，对于大多数应用程序来说，这几个函数够用了。但是，要完全控制Lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的Lua状态即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_State *<span class="title function_">lua_newstate</span><span class="params">(lua_Alloc f, <span class="type">void</span> *ud)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的Lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。<br>分配函数必须满足lua_Alloc的类型声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> * (*lua_Alloc) (<span class="type">void</span> *ud,</span><br><span class="line">							 <span class="type">void</span> *ptr,</span><br><span class="line">							 <span class="type">size_t</span> osize,</span><br><span class="line">							 <span class="type">size_t</span> nsize);</span><br></pre></td></tr></table></figure>
<p>第一个参数始终为lua_newstate所提供的用户数据；第二个参数是正要被分配或者释放的地址；第三个参数是原始块的大小；最后一个参数是请求的块大小。如果ptr不是NULL，Lua会保证其之前被分配的大小就是osize。<br>Lua语言使用NULL表示大小为零的块。当nsize为零时，分配函数必须释放ptr指向的块并返回NULL，对应于所要求的大小的块。当ptr是NULL时，该函数必须分配并返回一个指定大小的块；如果无法分配指定的块，则必须返回NULL。如果ptr是NULL并且nsize为零，则两条规则都适用：最终结果是分配函数什么都不做，返回NULL。<br>最后，当ptr不是NULL并且nsize不为零时，分配函数应该像realloc一样重新分配块并且返回新地址。同样，当出现错误分配函数必须返回NULL。Lua假定分配函数在块的新尺寸小于或等于旧尺寸时不会失败。<br>luaL_newstate使用的标准分配函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">l_alloc</span> <span class="params">(<span class="type">void</span> *ud , <span class="type">void</span> *ptr, <span class="type">size_t</span> osize, <span class="type">size_t</span> nsize)</span>&#123;</span><br><span class="line">	(<span class="type">void</span>)ud; (<span class="type">void</span>)osie;<span class="comment">/*未使用*/</span></span><br><span class="line">	<span class="keyword">if</span>(nsize == <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">free</span>(ptr);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">realloc</span> (ptr,nsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数假设free(NULL)什么也不做，并且realloc(NULL,size)等价于malloc(size)。IOSC标准会托管这两种行为。<br>我们可以通过调用lua_getallocf恢复Lua状态的内存分配器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_Alloc <span class="title function_">lua_getallocf</span> <span class="params">(lua_State *L, <span class="type">void</span> **ud)</span>;</span><br></pre></td></tr></table></figure>
<p>如果ud不是NULL，那么该函数会把*ud设置为该分配器的用户数据。我们可以通过调用lua_setallocf来更改Lua状态的内存分配器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_setallocf</span> <span class="params">(lua_State *L, Lua_Alloc f, <span class="type">void</span> *ud)</span>;</span><br></pre></td></tr></table></figure>
<p>请记住，所有新的分配函数都有责任释放由前一个分配函数分配的块。通常情况下，新的分配函数是在旧分配函数的基础上做了包装，来追踪或同步访问堆的。<br>Lua在内部不会为了重用而缓存空闲内存。它假定分配函数会完成这种缓存工作；而优秀的分配函数确实也会这么做。Lua不会试图压缩内存碎片。研究表明，内存碎片更多是由糟糕的分配决策导致的，而非程序的行为造成的；而优秀的分配函数不会造成太多内存碎片。<br>对于已有的优秀分配函数，想要做到比它更好是很难的，但有时候也不妨试一试。例如，Lua会告诉你已经释放或者重新分配的块的大小。因此，一个特定的分配函数不需要保存有关块大小的信息，以此减少每个块的内存开销。<br>还有一种可以改善的内存分配的场景，是在多线程系统中。这种系统通常需要对内存分配函数进行线程同步，因为这些函数使用的是全局资源。不过，对Lua状态的访问也必须是同步的——或者更好的情况是，限制只有一个线程能够访问Lua状态。如果每个Lua状态都从私有的内存池中分配内存，那么分配函数就可以避免线程同步导致的额外开销了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/26/C%E8%AF%AD%E8%A8%80API%E6%80%BB%E8%A7%88/" data-id="clw7ne0wu000e4sadengc2koy" data-title="Lua连续教程之C语言API总览" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua使用协程实现多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/07/Lua%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2020-06-07T09:35:20.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/07/Lua%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Lua使用协程实现多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>协程能够实现一种协作式多线程。每个协程都等价于一个线程。一对yield-resume可以将执行权在不同线程之间切换。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>不过，与普通的多线程的不同，协程是非抢占的。当一个协程正在运作时，是无法从外部停止它的。只有当协程显式地要求时它才会挂起执行。对于有些应用而言，这并没有问题，而对于另外一些应用则不行。当不存在抢占时，编程简单得多。由于在程序中所有的线程间同步都是显式的，所以我们无须为线程同步问题抓狂，只需要确保一个协程只在它的临界区之外调用yield即可。</p>
<p>不过，对于非抢占式多线程来说，只要有一个线程调用了阻塞操作，整个程序在该操作完成前都会阻塞。对于很多应用来说，这种行为是无法接受的，而这也正是导致许多程序员不把协程看作传统多线程的一种实现的原因。<br>让我们假设一个典型的多线程的场景：我们希望通过HTTP下载多个远程文件。为了下载多个远程文件，我们必须先知道如何下载一个远程文件。要下载一个文件，必须先打开一个到对应站点的连接，然后发送下载文件的请求，接收文件，最后关闭连接。在Lua语言中，可以按以下步骤来完成这项任务。首先，加载LuaSocket库：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> socket = <span class="built_in">require</span> <span class="string">&quot;socket&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后，定义主机和要下载的文件。在本例中，我们从Lua语言官网下载Lua5.3手册：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">&quot;www.lua.org&quot;</span></span><br><span class="line">file = <span class="string">&quot;/manual/5.3/manual.html&quot;</span></span><br></pre></td></tr></table></figure>
<p>接下来，打开一个TCP连接，连接到站点的80端口：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">assert</span>(socket.connect(host,<span class="number">80</span>))</span><br></pre></td></tr></table></figure>
<p>这步操作返回一个连接对象，可以用它来发送下载文件的请求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> request = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;GET %s HTTP/1.0\r\nhost: %s\r\n\r\n&quot;</span>,file,host)</span><br><span class="line">c:send(request)</span><br></pre></td></tr></table></figure>
<p>接下来，以1KB为一块读取文件，并将每块写入到标准输出中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">	<span class="keyword">local</span> s ,<span class="built_in">status</span>,partial = c:receive(<span class="number">2</span>^<span class="number">10</span>)</span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(s <span class="keyword">or</span> partial)</span><br><span class="line"><span class="keyword">until</span> <span class="built_in">status</span> == <span class="string">&quot;closed&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数receive要么返回它读取到的字符串，要么在发生错误时返回nil外加错误码及出错前读取到的内容。当主机关闭连接时，把输入流中剩余的内容打印出来，然后退出接收循环。<br>下载完文件后，关闭连接：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>既然我们知道了如何下载一个文件，那么再回到下载多个文件的问题上。最简单的做法是逐个地下载文件。不过，这种串行的做法太慢了，它只能在下载完一个文件后再下载一个文件。当读取一个远程文件时，程序把大部分的时间耗费在了等待数据到达上。更确切地说，程序将时间耗费在了对receive的阻塞调用上。因此，如果一个程序能够同时并行下载所有文件的话，就会快很多。当一个连接没有可用数据时，程序便可以从其他连接读取数据。很明显，协程为构造这种并发下载的代码结构提供了一种简单的方式。我们可以为每个下载任务创建一个新线程，当一个线程无可用数据时，它就可以将控制权传递给一个简单的调度器，这个调度器再去调用其他的线程。<br>在用协程重写程序前，我们先把之前下载的代码重写成一个函数。</p>
<blockquote>
<p>示例 下载Web页面的数据</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span> <span class="params">(host,file)</span></span></span><br><span class="line">	<span class="keyword">local</span> c = <span class="built_in">assert</span>(socket.connect(host,<span class="number">80</span>))</span><br><span class="line">	<span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">local</span> request = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;GET %s HTTP/1.0\r\nhost:%s\r\n\r\n&quot;</span>,file,host)</span><br><span class="line">	c:send(request)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> s ,<span class="built_in">status</span> = receive(c)</span><br><span class="line">		count = count + #s</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">status</span> == <span class="string">&quot;closed&quot;</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	c:<span class="built_in">close</span>()</span><br><span class="line">	<span class="built_in">print</span>(file,count)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于我们对远程文件的内容并不感兴趣，所以不需要将文件内容写入到标准输出中，只要计算并输出文件大小即可。<br>在新版本中，我们使用一个辅助函数receiver从连接接收数据。在串行的下载方式中，receive的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(connection)</span></span></span><br><span class="line">	<span class="keyword">local</span> s,<span class="built_in">status</span>,partial = connection:receive(<span class="number">2</span>^<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">return</span> s <span class="keyword">or</span> partial,<span class="built_in">status</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在并行的实现中，这个函数在接收数据时不能阻塞。因此，在没有足够的可用数据时，该函数会挂起，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(connection)</span></span></span><br><span class="line">	connection:settimeout(<span class="number">0</span>) <span class="comment">--不阻塞 </span></span><br><span class="line">	<span class="keyword">local</span> s ,<span class="built_in">status</span>,partial = connection:receive(<span class="number">2</span>^<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">status</span> == <span class="string">&quot;timeout&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(connection)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> s <span class="keyword">or</span> partial,<span class="built_in">status</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用settimeout(0)是的后续所有对连接进行的操作不会则塞。如果返回状态为”timeout”，就表示该操作在返回时还未完成。此时，线程就会挂起。传递给yield的非假参数通知调度器线程仍在执行任务中。请注意，即使在超时的情况下，连接也会返回超时前已读取到的内容，也就是变量partial中的内容。</p>
<blockquote>
<p>示例 调度器</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">tasks = &#123;&#125;			<span class="comment">-- 所有活跃任务的列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span> <span class="params">(host,file)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		download(host,file)</span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(tasks,co)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> <span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> tasks[i] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">if</span> tasks[<span class="number">1</span>] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			i = <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">local</span> res = tasks[i]()</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">table</span>.<span class="built_in">remove</span>(tasks,i)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在tasks为调度器保存着所有正在运行中的线程的列表。函数get保证每个下载任务运行在一个独立的线程中。调度器本身主要就是一个循环，它遍历所有的线程，逐个唤醒它们。调度器还必须在线程完成任务后，将该线程从列表中删除。在所有线程都完成运行后，调度器停止循环。<br>最后，主程序创建所有需要的线程并调起调度器。例如，如果要从Lua官网下载几个发行包，主程序可能如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.3.2.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.3.1.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.3.0.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.2.4.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.2.3.tar.gz&quot;</span>)</span><br><span class="line">dispatch()</span><br></pre></td></tr></table></figure>
<p>在笔者的机器上，串行实现花了15秒下载到这些文件，而协程实现比串行实现快了三倍多。<br>尽管速度提高了，但最后一种实现还有很大的优化空间。当至少由一个线程有数据可读取时不会有问题；然而，如果所有的线程都没有数据可读，调度程序就会陷入忙等待，不断地从一个线程切换到另一个线程来检查是否有数据可读。这样，会导致协程版的实现比串行版实现耗费多达3倍的CPU时间。<br>为了避免这样的情况，可以使用LuaSocket中的函数select，该函数允许程序阻塞直到一组套接字的状态发生改变。要实现这种改动，只需要修改调度器即可。</p>
<blockquote>
<p>示例 使用select的调度器</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line">	<span class="keyword">local</span> timedout = &#123;&#125;</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> tasks[i] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">if</span> tasks[<span class="number">1</span>] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			i = <span class="number">1</span></span><br><span class="line">			timedout =&#123;&#125;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">local</span> res = tasks[i]()</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">table</span>.<span class="built_in">remove</span>(tasks,i)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">			timeout[#timedout + <span class="number">1</span>] = res</span><br><span class="line">			<span class="keyword">if</span> #timedout == #tasks <span class="keyword">then</span></span><br><span class="line">				socket.<span class="built_in">select</span>(timedout)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在循环中，新的调度器将所有超时的连接收集到表timedout中。请记住，函数receive将这种超时的连接传递给yield，然后由resume返回。如果所有的连接均超时，那么调度器调用select等待这些连接的状态就会发生改变。这个最终的实现与上一个使用协程的实现一样快。另外，由于它不会有忙等待，所以与串行实现耗费的CPU资源一样多。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/07/Lua%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="clw7ne0x6001v4sad5foohgbu" data-title="Lua使用协程实现多线程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua反射" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/26/Lua%E5%8F%8D%E5%B0%84/" class="article-date">
  <time class="dt-published" datetime="2020-05-26T07:17:09.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/26/Lua%E5%8F%8D%E5%B0%84/">Lua连续教程之Lua反射</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>反射是程序用来检查和修改其自身某些部分的能力。像Lua语言这样的动态语言支持几种反射机制：环境允许运行时观察全局变量；</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>诸如type和pairs这样的函数允许运行时检查和遍历未知数据结构；诸如load和require这样的函数允许程序在自身中追加代码或更新代码。不过，还有很多方面仍然是缺失的：程序不能检查局部变量，开发人员不能跟踪代码的执行，函数也不知道是被谁调用的，等等。调试库填补了上述缺陷。<br>调试库是由两类函数组成：自省函数和钩子。自省函数允许我们检查一个正在运行中的程序的几个方面，例如活动函数的额栈、当前正在执行的代码行、局部变量的名称和值。钩子则允许我们跟踪一个程序的执行。<br>虽然名字里带有”调试“的字眼，但调试库提供的并不是Lua语言的调试器。不过，调试库提供了编写我们自己的调试器所需要的不同层次的所有底层机制。<br>调试库与其他库不同，必须被慎重地使用。首先，调试库中的某些功能的性能不高。其次，调试库会打破语言的一些固有规则，例如不能从一个局部变量的词法定界范围外访问这个局部变量。虽然调试库作为标准库直接可用，但笔者建议在使用调试库的代码段中显示地加载调试库。</p>
<h2 id="自省机制"><a href="#自省机制" class="headerlink" title="自省机制"></a>自省机制</h2><p>调试库中主要的自省函数是getinfo，该函数的第一个参数可以是一个函数或一个栈层次。当为某个函数foo调用debug.getinfo(foo)时，该函数会返回一个包含与该函数有关的一些数据的表。这个表可能具有以下字段：<br>  <strong>source:</strong>  该字段用于说明函数定义的位置。如果函数定义在一个字符串中（通过调用load），那么source就是这个字符串；如果函数定义在一个文件中，那么source就是使用@作为前缀的文件名。<br> <strong>short_src:</strong> 该字段是source的精简版本，对于错误信息十分有用。<br> <strong>linedefined:</strong> 该字段是该函数定义在源代码中第一行的行号。<br>  <strong>lastlinedefined:</strong> 该字段是该函数定义在源代码中最后一行的行号。<br> <strong>what:</strong> 该字段用于说明函数的类型。如果foo是一个普通的Lua函数，则为“Lua”；如果是一个C函数，则为“C”;如果是一个Lua语言代码段的主要部分，则为“main”。<br> <strong>name:</strong> 该字段是该函数的一个适当的名称，例如保存该函数的全局变量的名称。<br> <strong>namewhat:</strong> 该字段用于说明上一个子弹的含义，可能是”global”、”local”、”method”、”filed”或””(空字符串)。空字符串表示Lua原因找不到该函数的名称。<br> <strong>nups:</strong> 该字段是该函数的上值的个数。<br> <strong>nparams:</strong> 该字段是该函数的参数个数。<br> <strong>isvararg:</strong> 该字段表明该函数是否为可变长参数函数。<br> <strong>activelines:</strong> 该字段是一个包含该函数所有活跃行的集合。活跃行时指除空行和只包含注释的外行的其他行。<br> <strong>func:</strong> 该字段是该函数本身。<br> 当foo是一个C函数时，Lua语言没有多少关于该函数的信息。对于这种函数，只有字段what、name、namewhat、nups和func是有意义的。<br>当使用给一个数字n作为参数调用函数debug.getinfo(n)时，可以得到有关相应栈层次上活跃函数的数据。栈层次是一个数字，代表某个时刻上活跃的特定函数。调用getinfo的函数A的层次是1，而调用A的函数的层次是2，以此类推。如果n大于栈中活跃函数的数量，那么函数debug.getinfo返回nil。当通过带有栈层次的debug.getinfo查询一个活跃函数时，返回的表中海油两个额外字段：currentline，表示当前该函数正在执行的代码所在的行；istailcall，如果为真则表示函数是被尾调用所调起。<br>字段name有些特殊。请注意，由于函数在Lua语言中是第一类值，因此函数既可以没有名称也可以有多个名称。Lua语言会通过检查调用该函数的代码来看函数是如何被调用的，进而尝试找到该函数的名称。这种方法只有在以一个数字为参数调用getinfo时才会起作用，即我们只能获取关于某一具体调用的信息。<br>函数getinfo的效率不高。Lua语言以一种不影响程序执行的形式来保存调试信息，至于获取这些调试信息的效率则是次要的。为了实现更好的性能，函数getinfo有一个可选的第二参数，该参数用于指定希望获取哪些信息。通过这个参数，函数getinfo就不会浪费时间去收集用户不需要的数据。这个参数是一个字符串，其中每个字母代表选择一组字段，如下表所示：</p>
<hr>
<p>n 选择name和namewhat<br>f 选择func<br>S 选择source、short_src、what、linedefined和lastlinedefined<br>l 选择currentline<br>L 选择activelines<br>u 选择nup、nparams和isvararg</p>
<hr>
<p>下面这个函数演示了函数debug.getinfo的用法，它打印出了活跃栈的栈回溯：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="built_in">traceback</span>()</span><br><span class="line">	<span class="keyword">for</span> level = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level,<span class="string">&quot;Sl&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span> back <span class="keyword">end</span></span><br><span class="line">		<span class="keyword">if</span> info.what == <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d\tC function&quot;</span>,level))</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d\t[%s]:%d&quot;</span>,level,</span><br><span class="line">				info.short_src, info.currentline))</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>要改进这个函数并不难，只需要让函数getinfo返回更多数据即可。实事上，调试库也提供了这样一个改进版本，即函数traceback。与我们的版本不同的是，函数debug.traceback不会打印结果，而是返回一个包含栈回溯的字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>())</span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">	<span class="built_in">stdin</span>:<span class="number">1</span>:<span class="keyword">in</span> main chunk</span><br><span class="line">	[C]:<span class="keyword">in</span> ?</span><br></pre></td></tr></table></figure>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们可以通过函数debug.getlocal来检查任意活跃函数的局部变量。该函数有两个参数，一个是要查询函数的栈层次，另一个是变量的索引。该函数返回两个值，变量名和变量的当前值。如果变量索引大于活跃变量的数量，那么函数getlocal返回nil。如果栈层次无效，则会抛出异常。<br>Lua语言按局部变量在函数中的出现顺序对它们进行编号，但编号只限于在函数当前作用域中活跃的变量。例如，考虑如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> x </span><br><span class="line">	<span class="keyword">do</span> <span class="keyword">local</span> c = a - b <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> name ,value = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(<span class="number">1</span>,a)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="built_in">print</span>(name , value)</span><br><span class="line">		a = a + <span class="number">1</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用foo(10,20)会输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a	<span class="number">10</span></span><br><span class="line">b 	<span class="number">20</span></span><br><span class="line">x 	<span class="literal">nil</span></span><br><span class="line">a 	<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>索引为1的变量a，索引为2的变量b，索引为3的变量是x，索引为4的变量时内层的a。在getlocal被调用的时候，c已经完成了作用域，而name和value还未出现于作用域。<br>从Lua5.2开始，值为负的索引获取可变长参数函数的额外参数，索引-1指向第一个额外参数。此时，变量的名称永远是”(*vararg)”。<br>我们还可以通过函数debug.setlocal改变局部变量的值，该函数的前两个参数与getlocal相同，分别是栈层次和变量索引，而第三个参数是该局部变量的新值。该函数的返回值是变量名，如果变量索引超出了范围则返回nil。</p>
<h3 id="访问非局部变量"><a href="#访问非局部变量" class="headerlink" title="访问非局部变量"></a>访问非局部变量</h3><p>测试库还提供了函数getupvalue，该函数允许我们访问一个被Lua函数所使用的非局部变量。与局部变量不同，被一个函数所引用的非局部变量即使在引用它的函数已经不活跃的情况下也会一直存在。因此，函数getupvalue的第一个参数不是栈层次，而是一个函数。函数getupvalue的第二个参数是变量索引，Lua语言按照函数引用非局部变量的顺序对它们编号，但由于一个函数不能用同一个名称访问两个非局部变量，所以这个顺序是无关紧要的。<br>我们还可以通过函数debug.setupvalue更新非局部变量的值。就像读者可能预想的一样，该函数有三个参数：一个闭包、一个变量索引和一个新值。与函数setlocal一样，该函数返回变量名，如果索引超出范围则返回nil。</p>
<blockquote>
<p>示例 获取变量的值</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getvarvalue</span><span class="params">(name,level,isenv)</span></span></span><br><span class="line">	<span class="keyword">local</span> value</span><br><span class="line">	<span class="keyword">local</span> found = <span class="literal">false</span></span><br><span class="line">	level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">	<span class="comment">--尝试局部变量</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> , <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">		lcoal n, v = <span class="built_in">debug</span>,<span class="built_in">getlocal</span> (level,i)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">			value = v</span><br><span class="line">			found = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;local&quot;</span>, value <span class="keyword">end</span></span><br><span class="line">	<span class="comment">--尝试非局部变量</span></span><br><span class="line">	<span class="keyword">local</span> fun = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level,<span class="string">&quot;f&quot;</span>).func</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> n,v = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(func,i)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="keyword">if</span> n == name <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;upvalue&quot;</span>, v <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">if</span> isenv <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span> <span class="keyword">end</span>	<span class="comment">--避免循环</span></span><br><span class="line">	<span class="comment">--没找到；从环境中获取值</span></span><br><span class="line">	<span class="keyword">local</span> _, env = getvarvalue(<span class="string">&quot;_ENV&quot;</span>,level,<span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> env <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;global&quot;</span> , env[name]</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>用法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">local</span> a = <span class="number">4</span>; <span class="built_in">print</span>(getvarvalue(<span class="string">&quot;a&quot;</span>))		<span class="comment">-- local 4</span></span><br><span class="line">&gt; a = <span class="string">&quot;xx&quot;</span>;<span class="built_in">print</span>(getvarvalue(<span class="string">&quot;a&quot;</span>))			<span class="comment">-- global xx</span></span><br></pre></td></tr></table></figure>
<p>参数level指明在那个栈层次中寻找函数，1意味着直接的调用者。代码中多加1将层次纠正为包括getvarvalue自己。<br>该函数首先查找局部变量。如果有多个局部变量的名称与给定的名称相同，则获取具有最大索引的那个局部变量。因此，函数必须执行完整个循环。如果找不到指定名称的局部变量，那么就查找非局部变量。为了遍历非局部变量，该函数使用debug.getinfo函数获取调用闭包，然后遍历非局部变量。最后，如果还是找不到指定名字的非局部变量，就检索全局变量：该函数递归地调用自己来访问合适的_ENV变量并在相应环境中查找指定的名字。<br>参数isenv避免了一个诡异的问题。该参数用于说明我们是否处于一个从_ENV变量中查询全局名称的递归调用中。一个不使用全局变量的函数可能没有上值_ENV。在这种情况下，如果我们试图把_ENV当做全局变量来查询，那么由于我们需要_ENV来得到其自身的值，所以可能会陷入无限递归循环。因此，当isenv为真且函数getvarvalue找不到局部变量或上值时，getvarvalue就不应该再尝试全局变量。</p>
<h3 id="访问其他协程"><a href="#访问其他协程" class="headerlink" title="访问其他协程"></a>访问其他协程</h3><p>调试库中的所有自省函数都能够接受一个可选的协程作为第一个参数，这样就可以从外部来检查这个协程。例如，考虑使用如下的示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> x = <span class="number">10</span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">	<span class="built_in">error</span>(<span class="string">&quot;some error&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>(co))</span><br></pre></td></tr></table></figure>
<p>对函数traceback的调用作用在协程co上，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack traceback:</span><br><span class="line">	[C]:in function &#x27;yield&#x27;</span><br><span class="line">	temp:3:in function &lt;temp:1&gt;</span><br></pre></td></tr></table></figure>
<p>由于协程和主程序运行在不同的栈上，所以回溯没有跟踪到对函数resume的调用。<br>当协程引发错误时并不会进行栈展开，这就意味着可以在错误发生后检查错误。继续上面的示例，如果再次唤醒协程，它会提示引起了一个错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))		<span class="comment">-- false temp:4:some error</span></span><br></pre></td></tr></table></figure>
<p>现在，如果输出栈回溯，会得到这样的结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">	[C]:<span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &#x27;<span class="title">error</span>&#x27;</span></span><br><span class="line"><span class="function">	<span class="title">temp</span>:4:<span class="title">in</span> <span class="title">function</span> &lt;<span class="title">temp</span>:1&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使在错误发生后，也可以检查协程中的局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">getlocal</span>(co,<span class="number">1</span>,<span class="number">1</span>))		<span class="comment">-- x 10</span></span><br></pre></td></tr></table></figure>

<h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><p>调试库中的钩子机制允许用户注册一个钩子函数，这个钩子函数会在程序运行中某个特定事件发生时被调用。有四种时间能够触发一个钩子：</p>
<ul>
<li>每当调用一个函数时产生的call事件；</li>
<li>每当函数返回时产生的return事件；</li>
<li>每当开始执行一行新代码时产生的line事件；</li>
<li>执行完制定数量的指令后产生的count事件。<br>Lua语言用给一个描述导致钩子函数被调用的事件的字符串为参数来调用钩子函数，包括”call”、”return”、”line”或”count”。对于line事件来说，还有第二个参数，即新行号。我们可以在钩子函数内部调用函数debug.getinfo来获取更多的信息。<br>要注册一个钩子，需要用两个或三个参数来调用函数debug.sethook:第一个参数是钩子函数，第二个参数是描述要监控事件的掩码字符串，第三个参数是一个用于描述以何种频度获取count事件的可选数字。如果要监控call、return和line事件，那么需要把这几个事件的首字母放入掩码字符串。如果要监控count事件，则只需要在第三个参数中指定一个计数器。如果要关闭钩子，只需不带任何参数第调用函数sethook即可。<br>作为一个简单的示例，以下代码安装了一个简单的跟踪器，它会输出解释器执行的每一行代码：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(<span class="built_in">print</span>,<span class="string">&quot;l&quot;</span>)</span><br></pre></td></tr></table></figure>
这句调用只是简单地把函数print安装为一个钩子函数，并告诉Lua语言在line事件发生时调用它。一个更精巧的跟踪器可以使用函数getinfo获取当前文件名并添加到输出中：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span><span class="params">(event,line)</span></span></span><br><span class="line">	<span class="keyword">local</span> s = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>).short_src</span><br><span class="line">	<span class="built_in">print</span>(s .. <span class="string">&quot;:&quot;</span> .. line)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(trace,<span class="string">&quot;l&quot;</span>)</span><br></pre></td></tr></table></figure>
与钩子一起被使用的一个很有用的函数debug.debug。这个简单的函数可以提供一个能够执行任意Lua语言命令的提示符，其等价于如下的代码：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debug1</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;debug&gt; &quot;</span>)</span><br><span class="line">		<span class="keyword">local</span> line = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;cont&quot;</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="built_in">assert</span>(<span class="built_in">load</span>(line))()</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
当用户输入”命令“cont时，函数返回。这种标准的实现十分简单，并且在全局环境中运行命令，位于正在被调试代码的定界范围之外。</li>
</ul>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>除了调试，反射的另外一个常见用法是用于调优，即程序使用资源的行为分析。对于时间相关的调优，最好使用C接口，因为每次钩子调用函数开销太大从而可能导致测试结果无效。不过，对于计数性质的调优，Lua代码就可以做得很好。<br>性能调优工具的主要数据结构是两个表，其中一个表将函数和它们的调用计数关联起来，另一个表关联函数和函数名。这两个表的索引都是函数自身：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Counters = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> Names = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在性能分析完成后再获取函数的名称，但是如果能在一个函数F处于活动状态时获取其名称可能会得到更好的结果。这是因为，在函数F处于活动状态时，Lua语言可以通过分析正在调用函数F的代码来找出函数F的名称。<br>现在，我们定义一个钩子函数，该钩子函数的任务是获取当前正在被调用的函数，并递增相应的计数器，再收集函数名。</p>
<blockquote>
<p>示例 用于计算调用次数的钩子</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> f = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;f&quot;</span>).func </span><br><span class="line">	<span class="keyword">local</span> count = Counters[f]</span><br><span class="line">	<span class="keyword">if</span> count == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">		Counters[f] = <span class="number">1</span></span><br><span class="line">		Names[f] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;Sn&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		Counters[f] = count + <span class="number">1</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>接下来，运行带有钩子的程序。假设我们要分析的程序位于一个文件中，且用户通过参数把该文件名传递个性能分析器，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% lua profile main-prog</span><br></pre></td></tr></table></figure>
<p>这样，性能分析器就可以从arg[1]中得到文件名、设置钩子并运行文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(<span class="built_in">arg</span>[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook,<span class="string">&quot;c&quot;</span>)</span><br><span class="line">f()</span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>()</span><br></pre></td></tr></table></figure>
<p>最后一步是显示结果。</p>
<blockquote>
<p>示例  获取一个函数的函数名</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getname</span> <span class="params">(func)</span></span></span><br><span class="line">	<span class="keyword">local</span> n = Names[func]</span><br><span class="line">	<span class="keyword">if</span> n.what == <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> n.name </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> lc = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;[%s]:%d&quot;</span>,n.short_src, n.linedefined)</span><br><span class="line">	<span class="keyword">if</span> n.what ~= <span class="string">&quot;main&quot;</span> <span class="keyword">and</span> n.namewhat ~= <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)&quot;</span>,lc, n.name)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> lc</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有Lua语言中的函数名不是特别确定，所以我们给每个函数再加上位置信息，以file:file这样的形式给出。如果一个函数没有名称，那么就只使用它的位置。如果函数是C函数，那么就只使用它的名称（因为没有位置）。在上述函数定义后，我们输出每个函数及其计数器的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> func,count <span class="keyword">in</span> <span class="built_in">pairs</span>(Counters) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(getname(func),count)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><p>由于Lua语言通过库函数完成所有与外部世界的通信，因此一旦移除了这些函数也就排除了一个脚本能够影响外部环境的可能。不过尽管如此，我们仍然可能会被消耗大量CPU时间或内存的脚本进行拒绝服务Dos攻击。反射，以调试钩子的形式，提供了一种避免这种攻击的有趣方式。<br>首先，我们使用count时间钩子来限制一段代码能够执行的指令数。</p>
<blockquote>
<p>示例  一个使用钩子的简单沙盒</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">local</span> steplimit = <span class="number">1000</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setp</span><span class="params">()</span></span></span><br><span class="line">	count = count + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; steplimit <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;script uses too much CPU&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(<span class="built_in">arg</span>[<span class="number">1</span>],<span class="string">&quot;t&quot;</span>,&#123;&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(step,<span class="string">&quot;&quot;</span>,<span class="number">100</span>)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>这个程序加载了指定的文件，设置了钩子，然后运行文件。该程序把钩子设置为监听count事件，使得Lua语言每执行100条执行就调用一次钩子函数。钩子只是递增一个计数器，然后检查其是否超过了某个固定的限制。这样做之后还会有问题么？<br>当然有问题。我们还必须限制所加载的代码段的大小：一段很长的代码只要被加载就可能消耗尽内存。另一个问题是，程序可以通过少量指令消耗大量的内存。例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="string">&quot;123456789012345&quot;</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">36</span> <span class="keyword">do</span> s = s .. s <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述的几行代码用不到150行的指令就试图创建一个1字节的字符串。显然，单纯限制指令数量和程序大小是不够的。<br>一种改进是检查和限制函数step使用的内存。</p>
<blockquote>
<p>示例  控制内存使用</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最大能够使用的内存（单位 KB）</span></span><br><span class="line"><span class="keyword">local</span> memlimit = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最大能够执行的&quot;steps&quot;</span></span><br><span class="line"><span class="keyword">local</span> steplimit = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">checkmem</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>) &gt; memlimit <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;script uses too much memory&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">step</span><span class="params">()</span></span></span><br><span class="line">	checkmem()</span><br><span class="line">	count = count + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; steplimit <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;script uses too much CPU&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于通过少量指令就可以消耗很多内存，所以我们应该设置一个很低的限制或以很小的步进来调用钩子函数。更具体地说，一个程序用40行以内的指令就能把一个字符串的大小增加上千倍。因此，我们要么以比40条指令更高的频率调用钩子，要么把内存限制设为我们能够承受的最大值的一千分之一。<br>一个微妙的问题是字符串标准库。我们可以对字符串调用该库中的所有函数。因此，即使环境中没有这些函数，我们也可以调用它们：字符串常量把它们“走私”到了我们的沙盒中。字符串标准库中没有函数能够影响外部世界，但是它们绕过了我们的指令计数器。字符串标准库中的有些函数对于DoS攻击而言可能会非常危险。</p>
<blockquote>
<p>示例 使用钩子阻止对未授权函数的访问</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> steplimit = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> validfunc = &#123;</span><br><span class="line">	[<span class="built_in">string</span>.<span class="built_in">upper</span>] = <span class="literal">true</span>,</span><br><span class="line">	[<span class="built_in">string</span>.<span class="built_in">lower</span>] = <span class="literal">true</span>,</span><br><span class="line">	... <span class="comment">-- 其他授权的函数</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span><span class="params">(event)</span></span></span><br><span class="line"> 	<span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span></span><br><span class="line"> 		<span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;fn&quot;</span>)</span><br><span class="line"> 		<span class="keyword">if</span> <span class="keyword">not</span> validfunc[info.func] <span class="keyword">then</span></span><br><span class="line"> 			<span class="built_in">error</span>(<span class="string">&quot;calling bad function :&quot;</span> .. (info.name <span class="keyword">or</span> <span class="string">&quot;?&quot;</span>))</span><br><span class="line"> 		<span class="keyword">end</span></span><br><span class="line"> 	<span class="keyword">end</span></span><br><span class="line"> 	count = count + <span class="number">1</span></span><br><span class="line"> 	<span class="keyword">if</span> count &gt; steplimit <span class="keyword">then</span></span><br><span class="line"> 		<span class="built_in">error</span>(<span class="string">&quot;script uses too much CPU&quot;</span>)</span><br><span class="line"> 	<span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 加载代码段</span></span><br><span class="line"> <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(<span class="built_in">arg</span>[<span class="number">1</span>],<span class="string">&quot;t&quot;</span>,&#123;&#125;))</span><br><span class="line"> <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook,<span class="string">&quot;&quot;</span>,<span class="number">100</span>)</span><br><span class="line"> f()</span><br></pre></td></tr></table></figure>
<p>在上述代码中，表validfunc表示一个包含程序所能够调用的函数的集合。函数hook使用调试库来访问正在被调用的函数，然后检查函数是否在集合validfunc中。<br>对于任何一种沙盒的实现而言，很重要的一点是沙盒内允许使用哪些函数。用于数据描述的沙盒可以限制所有或大部分函数；其他的沙盒则需要更加宽容，也许应该对某些函数提供它们自己带限制的实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/26/Lua%E5%8F%8D%E5%B0%84/" data-id="clw7ne0x700214saddemncfcc" data-title="Lua连续教程之Lua反射" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Autodesk3dMax/">Autodesk3dMax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/algolia/">algolia</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web-Development/">Web Development</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/Visual-Studio/">Visual Studio</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/android-ndk/">android ndk</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/">cocos Creator</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/">json</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/js/">js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/js/node/">node</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-Creator/json/js/node/TypeScript/">TypeScript</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos-creator/">cocos creator</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">小程序开发</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/https/">https</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssh/">ssh</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/">创意编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97/">蓝牙模块</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/">工具脚本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E8%A7%81bug/">常见bug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%BF%E5%91%8A/">广告</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">开发工具的使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/">日常代码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/">Python应用</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E5%BE%AE%E4%BF%A1/">微信</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E5%BE%AE%E4%BF%A1/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/">数据抓取</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E5%BA%94%E7%94%A8/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/">俄罗斯方块</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E7%BB%98%E5%9B%BE/">Python绘图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E7%BB%98%E5%9B%BE/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/">创意编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/Python%E7%BB%98%E5%9B%BE/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/%E6%8A%96%E9%9F%B3%E7%83%AD%E9%97%A8/">抖音热门</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/">工作生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/Python%E5%BA%94%E7%94%A8/">Python应用</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E4%BB%A3%E7%A0%81/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/Python%E5%BA%94%E7%94%A8/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/">服务器搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/">虚拟专用网络</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">电脑使用技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/">破解软件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E7%BC%96%E7%A8%8B/">Lua编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/">网页设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/">节日祝福</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/">课程设计</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E9%80%9A%E4%BF%A1%E5%B7%A5%E7%A8%8B/">通信工程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E9%80%9A%E4%BF%A1%E5%B7%A5%E7%A8%8B/%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A/">实习报告</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%9A%E4%BF%A1%E7%A7%91%E6%8A%80%E4%BA%BA%E5%91%98%E8%81%8C%E4%B8%9A%E9%81%93%E5%BE%B7/">通信科技人员职业道德</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/" rel="tag">1024程序员节</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/404/" rel="tag">404</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Autodesk3dMax/" rel="tag">Autodesk3dMax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Creator/" rel="tag">Cocos Creator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ImageView/" rel="tag">ImageView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sprite/" rel="tag">Sprite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thinter/" rel="tag">Thinter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Word/" rel="tag">Word</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/" rel="tag">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ndk/" rel="tag">android ndk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos/" rel="tag">cocos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos-Creator/" rel="tag">cocos Creator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos-creator/" rel="tag">cocos creator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2dx/" rel="tag">cocos2dx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/facebook/" rel="tag">facebook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/" rel="tag">https</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lua/" rel="tag">lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/" rel="tag">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ndkr10e/" rel="tag">ndkr10e</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quick-Cocos/" rel="tag">quick Cocos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/" rel="tag">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tolua/" rel="tag">tolua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/" rel="tag">ts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeScript/" rel="tag">typeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vsCode/" rel="tag">vsCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/" rel="tag">创意编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E6%80%A7%E8%83%BD/" rel="tag">游戏性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="tag">电脑使用技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A1%AC%E4%BB%B6/" rel="tag">硬件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/" rel="tag">粒子特效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%B9%E7%90%86/" rel="tag">纹理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%B9%E7%90%86%E4%BC%98%E5%8C%96/" rel="tag">纹理优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%98%E5%9B%BE/" rel="tag">绘图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E6%95%AC/" rel="tag">致敬</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%82%E6%97%A5/" rel="tag">节日</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%B7%E6%B1%82/" rel="tag">请求</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/" style="font-size: 10px;">1024程序员节</a> <a href="/tags/404/" style="font-size: 10px;">404</a> <a href="/tags/Android/" style="font-size: 12.22px;">Android</a> <a href="/tags/Autodesk3dMax/" style="font-size: 10px;">Autodesk3dMax</a> <a href="/tags/C/" style="font-size: 14.44px;">C</a> <a href="/tags/Cocos-Creator/" style="font-size: 12.22px;">Cocos Creator</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/ImageView/" style="font-size: 10px;">ImageView</a> <a href="/tags/Java/" style="font-size: 14.44px;">Java</a> <a href="/tags/Lua/" style="font-size: 20px;">Lua</a> <a href="/tags/Mac/" style="font-size: 11.11px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Sprite/" style="font-size: 10px;">Sprite</a> <a href="/tags/Thinter/" style="font-size: 10px;">Thinter</a> <a href="/tags/TypeScript/" style="font-size: 16.67px;">TypeScript</a> <a href="/tags/Word/" style="font-size: 10px;">Word</a> <a href="/tags/Xcode/" style="font-size: 11.11px;">Xcode</a> <a href="/tags/android/" style="font-size: 11.11px;">android</a> <a href="/tags/android-ndk/" style="font-size: 10px;">android ndk</a> <a href="/tags/cocos/" style="font-size: 10px;">cocos</a> <a href="/tags/cocos-Creator/" style="font-size: 18.89px;">cocos Creator</a> <a href="/tags/cocos-creator/" style="font-size: 10px;">cocos creator</a> <a href="/tags/cocos2dx/" style="font-size: 17.78px;">cocos2dx</a> <a href="/tags/facebook/" style="font-size: 10px;">facebook</a> <a href="/tags/git/" style="font-size: 11.11px;">git</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/https/" style="font-size: 10px;">https</a> <a href="/tags/java/" style="font-size: 11.11px;">java</a> <a href="/tags/lua/" style="font-size: 13.33px;">lua</a> <a href="/tags/mac/" style="font-size: 11.11px;">mac</a> <a href="/tags/ndkr10e/" style="font-size: 10px;">ndkr10e</a> <a href="/tags/python/" style="font-size: 15.56px;">python</a> <a href="/tags/quick-Cocos/" style="font-size: 11.11px;">quick Cocos</a> <a href="/tags/shader/" style="font-size: 11.11px;">shader</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/tolua/" style="font-size: 10px;">tolua</a> <a href="/tags/ts/" style="font-size: 10px;">ts</a> <a href="/tags/typeScript/" style="font-size: 10px;">typeScript</a> <a href="/tags/vsCode/" style="font-size: 11.11px;">vsCode</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a> <a href="/tags/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">创意编程</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" style="font-size: 10px;">游戏开发</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E6%80%A7%E8%83%BD/" style="font-size: 10px;">游戏性能</a> <a href="/tags/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 11.11px;">电脑使用技巧</a> <a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 13.33px;">硬件</a> <a href="/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/" style="font-size: 10px;">粒子特效</a> <a href="/tags/%E7%BA%B9%E7%90%86/" style="font-size: 10px;">纹理</a> <a href="/tags/%E7%BA%B9%E7%90%86%E4%BC%98%E5%8C%96/" style="font-size: 10px;">纹理优化</a> <a href="/tags/%E7%BB%98%E5%9B%BE/" style="font-size: 10px;">绘图</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 10px;">编码</a> <a href="/tags/%E8%87%B4%E6%95%AC/" style="font-size: 10px;">致敬</a> <a href="/tags/%E8%8A%82%E6%97%A5/" style="font-size: 10px;">节日</a> <a href="/tags/%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">请求</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/15/cocos2dx%E4%BD%BF%E7%94%A8%E5%B8%A7%E5%8A%A8%E7%94%BB/">cocos2dx使用帧动画</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx_lua%E9%94%AE%E7%9B%98%E7%9B%91%E5%90%AC/">cocos2dx_lua键盘监听</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx-lua%E8%AE%BE%E7%BD%AE%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7/">cocos2dx-lua设置节点层级</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx-lua%E5%AF%B9%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%BC%A9%E6%94%BE/">cocos2dx-lua对图片进行九宫格缩放</a>
          </li>
        
          <li>
            <a href="/2024/05/15/cocos2dx-Lua%E4%B8%ADLabel%E6%96%87%E6%9C%AC%E8%B6%85%E8%BF%87%E7%89%B9%E5%AE%9A%E9%95%BF%E5%BA%A6%E4%BD%BF%E7%94%A8...%E4%BB%A3%E6%9B%BF/">cocos2dx-Lua中Label文本超过特定长度使用...代替</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>