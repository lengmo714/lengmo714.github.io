<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="南锋">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/16/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">c语言中的用户自定义类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 23:01:47" itemprop="dateCreated datePublished" datetime="2020-07-16T23:01:47+08:00">2020-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下面这个示例实现了一种很简单的类型，即布尔类型。选用这个示例的只要动机在于它不涉及复杂的算法，便于我们专注于API的问题。不过尽管如此，这个示例本身还是很有用的。当然，我们可以在Lua中用来表示实现布尔数组。但是，在C语言实现中，可以将每个布尔值存储在一个比特中，所使用的内存量不到使用表方法的3%。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>这个示例需要以下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_WORD (CHAR_BIT * sizeof(unsigned int))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I_WORD(i)     ((unsigned int)(i) / BITS_PER_WORD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I_BIT(i)	  (1 &lt;&lt; ((unsigned int)(i) % BITS_PER_WORD))</span></span><br></pre></td></tr></table></figure>
<p>BITS_PER_WORD表示一个无符号整型数的位数，宏I_WORD用于根据指定的索引来计算存放相应比特位的字，I_BIT用于计算访问这个字中相应比特位要用的掩码。<br>我们可以使用一下的结构体来表示布尔数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitArray</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> values[<span class="number">1</span>];</span><br><span class="line">&#125;BitArray;</span><br></pre></td></tr></table></figure>
<p>由于C89标准不允许分配长度为零的数组，所以我们声明数组values的大小为1，仅有一个占位符；等分配数组时，我们再设置数组的实际大小。下面这个表达式可以计算出拥有n个元素的数组大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(BitArray) * I_WORD(n <span class="number">-1</span>) * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>此处n减去1是因为原结构中已经包含了一个元素的空间。</p>
<h2 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h2><p>在第一个版本中，我们使用显示的调用来设置和获取值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">array</span>.new(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">1000</span> <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">array</span>.<span class="built_in">set</span>(a,i,i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">end</span><br><span class="line">print(<span class="built_in">array</span>.get(a,<span class="number">10</span>))			-- <span class="literal">true</span></span><br><span class="line">print(<span class="built_in">array</span>.get(a,<span class="number">11</span>))			-- fales</span><br><span class="line">paint(<span class="built_in">array</span>.size(a))			-- <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>后续我们将介绍如何同时支持像a:get(i)这样的面向对象风格和像a[i]这样的常见语法。<br>在所有版本中，下列函数是一样的，参加示例。</p>
<blockquote>
<p>示例 操作布尔数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">newarray</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i ;</span><br><span class="line">	<span class="type">size_t</span> nbytes;</span><br><span class="line">	BitArray *a;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">1</span>);</span><br><span class="line">	luaL_argcheck(L, n &gt;= <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">	nbytes = <span class="keyword">sizeof</span>(BitArray) + I_WORD(n<span class="number">-1</span>)*<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	a = (BitArray *)lua_newuserdata(L,nbytes);</span><br><span class="line">	a -&gt; size = n;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= I_WORD(n<span class="number">-1</span>); i++)</span><br><span class="line">		a -&gt; values[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setarray</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = (BitArray *)lua_touserdata(L,<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> index = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	luaL_argcheck(L,a != <span class="literal">NULL</span> , <span class="number">1</span>, <span class="string">&quot;&#x27;array&#x27; expected&quot;</span>);</span><br><span class="line">	luaL_argcheck(L,<span class="number">0</span> &lt;= index &amp;&amp; index &lt; a-&gt;size, <span class="number">2</span> <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line"></span><br><span class="line">	luaL_checkany(L,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lua_toboolean(L,<span class="number">3</span>))</span><br><span class="line">		a -&gt; values[I_WORD(index)] |= I_BIT(index);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		a -&gt; values[I_WORD(index)] &amp;= ~I_BIT(index);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getarray</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = (BitArray *)lua_touserdata(L,<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> index = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	luaL_argcheck(L,a != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;&#x27;array&#x27; expected&quot;</span>);</span><br><span class="line">	luaL_argcheck(L,<span class="number">0</span> &lt;= index &amp;&amp; index &lt;  a-&gt;size , <span class="number">2</span>, <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line"></span><br><span class="line">	lua_pushboolean(L, a-&gt; values[I_WORD(index)] &amp; I_BIT(index));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面让我们一点一点地分析。<br>我们首先关心的是如何在Lua中表示一个C语言结构体。Lua语言专门为这类任务提供了一个名为用户数据的剧本类型。用户数据为Lua语言提供了可以用来存储任何数据的原始内存区域，没有预定义的操作。<br>函数lua_newuserdata分配一块指定大小的内存，然后将相应的用户数据压栈，并返回该块内存的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">lua_newuserdata</span> <span class="params">(lua_State *L, <span class="type">size_t</span> ,size)</span>;</span><br></pre></td></tr></table></figure>
<p>如果因为一些原因需要用其他方法来分配内存，可以很容易地创建一个指针大小的用户数据并在其中存储一个指向真实内存块的指针。<br>示例中第一个函数newarray使用lua_newuserdata创建新的数组。newarray的代码很简单，它检查了其唯一的参数，以字节为单位计算出数组的大小，创建了一个适当大小的用户数据，初始化用户数据的各个字段并将其返回给Lua。<br>第二函数是setarray，它有三个参数：数组、索引和新的值。setarray假定数组索引像Lua语言中的那样是从1开始的。因为Lua可以将任意值当做布尔类型，所以我们用luaL_checkany检查第三个参数，不过luaL_checkany只能确保该参数有一个值。如果用不符合条件的参数调用了setarray，将会收到一条解释错误的信息，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">11</span>,<span class="number">0</span>)</span><br><span class="line">	-- <span class="built_in">stdin</span>:<span class="number">1</span>:bad argument #<span class="number">1</span> to <span class="string">&#x27;set&#x27;</span> (<span class="string">&#x27;array&#x27;</span> expected)</span><br><span class="line"><span class="built_in">array</span>.<span class="built_in">set</span>(a,<span class="number">1</span>)</span><br><span class="line">	-- <span class="built_in">stdin</span>:<span class="number">1</span>:bad argument #<span class="number">3</span> to <span class="string">&#x27;set&#x27;</span> (value expected)</span><br></pre></td></tr></table></figure>
<p>示例中的最后一个函数是getarray，该函数类似于setarray,用于获取元素。<br>我们还需要定义一个获取数组大小的函数和一些初始化库的额外代码，参见示例：</p>
<blockquote>
<p>示例 布尔数组库的额外代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getsize</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = (BitArray *)lua_touserdata(L<span class="number">.1</span>);</span><br><span class="line">	luaL_argcheck(L,a != <span class="literal">NULL</span> , <span class="number">1</span>, <span class="string">&quot;&#x27;array&#x27; expected&quot;</span>);</span><br><span class="line">	lua_pushinteger(L, a -&gt; size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib</span>[] =</span>&#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,newarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;set&quot;</span>,setarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;get&quot;</span>,getarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;size&quot;</span>,getsize&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newlib(L, arraylib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再一次使用了辅助库中的luaL_newlib，该函数创建了一张表，并且用数组arraylib指定的”函数名-函数指针”填充了这张表。</p>
<h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><p>我们当前的额实现有一个重大的漏洞。假设用户泄露一条像array.set(io.stdin,1,false)这样的语句，那么io.stdin的值会是一个带有指向文件流（FILE*）的指针的用户数据，array.set会开心地认为它时一个合法的参数；其后果可能就是内存崩溃。这种行为对于任何一个Lua库而言都是不可接受的。无论你如何使用库，都不应该破坏C语言的数据，也不应该让Lua语言崩溃。<br>要区别不同类型的用户数据，一种常见的方法是为每种类型创建唯一的元表。每次创建用户数据时，用相应的元表进行标记；每当获取用户数据时，检查其是否有正确的元表。由于Lua代码不能改变用户数据的元表，因此不能绕过这些检查。<br>我们还需要有个地方来存储这个新的元表，然后才能用它来创建新的用户数据和检查指定的用户数据是否具有正确的类型。我们之前已经看到过，存储元表有两种方法，即存储在注册表中或者库函数的上值中。在Lua语言中，惯例是将所有新的C原因类型注册到注册表中，用类型名作为索引，以元表作为值。由于注册表中还有其他索引，所以必须谨慎选择类型名以避免冲突。在我们的示例中将使用”LuaBook.array”作为这个新类型的名称。<br>通常，辅助库会提供一些函数来帮忙实现这些内容。我们将使用新的辅助函数包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>		<span class="title function_">luaL_newmetatable</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *tname)</span>;</span><br><span class="line"><span class="type">void</span> 	<span class="title function_">luaL_getmatatable</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *tname)</span>;</span><br><span class="line"><span class="type">void</span>   *<span class="title function_">luaL_checkudata</span>  <span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">const</span> <span class="type">char</span> *tname)</span>;</span><br></pre></td></tr></table></figure>
<p>函数luaL_newmetatable会创建一张新表，然后将其压入栈顶，并将该表与注册表中的指定名称关联起来。函数luaL_getmetatable从注册表中获取与tname关联的元表。最后，luaL_checkudata会检查栈中指定位置上的对象是否是于指定名称的元表匹配的用户数据。如果该对象不是用户数数据，或者该用户数据没有正确的元表，luaL_checkudata就会引发错误；否则，luaL_checkudata就返回这个用户数据的地址。<br>现在让我们开始修改前面的代码。第一步是修改打开库的函数，让该函数为数组创建元表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newmetatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">	luaL_newlib(L,arraylib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是修改newarray使其能为其新建的所有数组设置这个元表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">newarray</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	同前</span><br><span class="line">	luaL_getmatatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">	lua_setmetatable(L,<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数lua_setmetatable会从栈中弹出一个表，并将其设置为指定索引上对象的元表。在本例中这个对象就是新建的用户数据。<br>最后，setarray、getarray和getsize必须检查其第一个参数是否是一个有效的数组。为了简化这项任务，我们定义如下的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> checkarray(L) (BitArray *)luaL_checkudata(L,1,<span class="string">&quot;LuaBook.array&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>有了这个宏，getsize的定义就很简单了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getsize</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = checkarray(L);</span><br><span class="line">	lua_pushinteger(L,a-&gt;size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于setarray和getarray还共享了用来读取和检查它们的第二个参数的代码，所以我们将其通用部分提取出来组成了一个新的辅助函数（getparams）</p>
<blockquote>
<p>示例 setarray&#x2F;getarray的新版本</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> *<span class="title function_">getparams</span> <span class="params">(lua_State *L, <span class="type">unsigned</span> <span class="type">int</span> *mask)</span>&#123;</span><br><span class="line">	BitArray *a = checkarray(L);</span><br><span class="line">	<span class="type">int</span> index = (<span class="type">int</span>)luaL_checkinteger(L,<span class="number">2</span>) <span class="number">-1</span> ;</span><br><span class="line">	luaL_argcheck(L,<span class="number">0</span> &lt;= index &amp;&amp; index &lt; a-&gt; size, <span class="number">2</span>, <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">	*mask = I_BIT(index);</span><br><span class="line">	<span class="keyword">return</span> &amp;a -&gt; values[I_WORD(index)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setarray</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *entry = getparams(L,&amp;mask);</span><br><span class="line">	luaL_checkany(L,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (lua_toboolean(L,<span class="number">3</span>))</span><br><span class="line">		*entry |= mask;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*entry &amp;= ~mask;</span><br><span class="line">		reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getarray</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *entry = getparams(L,&amp;mask);</span><br><span class="line">	lua_pushboolean(L,*entry &amp; mask);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个新版本中，setarray和getarray都很简单，参见示例。现在，如果调用他们时使用了无效的用户数据，我们将会收到一条相应的错误信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">array</span>.get(io.<span class="built_in">stdin</span>,<span class="number">10</span>)</span><br><span class="line">-- bad argument #<span class="number">1</span> to <span class="string">&#x27;get&#x27;</span> (LuaBook.<span class="built_in">array</span> expected, got FILE*)</span><br></pre></td></tr></table></figure>

<h2 id="面向对象访问"><a href="#面向对象访问" class="headerlink" title="面向对象访问"></a>面向对象访问</h2><p>下一步是将这种新类型转换成一个对象，以便用普通的面向对象语法来操作其实例。例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = array.new(<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(a:size())			-- <span class="number">1000</span></span><br><span class="line">a:<span class="built_in">set</span>(<span class="number">10</span>,true)</span><br><span class="line"><span class="built_in">print</span>(a:get(<span class="number">10</span>))		-- true</span><br></pre></td></tr></table></figure>
<p>请注意，a:size()等价于a.size(a)。因此，我们必须让表达式a.size返回函数getsize。此处的关键机制在于元方法__index。对于表而言，Lua会在找不到的指定键时调用这个元方法；而对于用户数据而言，由于用户数据根本没有键，所以Lua在每次访问时都会调用该元方法。<br>假设我们运行了一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do </span><br><span class="line">	local metaarry = getmetatable(array.new(<span class="number">1</span>))</span><br><span class="line">	metaarry.__index = metaarry</span><br><span class="line">	metaarry.<span class="built_in">set</span> = array.<span class="built_in">set</span></span><br><span class="line">	metaarry.get = array.get</span><br><span class="line">	metaarry.size = array.sizeo</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在第一行中，我们创建了一个数组用户获取分配给metaarray的元表（我们无法在Lua中设置用户数据的元表，但是可以获取用户数据的元表）。然后，将metaarray.__index设置为metaarray。当对a.size求值时，因为对象a是一个用户数据，所以Lua在对象a中无法找到键”size”。因此，Lua会尝试通过a的元表的__index字段来获取这个值，而这个字段正好就是metaarray。由于metaarray.size就是array.size，所以a.size(a)就是我们想要的array.size(a)。<br>当然，用C语言也可以达到相同的效果，甚至还可以做得更好：既然数组有自己的操作的对象，那么在表array中也就无需包含这些操作了。我们的库只需导出一个用于创建新数组的函数new就行了，所有的其他操作都变成了对象的方法。C语言代码同样可以直接注册这些方法。<br>操作getsize、getarray和setarray无须做任何改变，唯一需要改变的是注册它们的方式。换而言之，我们必须修改打开库的函数。首先，我们需要两个独立的函数列表，一个用户常规的函数，另一个用户方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_f</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,newarray&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_m</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;set&quot;</span>,setarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;get&quot;</span>,getarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;size&quot;</span>,getsize&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新的打开函数luaopen_array必须创建元表，并把它赋给自己的__index字段，然后在元表中注册所有方法，创建和填充表array:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL+newetatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);  <span class="comment">// 创建元表</span></span><br><span class="line">	lua_pushvalue(L,<span class="number">-1</span>);   <span class="comment">// 复制元表</span></span><br><span class="line">	lua_setfield(L,<span class="number">-2</span>,<span class="string">&quot;__index&quot;</span>); <span class="comment">// mt.__index = mt</span></span><br><span class="line">	luaL_setfuncs(L,arraylib_m,<span class="number">0</span>);  <span class="comment">// 注册元方法</span></span><br><span class="line">	luaL_newlib(L,arraylib_f);   <span class="comment">// 创建库</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们再次使用了luaL_setfuncs将列表arraylib_m中的函数赋值到栈顶的元表中。然后，调用luaL_newlib创建一张新表，并在该表中注册来自列表arraylib_f的函数。<br>最后，向新类型中新增一个__tostring元方法，这样print(a)就可以打印出”array”以及用括号括起来的数组的大小了。该函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array2string</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	BitArray *a = checkarray(L);</span><br><span class="line">	lua_pushfstring(L.<span class="string">&quot;array(%d)&quot;</span>, a-&gt; size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用lua_pushfstring格式化字符串，并将其保留在栈顶。我们还需要将array2string添加到列表arraylib_m中，以此将函数加入到数组对象的元表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_m</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;__tostring&quot;</span>, array2string&#125;,</span><br><span class="line">	other <span class="title function_">methods</span><span class="params">(其他方法)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组访问"><a href="#数组访问" class="headerlink" title="数组访问"></a>数组访问</h2><p>另一种更好的面向对象的表示方法是，使用普通的数组符号来访问数组。只需要简单地使用a[i]就可以替代a:get(i)。对于上面的是示例，由于函数setarray和getarray本身就是按照传递给相应元方法的参数的顺序来接收参数的，所以很容易做到这一点。一种快速的解决方案就是直接在Lua中定义这些元方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local metaarry = getmetatable(array.new(<span class="number">1</span>))</span><br><span class="line">metaarry.__index = array.get</span><br><span class="line">metaarry.__newindex = array.<span class="built_in">set</span></span><br><span class="line">metaarry.__<span class="built_in">len</span> = array.sizeof</span><br></pre></td></tr></table></figure>
<p>必须在数组原来的实现中运行这段代码，无须修改面向对象的访问。这样，就可以使用标准语法了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = array.new(<span class="number">1000</span>)</span><br><span class="line">a[<span class="number">10</span>] = true 			-- <span class="string">&#x27;setarray&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">10</span>])			-- <span class="string">&#x27;getarray&#x27;</span>		-- true</span><br><span class="line"><span class="built_in">print</span>(<span class="comment">#a)				-- &#x27;getsize&#x27;		-- 1000</span></span><br></pre></td></tr></table></figure>
<p>如果还要更加完美，可以在C语言中注册这些元方法。为此，需要再次修改初始化函数。参见如下示例：</p>
<blockquote>
<p>示例 新的初始化比特数组库的代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_f</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,newarray&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">arraylib_m</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;__newindex&quot;</span>,setarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;__index&quot;</span>,getarray&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;__len&quot;</span>,getsize&#125;,</span><br><span class="line">	(<span class="string">&quot;__tostring&quot;</span>,array2string),</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newmetatable(L,<span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">	luaL_setfuncs(L,arraylib_m,<span class="number">0</span>);</span><br><span class="line">	luaL_newlib(L,arraylib_f);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个新版本中，仍然只有一个公有函数new，所有的其他函数都只是特定操作的元方法。</p>
<p>##轻量级用户数据<br>到现在为止，我们使用的用户数据成为完全用户数据。Lua语言还提供了另一种数据，成为轻量级用户数据。<br>轻量级用户数据时一个代表C语言指针的值，即它时一个void*值。因为轻量级用户数据是一个值而不是一个对象，所以无须创建它（就好比我们也不需要创建数组）。要将一个轻量级用户数据放入栈中，可以调用lua_pushlightuserdata:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_pushlightuserdata</span><span class="params">(lua_State *L,<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure>
<p>尽管名字差不多，但实际上轻量级用户数据和完全用户数据之间区别很大。轻量级用户数据不是缓冲区，而只是一个指针，它们也没有元表。与数值一样，轻量级用户数据不受垃圾收集器的管理。<br>有时，人们会将轻量级用户数据当做完全用户数据的一种廉价替代物来使用，但这种用法并不普遍。首先，轻量级用户数数据没有元表，因此没有办法得知其类型。其次，不要“完全”二字所迷惑，实际上完全用户数据的开销也并不大。对于给定的内存大小，完全用户数据与malloc相比值增加了一点开销。<br>轻量级用户数据的真正用途是相等性判断。由于完全用户数据时一个对象，因此它只和自身相等；然而，一个轻量级用户数据表示的是一个C语言指针的值。因此，它与所有表示相同指针的轻量级用户数据相等。因此，我们可以使用轻量级用户数据在Lua语言中查找C语言对象。<br>我们已经见到过轻量级用户数据的一种典型用法，即在注册表中被用作键。在这种情况下，轻量级用户数据的相等性是至关重要的。每次使用lua_pushlightuserdata压入相同的地址时，我们都会得到相同的Lua值，也就是注册表中相同的元素。<br>Lua语言中另一种典型的场景是把Lua语言对象当做对应的C语言对象的代理。例如：输入&#x2F;输出库使用Lua中的用户数据来表示C语言的流。当操作时从Lua语言到C语言时，从Lua对象到C对象的映射很简单。还是以输入&#x2F;输出库为例，每个Lua语言流会保存指向其相应C语言流的指针。不过，当操作时从C语言到Lua语言时，这种映射就可能比较棘手。例如，假设在输入&#x2F;输出系统中有某些回调函数（例如，那些告诉我们还有多少数据需要被读取的函数），回调函数接收它要操作的C语言流，那么如何从中得到其相应的Lua对象呢？由于C语言流是由C语言标准库定义的而不是我们定义的，因此无法在C语言流中存储任何东西。<br>轻量级用户数据为这种映射提供了一种好的解决方案。我们可以保存一张表，其中键是带有流地址的轻量级用户数据，值是Lua中表示流的完全用户数据。在回调函数中，一旦有了流地址，就可以将其作为轻量级用户数据，把它当做这张表的索引来获取对应的Lua对象（这张表很可能得事弱引用的；否则，这些完全用户数据可能永远不会被作为垃圾回收）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/09/%E7%BC%96%E5%86%99C%E5%87%BD%E6%95%B0%E7%9A%84%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/09/%E7%BC%96%E5%86%99C%E5%87%BD%E6%95%B0%E7%9A%84%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Lua连续教程之编写C函数的技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-09 22:45:28" itemprop="dateCreated datePublished" datetime="2020-07-09T22:45:28+08:00">2020-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua中的“数组”就是特殊方式使用的表。像lua-settable和lua-gettable这种用来操作表的通用函数，也可用于操作数组。不过，CAPI为使用整数索引的表的访问和封信提供了专门的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_geti</span> <span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">int</span> key)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_seti</span> <span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">int</span> key)</span>;</span><br></pre></td></tr></table></figure>
<p>Lua5.3之前的版本只提供了这些函数的原始版本，即lua_rawgeti和lua_rawseti。这两个函数类似于lua_geti和lua_seti，但进行的是原始访问。当区别并不明显时，那么原始版本可能会稍微快一点。<br>lua_geti和lua_seti的描述有一点令人困惑，因为其用了两个索引：index表示在栈中的位置，key表示元素在表中的位置。当t为正数时，那么调用lua_geti(L,t,key)等价于如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L,key);</span><br><span class="line">lua_gettable(L,t);</span><br></pre></td></tr></table></figure>
<p>调用lua_seti(L,t,key)等价于如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L,key);</span><br><span class="line">lua_insert(L,<span class="number">-2</span>);</span><br><span class="line">lua_settable(L,t);</span><br></pre></td></tr></table></figure>
<p>作为使用这些函数的具体示例，下面实现了函数map，该函数对数组中的所有元素调用一个指定的函数，然后用词函数返回的结果替换掉对应的数组元素。</p>
<blockquote>
<p>C语言中的函数map</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">l_map</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i , n;</span><br><span class="line">	<span class="comment">/*第一个参数必须是一张表(t) */</span></span><br><span class="line">	luaL_checktype(L,<span class="number">1</span>,LUA_TTABLE);</span><br><span class="line">	<span class="comment">/*第二个参数必须是一个函数(f) */</span></span><br><span class="line">	luaL_checktype(L,<span class="number">2</span>,LUA_TFUNCTION);</span><br><span class="line">	n = luaL_len(L,<span class="number">1</span>);<span class="comment">/*获取表的大小*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;=n; i++)&#123;</span><br><span class="line">		lua_pushvalue(L,<span class="number">2</span>); <span class="comment">/*压入f*/</span></span><br><span class="line">		lua_geti(L,<span class="number">1</span>,i); <span class="comment">/*压入t[i]*/</span></span><br><span class="line">		lua_call(L,<span class="number">1</span>,<span class="number">1</span>); <span class="comment">/*调用f(t[i])*/</span></span><br><span class="line">		lua_seti(L,<span class="number">1</span>,i); <span class="comment">/*t[i] = result */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 没有返回值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例还引入了三个新函数：luaL_checktype、luaL_len和lua_call。<br>函数luaL_checktype确保指定的参数具有指定的类型，否则它会引发一个错误。<br>原始的lua_len类似于长度运算符。由于元方法的存在，该运算符能够返回任意类型的对象，而不仅仅是数字；因此，lua_len会在栈中返回其结果。函数luaL_len会将长度作为整型数返回，如果无法进行强制类型转换则会引发错误。<br>函数lua_call做的是不受保护的调用，该函数类似于lua_pcall，但在发生错误时lua_call会传播错误而不是返回错误码。在一个应用中编写主函数时，不应使用lua_call，因为我们需要捕获所有的错误。不过，编写一个函数时，一般情况下使用lua_call是个不错的注意；如果发生错误，就留给关心错误的人去处理吧。</p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>当C函数接收到一个Lua字符串为参数时，必须遵守两条规则：在使用字符串期间不能从栈中将其弹出，而且不应该修改字符串。<br>当C函数需要创建一个返回给Lua的字符串时，要求则更高。此时，是C语言代码负责缓冲区的分配&#x2F;释放、缓冲区溢出，以及其他对C语言来说比较困难的任务。因此，LuaAPI提供了一些函数来帮助完成这些任务。<br>标准API为两种常用的字符串操作提供了支持，即子串提取和字符串连接。要提取子串，那么基本的操作lua_pushlstring可以获取字符串长度作为额外的参数。因此，如果要把字符串s从i到j（包含）的子串传递给Lua，就必须：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_pushlstring(L,s+i,j-i+1);</span><br></pre></td></tr></table></figure>
<p>举个例子，假设需要编写一个函数，该函数根据指定的分隔符来分隔字符串，并返回一张包含子串的表。例如，调用split(“hi:ho:there”,”:”)应该返回表{“hi”,”ho”,”there”}。下面示例演示了该函数的一种简单实现：</p>
<blockquote>
<p>分隔字符串</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_split</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *sep = luaL_checkstring(L,<span class="number">2</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *e;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	lua_newtable(L); <span class="comment">/*结果表*/</span></span><br><span class="line">	<span class="comment">/* 依次处理每个分隔符*/</span></span><br><span class="line">	<span class="keyword">while</span> ((e = <span class="built_in">strchr</span>(s,*sep)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		lua_pushlstring(L,s,e - s); <span class="comment">/*压入子串*/</span></span><br><span class="line">		lua_rawseti(L,<span class="number">-2</span>,i++); <span class="comment">/* 向表中插入*/</span></span><br><span class="line">		s = e + <span class="number">1</span>; <span class="comment">/*跳过分隔符*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 插入最后一个子串*/</span></span><br><span class="line">	lua_pushstring(L,s);</span><br><span class="line">	lua_rawseti(L,<span class="number">-2</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">/*将结果表返回*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数无须缓冲区，并能处理任意长度的字符串，Lua语言会负责处理所有的内存分配。<br>要连接字符串，Lua提供了一个名为lua_concat的特殊函数，该函数类似于Lua中的连接操作符(..)，它会将数字转换为字符串，并在必要时调用元方法。此外，该函数还能一次连接两个以上的字符串。调用lua_concat(L,n)会连接栈最顶端的n个值，并将结果压入栈。<br>另一个有帮助的函数是lua_pushfstring:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">lua_pushfstring</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数在某种程度上类似于C函数sprintf，它们都会根据格式字符串和额外的参数来创建字符串。然而，与sprintf不同，使用lua_pushfstring时不需要提供缓冲区。不管字符串有多大，Lua都会动态地为我们创建。lua_pushfstring会将结果字符串压入栈中并返回一个指向它的指针，该函数能够接受如下所示字符。</p>
<hr>
<p>%s 						插入一个以\0结尾的字符串<br>%d						插入一个int<br>%f 						插入一个Lua语言的浮点数<br>%p 						插入一个浮点数<br>%I 						插入一个Lua语言的整型数<br>%c 						插入一个以int表示的单字节字符<br>%U						插入一个以int表示的UTF-8字节序列<br>%%						插入一个百分号</p>
<hr>
<p>该函数不能使用诸如宽度或者精度之类的修饰符。<br>当只需要连接几个字符串时，lua_concat和lua_pushfstring都很有用。不过，如果需要连接很多字符串，此时，我们可以用由辅助库提供的缓冲机制。<br>缓冲机制的简单用法只包含两个函数：一个用于在组装字符串时提供任意大小的缓冲区；另一个用于将缓冲区中的内容转换为一个Lua字符串。下面示例用源文件lstrlib.c中string.upper的实现演示了这些函数。</p>
<blockquote>
<p>函数string.upper</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">str_upper</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">size_t</span> l;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	luaL_Buffer b;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s = luaL_checklstring(L,<span class="number">1</span>,&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="type">char</span> *p = luaL_buffinitsize(L,&amp;b,l);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; l; i++)</span><br><span class="line">		p[i] = <span class="built_in">toupper</span>(uchar(s[i]));</span><br><span class="line">	luaL_pushresultsize(&amp;b,l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用辅助库中缓冲区的第一步是声明一个luaL_Buffer类型的变量。第二步是调用luaL_buffinitsize获取一个指向指定大小缓冲区的指针，之后就可以自由地使用该缓冲区来创建字符串了。最后需要调用luaL_pushresultsize将缓冲区中的内容转换为一个新的Lua字符串，并将该字符串压栈。其中，第二步调用时就确定了字符串的最终长度。通常情况下，像我们的示例一样，字符串的最终大小与缓冲区大小相等，但也可能更小。加入我们并不知道返回字符串的准确长度，但知道其最大不超过多少，那么可以操守地为其分配一个较大的空间。<br>请注意，luaL_pushresultsize并未获取Lua状态作为其第一个参数。在初始化之后，缓冲区保存了对Lua状态的引用，因此在调用其他操作缓冲区的函数时无需再传递该状态。<br>加入不知道返回结果大小的上限值，我们还可以通过逐步增加内容的方式来使用辅助库的缓冲区。辅助库提供了一个用于缓冲区中增加内容的函数：luaL_addvalue用于在栈顶增加一个Lua字符串，luaL_addlstring用于增加一个长度明确的字符串，luaL_addstring用于增加一个以\0结尾的字符串，luaL_addchar用于增加一单个字符。这些函数的原型如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void luaL_buffinit   (lua_State *L, luaL_Buffer *B);</span><br><span class="line">void luaL_addvalue   (luaL_Buffer *B);</span><br><span class="line">void lua_addlstring  (luaL_Buffer *B, const <span class="built_in">char</span> *s, size_t l);</span><br><span class="line">void lua_addstring   (luaL_Buffer *B, const <span class="built_in">char</span> *s);</span><br><span class="line">void luaL_addchar	(luaL_Buffer *B, <span class="built_in">char</span> c);</span><br><span class="line">void luaL_pushresult (luaL_Buffer *B);</span><br></pre></td></tr></table></figure>
<p>下面示例通过函数table.concat的一个简化的实现演示了这些函数的使用。</p>
<blockquote>
<p>示例 函数table.concat的一个简化的实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tconcat</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_Buffer b;</span><br><span class="line">	<span class="type">int</span> i , n;</span><br><span class="line">	luaL_checktype(L,<span class="number">1</span>,LUA_TTABLE);</span><br><span class="line">	n = luaL_len(L,<span class="number">1</span>);</span><br><span class="line">	luaL_buffinit(L,&amp;b);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		lua_geti(L,<span class="number">1</span>,i);</span><br><span class="line">		luaL_addvalue(b);</span><br><span class="line">	&#125;</span><br><span class="line">	luaL_pushresult(&amp;b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中，首先调用luaL_buffinti来初始化缓冲区。然后，向缓冲区中逐个增加元素，本例中用的是luaL_addvalue。最后，luaL_pushresult刷新缓冲区并在栈顶留下最终的结果字符串。<br>在使用辅助库的缓冲区时，我们必须注意一个细节。初始化一个缓冲区后，Lua栈可能还会保留某些内部数据。因此，我们不能假设在使用缓冲区之前栈顶仍然停留在最初的位置。此外，尽管使用缓冲区时我们可以将该栈用于其他用途，但在访问栈之前，对栈的压入和弹出次数必须平衡。唯一的例外是luaL_addvalue，该函数会假设要添加到缓冲区的字符串是位于栈顶的。</p>
<h2 id="在C函数中保存状态"><a href="#在C函数中保存状态" class="headerlink" title="在C函数中保存状态"></a>在C函数中保存状态</h2><p>通常情况下，C函数需要保存一些非局部数据，即生存时间超出C函数执行时间的数据。在C语言中，我们通常使用全局变量或静态变量来满足这种需求。然而，当我们为Lua编写库函数时，这并不是一个好办法。首先，我们无法在一个C语言变量中保存普通的Lua值。其次，使用这类变量的库无法用于多个Lua状态。<br>更好的办法是从Lua语言中寻求帮助。Lua函数有两个地方可用于存储非局部数据，即全局变量和非局部变量，而CAPI也提供了两个类似的地方来存储非局部数据，即注册表和上值。</p>
<h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><p>注册表是一张只能被C代码访问的全局表。通常情况下，我们使用注册表来存储多个模块间共享的数据。<br>注册表总是位于伪索引LUA_REGISTRYINDEX中。伪索引就像是一个栈中的索引，但它所关联的值不在栈中。LuaAPI中大多数接受索引作为参数的函数也能将伪索引作为参数，像lua_remove和lua_insert这种操作栈本身的函数除外。例如，要获取注册表中键为”key”的值，可以使用如下的调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_getfield(L,LUA_REGISTRYINDEX,<span class="string">&quot;Key&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注册表是一个普通的Lua表，因此可以使用除nil外的任意Lua值来检索它。不过，由于所有的C语言模块共享的是同一个注册表，为了避免冲突，我们必须谨慎地选择作为键的值。当允许其他独立的库访问我们的数据时，字符串类型的键尤为有用，因为这些库只需知道键的名字就可以了。对于浙西键，选择名字时没有一种可以绝对避免冲突的方法；不过，诸如避免使用常见的名字，以及用库名或类似的东西作为键名的前缀，仍然是好的做法。<br>在注册表中不能使用数值类型的键，因为Lua语言将其用作引用系统的保留字。引用系统由辅助库中的一对函数组成，有了这两个函数，我们在表中存储值时不必担心如何创建唯一的键。函数luaL_ref用于创建新的引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ref = luaL_ref(L,LUA_REGISTRYINDEX);</span><br></pre></td></tr></table></figure>
<p>上述调用会从栈中弹出一个值，然后分配一个新的整型的键，使用这个键将从栈中弹出的值保存到注册表中，最后返回该整型键，而这个键就被称为引用。<br>顾名思义，我们主要是在需要一个C语言结构体中保存一个指向Lua值的引用时使用引用。正如我们之前所看到的，不应该将指向Lua字符串的指针保存在获取该指针的函数之外。此外，Lua语言甚至没有提供指向其他对象的指针。因此，我们无法通过指针来引用Lua对象。当需要这种指针时，我们可以创建一个引用并将其保存在C语言中。<br>要将于引用ref关联的值压入栈中，只要这样写就行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_rawgeti(L,LUA_REGISTRYINDEX,ref);</span><br></pre></td></tr></table></figure>
<p>最后，要释放值和引用，我们可以调用luaL_unref:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luaL_unref(L,LUA_REGISTRYINDEX,ref);</span><br></pre></td></tr></table></figure>
<p>在这句调用后，再次调用luaL_ref会再次返回相同的引用。<br>引用系统将nil视为一种特殊情况。无论何时为一个nil值调用luaL_ref都不会创建新的引用，而是会返回一个常量引用LUA_REFNIL。如下的调用没什么好处：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luaL_unref(L,LUA_REGISTRYINDEX,LUA_REFNIL);</span><br></pre></td></tr></table></figure>
<p>而如下的代码则会像我们期望地一样像栈中压入一个nil：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_rawgeti(L,LUA_REGISTRYINDEX,LUA_REFNIL);</span><br></pre></td></tr></table></figure>
<p>引用系统还定义了一个常量LUA_NOREF，这是一个不同于其他合法引用的整数，它可以用于表示无效的引用。<br>当创建Lua状态时，注册表中有两个预定义的引用：<br>LUA_RIDX_MAINTHREAD<br>指向Lua状态本身，也就是其主线程。<br>LUA_RIDX_GLOBALS<br>指向全局变量。<br>另一种在注册表中创建唯一键的方法是，使用代码中静态变量的地址，C语言的链接编辑器会确保键在所有已加载的库中的唯一性。要使用这种方法，需要用到函数lua_pushlightuserdata，该函数会在栈中压入一个表示C语言指针的值。下面的代码演示了如何使用这种方法在注册表中保存和获取字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*具有唯一地址的变量*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> Key = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="comment">/* 保存字符串*/</span></span><br><span class="line">lua_pushlightuserdata(L,(<span class="type">void</span> *)&amp;Key); <span class="comment">/* 压入地址*/</span></span><br><span class="line">lua_pushstring(L,myStr); <span class="comment">/*压入值*/</span></span><br><span class="line">lua_settable(L,LUA_REGISTRYINDEX); <span class="comment">/* registry[&amp;Key] = myStr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取字符串*/</span></span><br><span class="line">lua_pushlightuserdata(L,(<span class="type">void</span> *)&amp;Key); <span class="comment">/* 压入地址*/</span></span><br><span class="line">lua_gettbale(L,LUA_REGISTRYINDEX); <span class="comment">/* 获取值 */</span></span><br><span class="line">myStr = lua_tostring(L,<span class="number">-1</span>); <span class="comment">/*转换为字符串*/</span></span><br></pre></td></tr></table></figure>
<p>为了简化将变量地址用作唯一键的方法，Lua5.2中引入了两个新函数：lua_rawgetp和lua_rawsetp。这两个函数类似于lua_rawgeti和lua_rawseti，但它们使用C语言指针作为键。使用这两个函数，可以将上面的代码重写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> Key = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="comment">/* 保存字符串 */</span></span><br><span class="line">lua_pushstring(L,myStr);</span><br><span class="line">lua_rawsetp(L,LUA_REGISTRYINDEX,(<span class="type">void</span> *)&amp;Key);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取字符串*/</span></span><br><span class="line">lua_rawgetp(L,LUA_REGISTRYINDEX,(<span class="type">void</span> *)&amp;Key);</span><br><span class="line">myStr = lua_toshtring(L,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>这两个函数都使用了原始访问。由于注册表没有元素，因此原始访问和普通访问相同，而且效率还会稍微高一些。</p>
<h3 id="上值"><a href="#上值" class="headerlink" title="上值"></a>上值</h3><p>注册表提供了全局变量，而上值则实现了一种类似于C语言静态变量的机制。每一次在Lua中创建新的C函数时，都可以将任意数量的上值与这个函数相关联，而每个上值都可以保存一个Lua值。后面在调用该函数时，可以通过伪索引来自由地访问这些上值。<br>我们将这种C函数与其上值的关联称为闭包。C语言闭包类似于Lua语言闭包。 特别的，可以用相同的函数代码来创建不同的闭包，每个闭包可以拥有不同的上值。<br>接下来看一个简单的示例，让我们用C语言创建一个函数newCounter。该函数是一个工厂函数，每次调用都会返回一个新的计数函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = newCounter()</span><br><span class="line">print(c1(),c1(),c1())			-- <span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></span><br><span class="line">c2 = newCounter()</span><br><span class="line">print(c2(),c2(),c2())			-- <span class="number">1</span>	<span class="number">2</span>	<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>尽管所有的计数器都适用相同的C语言代码，但它们各自都保留了独立的计数器。工厂函数的代码形如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">counter</span> <span class="params">(lua_State *L)</span>;  <span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">newCounter</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	lua_pushinteger(L,<span class="number">0</span>);</span><br><span class="line">	lua_pushcclosure(L,&amp;counter,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键函数是lua_pushcclosure，该函数会创建一个新的闭包。lua_pushcclosure的第二个参数是一个基础函数，第三个参数是上值的数量。在创建一个新的闭包前，我们必须将上值的初始值压栈。在此示例中，我们压入了零作为唯一一个上值的初始值。正如我们预想的那样，lua_pushcclosure会将一个新的闭包留在栈中，并将其作为newCounter的返回值。<br>现在，来看一下counter的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">counter</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val = lua_tointeger(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">	lua_pushinteger(L,++val);<span class="comment">/*新值*/</span></span><br><span class="line">	lua_copy(L,<span class="number">-1</span>,lua_upvalueindex(<span class="number">1</span>)); <span class="comment">/*更新上值*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/*返回新值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键是宏lua_upvalueindex,它可以生成上值的伪索引。特别的，表达式lua_upvalueindex(1)给出了正在运行的函数的第一个上值的伪索引，该为索引同其他的栈索引一样，唯一区别的是它不存在与栈中。因此，调用lua_tointeger会以整型返回一个上值的当前值。然后，函数counter将新值++val压栈，并将其复制一份作为新上值的值，再将其返回。<br>接下来是一个更高级的示例，我们将使用上值来实现元组。元组是一种具有匿名字段的常量结构，我们可以用一个数值索引来获取某个特定的字段，或者一次性地获取所有字段。在我们的实现中，将元组表示为函数，元组的值存储在函数的上值中。当使用数值参数来调用该函数时，函数会返回特定的字段。当不使用参数来调用该函数时，则返回所有字段。一下代码演示了元组的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = tuple.new(<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>,&#123;&#125;,<span class="number">3</span>)</span><br><span class="line">print(x(<span class="number">1</span>))			-- <span class="number">10</span></span><br><span class="line">print(x(<span class="number">2</span>))			-- hi</span><br><span class="line">print(x(<span class="number">3</span>))			-- <span class="number">10</span> hi table:ox8087878 <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在C语言中，我们会用同一个函数t_tuple来表示所有的元组，代码参考下示例。</p>
<blockquote>
<p>元组的实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">t_tuple</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	lua_Integer op = luaL_optinteger(L,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (op == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; !lua_isnone(L,lua_upvalueindex(i)); i++)</span><br><span class="line">			lua_pushvalue(L,lua_upvalueindex(i));</span><br><span class="line">		<span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		luaL_argcheck(L,<span class="number">0</span>&lt;op &amp;&amp; op &lt;= <span class="number">256</span>,<span class="number">1</span>,<span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (lua_isnone(L,lua_upvalueindex(op)))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		lua_pushvalue(L,lua_upvalueindex(op));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">t_new</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> top = lua_gettop(L);</span><br><span class="line">	luaL_argcheck(L, top&lt; <span class="number">256</span>, top ,<span class="string">&quot;too many fields&quot;</span>);</span><br><span class="line">	lua_pushcclosure(L,t_tuple,top);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">tuplelib</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;new&quot;</span>,t_new&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_tuple</span> <span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newlib(L,tuplelib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于调用元组时既可以使用数字作为参数也可以不用数字作为参数，因此t_tuple使用luaL_optinteger来获取可选参数。该函数类似于luaL_checkinteger,但当参数不存在时不会报错，而是返回指定的默认值。<br>C语言函数中最多可以有255个上值，而lua_upvaluindex的最大索引值是256。因此，我们使用luaL_argcheck来确保这些范围的有效性。<br>当访问一个不存在的上值时，结果是一个类型为LUA_TNONE的伪值。函数t_tuple使用lua_isnone测试指定的上值是否存在。不过，我们永远不应该使用负数或者超过256的索引值来调用lua_upvalueindex，因此必须对用户提供索引进行检查。函数luaL_argcheck可用于检查给定的条件，如果条件不符合，则会引发错误并返回一条友好的错误信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; t = tuple.new(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&gt; t(<span class="number">300</span>)</span><br><span class="line">--&gt; <span class="built_in">stdin</span>:<span class="number">1</span>:bad argument #<span class="number">1</span> to <span class="string">&#x27;t&#x27;</span> (index out of range)</span><br></pre></td></tr></table></figure>
<p>luaL_argcheck的第三个参数表示错误信息的参数编号，第四个参数表示对信息的不出。<br>创建元组的函数t_new很简单，由于其参数已经在栈中，因此该函数先检查字段的数量是否符合闭包中上值个数的限制，然后将所有上值作为参数调用lua_pushcclosure来创建一个t_tuple的闭包。最后，数组tuplelib和函数luaopen_tuple是创建tuple库的标准代码，该库只有一个函数new。</p>
<h3 id="共享的上值"><a href="#共享的上值" class="headerlink" title="共享的上值"></a>共享的上值</h3><p>我们经常需要同一个库的所有函数之间共享某些值或变量，虽然可以用注册表来完成这个任务，但也可以使用上值。<br>与Lua语言的闭包不同，C语言的闭包不能共享上值，每个闭包都有其独立的上值。但是，我们可以设置不同函数的上值指向一张共同的表，这张表就成为了一个共同的环境，函数在其中能够共享数据。<br>Lua语言提供了一个函数，该函数可以简化同一个库中所有函数间共享上值的任务。我们已经使用luaL_newlib打开了C语言库。Lua将这个函数实现为如下的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> luaL_newlib(L,lib) \ (luaL_newlibtable(L,lib),(luaL_setfuncs(L,lib,0))</span></span><br></pre></td></tr></table></figure>
<p>宏luaL_newlibtable只是为库创建了一张新表。然后，函数luaL_setfuncs将列表lib中的函数添加到位于栈顶的新表中。<br>我们这里感兴趣的是luaL_setfuncs的第三个参数，这个参数给出了库中的新函数共享的上值个数。当调用lua_pushcclosure时，这些上值的初始值应该位于栈顶。因此，如果要创建一个库，这个库中的所有函数共享一张表作为它们唯一的上值，则可以使用如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 创建库的表*/</span><br><span class="line">luaL_newlibtable(L,lib);</span><br><span class="line">/* 创建共享上值 */</span><br><span class="line">lua_newtable(L);</span><br><span class="line">/*将表&#x27;lib&#x27;中的函数加入到新库中，将之前的表共享为上值*/</span><br><span class="line">luaL_setfuncs(L,lib,1);</span><br></pre></td></tr></table></figure>
<p>最后一个函数调用从栈中删除了这张共享表，只留下了新库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/28/%E5%9C%A8Lua%E4%B8%AD%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/28/%E5%9C%A8Lua%E4%B8%AD%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">在Lua中调用C语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-28 01:00:51" itemprop="dateCreated datePublished" datetime="2020-06-28T01:00:51+08:00">2020-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们说用Lua可以调用C语言函数，但这并不意味着Lua可以调用所有的C函数。当C语言调用Lua函数时，该函数必须遵循一个简单的规则来传递参数和获取结果。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>同样，当Lua调用C函数时，这个C函数也必须遵循某种规则来获取参数和返回结果。此外，当Lua调用C函数时，我们必须注册该函数，即必须以一种恰当的方式为Lua提供该C函数的地址。<br>Lua调用C函数时，也使用一个与C语言调用Lua函数时相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。<br>此处的重点在于，这个栈不是一个全局结构；每个函数都有其私有的局部栈。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置。即使一个C函数调用了Lua代码，而且Lua代码又再次调用了同一个C函数，这些调用每一次都只会看到本次调用自己的私有栈，其中索引为1的位置上就是一个参数。</p>
<h2 id="C函数"><a href="#C函数" class="headerlink" title="C函数"></a>C函数</h2><p>先举一个例子，让我们实现一个简化版本的正弦函数，该函数返回某个给定数的正弦值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_sin</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">double</span> d = lua_tonumber(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushnumber(L,<span class="built_in">sin</span>(d));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有在Lua中注册的函数都必须使用一个相同的原型，该原型就是定义在lua.h中的lua_CFunction:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*lua_CFunction)</span><span class="params">(lua_State *L)</span>;</span><br></pre></td></tr></table></figure>
<p>从C语言的角度看，这个函数只有一个指向Lua状态类型的指针作为参数，返回值为一个整型数，代表压入栈中的返回值的个数。因此，该函数在压入结果前无须清空栈。在该函数返回后，Lua会自动保存返回值并清空整个栈。<br>在Lua中，调用这个函数前，还必须通过lua_pushcfunction注册该函数。函数lua_pushcfunction会获取一个指向C函数的指针，然后在Lua中创建一个”function”类型，代表待注册的函数。一旦完成注册，C函数就可以像其他Lua函数一样行事了。<br>一种快速测试函数l_sin的方法是，将其代码放到简单解释器中，并将下列代码添加到luaL_openlibs调用的后面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_pushcfunction(L,l_sin);</span><br><span class="line">lua_setglobal(L,<span class="string">&quot;mysin&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码的第一行压入一个函数类型的值，第二行将这个值赋给全局变量mysin。完成这些修改后，我们就可以在Lua脚本中使用新函数mysin了。<br>要编写一个更专业的正弦函数，必须检查其参数的类型，而辅助库可以帮助我们完成这个任务。函数luaL_checknumber可以检查指定的参数是否为一个数字：如果出现错误，该函数会抛出一个告知性的错误信息；否则，返回这个数字。只需对上面这个正弦函数稍作修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_sin</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">double</span> d = luaL_checknumber(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushnumber(L,<span class="built_in">sin</span>(d));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了上述修改后，如果调用mysin(‘a’)就会出现如下的错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad argument #<span class="number">1</span> to <span class="string">&#x27;mysin&#x27;</span> (number expected, got <span class="built_in">string</span>)</span><br></pre></td></tr></table></figure>
<p>函数luaL_checknumber会自动用参数的编号(#1)、函数名(“mysin”)、期望的参数类型及实际的参数类型来填写错误信息。<br>下面是一个更复杂的示例，编写一个函数返回指定目录下的内容。由于ISO C中没有具备这种功能的函数，因此Lua没有在标准库中提供这样的函数。这里，我们假设使用一个POSIX兼容的操作系统。这个函数以一个目录路径字符串作为参数，返回一个列表，列出该目录下的内容。例如，调用dir(“&#x2F;home&#x2F;lua”)会得到形如{“.”,”..”,”src”,”bin”,”lib”}的表。该函数的完整代码如下：</p>
<blockquote>
<p>一个读取目录的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_dir</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	DIR *dir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path = lual_checkstring(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	dir = opendir(path);</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		lua_pushnil(L);</span><br><span class="line">		lua_pushstring(L,strerror(error));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		lua_newtable(L);</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			lua_pushinteger(L,i++);</span><br><span class="line">			lua_pushstring(L,entry -&gt; d_name);</span><br><span class="line">			lua_settable(L,<span class="number">3</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			closedir(dir);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数先使用与luaL_checknumber类似的函数luaL_checkstring检查目录路径是否为字符串，然后使用函数opendir打开目录。如果无法打开目录，该函数会返回nil以及一条用函数strerror获取的错误信息。在打开目录后，该函数会创建一张新表，然后用目录中的元素填充这张新表。最后，该函数关闭目录并返回1，在C语言中即表示该函数将其栈顶的值返回给了Lua。<br>在某些情况中，l_dir的这种实现可能会造成内存泄露。该函数调用的三个Lua函数均可能由于内存不足而失败。这三个函数中的任意一个执行失败都会引发错误，并中断函数l_dir的执行，进而也就无法调用closedir了。</p>
<h2 id="延续"><a href="#延续" class="headerlink" title="延续"></a>延续</h2><p>通过lua_pcall和lua_call，一个被Lua调用的C函数也可以回调Lua函数。标准库中有一些函数就是这么做的：table.sort调用了排序函数，string.gsub调用了替换函数，pcall和xpcall以保护模式来调用函数。如果你还记得Lua代码本身就是被C代码调用的，那么你应该知道调用顺序类似于：C调用Lua，Lua又调用了C，C又调用了Lua。<br>通常，Lua语言可以处理这种调用顺序；毕竟，与C语言的集成是Lua的一大特点。但是，有一种情况下，这种相互调用会有问题，那就是协程。<br>Lua语言中的每个协程都有自己的栈，其中保存了该协程所挂起调用的信息。具体地说，就是该栈中存储了每一个调用的返回地址、参数及局部变量。对于Lua函数的调用，解释器只需要这个栈即可，我们将其成为软栈。然而，对于C函数的调用，解释器必须使用C语言栈。毕竟，C函数的返回地址是局部变量都位于C语言栈中。<br>对于解释器来说，拥有多个软栈并不难；然而，ISO C的运行时环境却只能拥有一个内部栈。因此，Lua中的协程不能挂起C函数的执行：如果一个C函数位于从resume到对应yield的调用路径中，那么Lua无法保存C函数的状态以便在下次resume时恢复状态。请考虑如下的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.wrap(function()</span><br><span class="line">	<span class="built_in">print</span>(pcall(coroutine.<span class="keyword">yield</span>))</span><br><span class="line">end)</span><br><span class="line">co()</span><br><span class="line"></span><br><span class="line">-- false attempt to <span class="keyword">yield</span> across metamethod/C-call boundary</span><br></pre></td></tr></table></figure>
<p>函数pcall是一个C语言函数；因此，Lua5.1不能将其挂起，因为ISO C无法挂起一个C函数并在之后恢复其运行。<br>在Lua5.2及后续版本中，用延续改善了对这个问题的处理。Lua5.2使用长跳转实现了yield，并使用相同的方式实现了错误信息处理。长跳转简单地丢弃了C语言栈中关于C函数的所有信息，因而无法resume这些函数。但是，一个C函数foo可以指定一个延续函数foo_k，该函数也是一个C函数，在要恢复foo的执行时它就会被调用。也就是说，当解释器发现它应该恢复函数foo的执行时，如果长调转已经丢弃了C语言栈中有关foo的信息，则调用foo_k来替代。<br>为了说得更具体些，我们将pcall的实现作为示例。在Lua5.1中，该函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_pcall</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	luaL_checkany(L,<span class="number">1</span>);</span><br><span class="line">	status = lua_pcall(L,lua_gettop(L) - <span class="number">1</span>, LUA_MULTRET,<span class="number">0</span>);</span><br><span class="line">	lua_pushboolean(L,(status == LUA_OK));</span><br><span class="line">	lua_insert(L,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> lua_gettop(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序正在通过lua_pcall被调用的函数yield，那么后面就不能恢复luaB_pcall的执行。因此，如果我们在保护模式的调用下试图yield时，解释器就会抛出异常。Lua5.3使用基本类似于下面示例中的方式实现了pcall。</p>
<blockquote>
<p>使用延续实现pcall</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">finishpcall</span> <span class="params">(lua_State *L, <span class="type">int</span> status, <span class="type">intptr_t</span> ctx)</span>&#123;</span><br><span class="line">	(<span class="type">void</span>)ctx;</span><br><span class="line">	status = (status != LUA_OK &amp;&amp; status != LUA_YIELD);</span><br><span class="line">	lua_pushboolean (L,(status == <span class="number">0</span> ));</span><br><span class="line">	lua_insert(L,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> lua_gettop(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_pcall</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	luaL_checkany(L,<span class="number">1</span>);</span><br><span class="line">	status = lua_pcall(L,lua_gettop(L) - <span class="number">1</span>, LUA_MULTERT,<span class="number">0</span>,<span class="number">0</span>,finishpcall);</span><br><span class="line">	<span class="keyword">return</span> finsihpcall(L,status,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与Lua5.1中的版本相比，上述实现有三个重要的不同点：首先，新版本用lua_pcallk替换了lua_pcall；其次，新版本在调用完lua_pcallk后把完成的状态传给了新的辅助函数finishpcall；第三，lua_pcallk返回的状态除了LUA_OK或者一个错误外，还可以是LUA_YIELD。<br>如果没有发生yield，那么lua_pcallk的行为与lua_pcall的行为完全一样。但是，如果发生yield，情况则大不相同。如果一个被原来lua_pcall调用的函数想要yield，那么Lua5.3会像Lua5.1版本一样引发错误。但当被新的lua_pcallk调用的函数yield时，则不会出现发生错误：Lua会做一个长跳转并且丢弃C语言栈中有关luaB_pcall的元素，但是会在协程软栈中保存传递给函数lua_pcallk的延续函数的引用。后来，当解释器发现应该返回到luaB_pcall时，它就会调用延续函数。<br>当发生错误时，延续函数finishpcall也可能会被调用。与原来的luaB_pcall不同，finishpcall不能获取lua_pcallk所返回的值。因此，finishpcall通过额外的参数status获取这个结果。当没有错误时，status是LUA_YIELD而不是LUA_OK，因此延续函数可以检查它是如何被调用的。当发生错误时，status还是原来的错误码。<br>除了调用的状态，延续函数还接收一个上下文。lua_pcallk的第5个参数是一个任意的整型数，这个参数被当做延续函数的最后一个参数来传递。这个值允许原来的函数直接向延续函数传递某些任意的信息。<br>Lua5.3的延续体系是一种为了支持yield而设计的精巧机制，但它也不是万能的。某些C函数可能会需要它们的延续传递相当多的上下文。例如，table.sort将C语言栈用于递归，而string.gsub则必须跟踪捕获，还要跟踪和一个用于存放部分结果的缓冲区。虽然这些函数能以”yieldbale”的方式重写，但与增加的复杂性和性能损失相比，这样做似乎并不值得。</p>
<h2 id="C模块"><a href="#C模块" class="headerlink" title="C模块"></a>C模块</h2><p>Lua模块就是一个代码段，其中定义了一些Lua函数并将其存储在恰当的地方。为Lua编写的C语言模块可以模仿这种行为。除了C函数的定义外，C模块还必须定义一个特殊的函数，这个特殊的函数相当于Lua库中的主代码段，用于注册模块中所有的C函数，并将它们存储在恰当的地方。与Lua的主代码段一样，这个函数还应该初始化模块中所有需要初始化的其他东西。<br>Lua通过注册过程感知到C函数。一旦一个C函数用Lua表示和存储，Lua就会通过对其地址的直接引用来调用它。换句话说，一旦一个C函数完成注册，Lua调用它时就不再依赖于其函数名、包的位置以及可见性规则。通常，一个C模块中只有一个用于打开库的公共函数；其他所有的函数都是私有的，在C语言中被声明为static。<br>当我们使用C函数来扩展Lua程序时，将代码设计为一个C模块是个不错的想法。因为即使我们现在只想注册一个函数，但迟早总会需要其他的函数。通常，辅助库为这项工作提供了一个辅助函数。宏luaL_newlib接收一个由C函数及其对应函数名组成的数组，并将这些函数注册到一个新表中。举个例子，假设我们要用之前定义的函数l_dir创建一个库。首先，必须定义这库函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_dir</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	同前</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，声明一个数组，这个数组包含了模块中所有的函数及其名称。数组元素的类型为luaL_Reg，该类型是由两个字段组成的结构体，这两个字段分别是函数名和函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">mylib</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;dir&quot;</span>,l_dir&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，只声明了一个函数。数组的最后一个元素永远是是{NULL,NILL}，并以此标识数组的结尾。最后，我们使用函数luaL_newlib声明一个主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaopen_mylib</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	luaL_newlib(L,mylib);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对函数luaL_newlib的调用会新创建一个表，并使用由数组mylib指定的”函数名-函数指针”填充这个新创建的表。当luaL_newlib返回时，它把这个新创建的表留在栈中，在表中它打开了这个库。然后，函数luaopen_mylib返回1，表示将这个表返回给Lua。<br>编写完这个库以后，我们还必须将其链接到解释器。如果Lua解释器支持动态链接的话，那么最简便的方法是使用动态链接机制。在这种情况下，必须将这个库放到C语言路径中的某个地方。在完成了这些步骤后，就可以使用require在Lua中直接加载这个模块了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local mylib = requrire <span class="string">&quot;mylib&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述的语句会将动态库mylib链接到Lua，查找函数luaopen_mylib，将其注册为一个C语言函数，然后调用它以打开模块。<br>动态链接器必须知道函数luaopen_mylib的名字才能找到它。它总是寻找名为”luaopen + 模块名”这样的函数。因此，如果我们的模块名为mylib，那么该函数应该命名为luaopen_mylib。<br>如果解释器不支持动态链接，就必须连同新库一起重新编译Lua语言。除了重新编译，还需要以某种方式告诉独立解释器，它应该在打开一个新状态时打开这个库。一个简答的做法是把luaopen_mylib添加到由lua_openlibs打开的标住库列表中，这个列表位于文件linit.c中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/26/C%E8%AF%AD%E8%A8%80API%E6%80%BB%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/26/C%E8%AF%AD%E8%A8%80API%E6%80%BB%E8%A7%88/" class="post-title-link" itemprop="url">Lua连续教程之C语言API总览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-26 23:21:06" itemprop="dateCreated datePublished" datetime="2020-06-26T23:21:06+08:00">2020-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua是一种嵌入式语言，这就意味着Lua并不是一个独立运行的应用，而是一个库，它可以链接到其他应用程序，将Lua的功能融入这些应用。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>因为能够当作库来扩展某个应用程序，所以Lua是一种嵌入式语言。同时，使用了Lua语言的程序也可以在Lua环境中注册新的函数，比如用C语言实现函数，从而增加一些无法直接用Lua语言编写的功能。因此Lua也是一种可扩展的语言。<br>上述两种对Lua语言的定位分别对应C语言和Lua语言之间的两种交互形式。在第一种形式中，C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。在第二种形式中，Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。应用代码和库代码都适用相同的API与Lua语言通信，这些API被称为C API。<br>C API是一个函数、常量和类型组成的集合，有了它，C语言代码就能与Lua语言交互。C API包括读写Lua全局变量的函数、调用Lua函数的函数、运行Lua代码段的函数，以及注册C函数的函数等。通过调用CAPI，C代码几乎可以做Lua代码能够做的所有事情。<br>CAPI遵循C语言的操作模式，与Lua的操作模式由很大的区别。在使用C语言编程时，我们必须注意类型检查、错误恢复、内存分配错误和其他一些复杂的概念。CAPI中的大多数函数都不会检查其参数的正确性，我们必须在调用函数前确保参数的合法性，一旦出错，程序会直接崩溃而不会收到规范的错误信息。此外，CAPI强调的是灵活性和简洁性，某些情况下会以牺牲易用性为代价，即便是常见的需求，也可能需要调用好几个API。这么做虽然有些繁琐，但我们却可以完全控制所有细节。</p>
<h2 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h2><p>首先来学习一个简单的应用程序的例子：一个独立的解释器。</p>
<blockquote>
<p>一个简单地额独立解释器</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	lua_State *L = luaL_newstate();     <span class="comment">/*打开Lua*/</span></span><br><span class="line">	luaL_openlibs(L);				<span class="comment">/*打开标准库*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buff,<span class="keyword">sizeof</span>(buff),<span class="built_in">stdin</span>)!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">		error = luaL_loadstring(L,buff)||lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(error)&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">			lua_pop(L,<span class="number">1</span>);			<span class="comment">/*从栈中弹出错误信息*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头文件lua.h声明了Lua提供的基础函数，其中包括创建新Lua环境的函数、调用Lua函数的函数、读写环境中的全局变量的函数，以及注册供Lua语言调用新函数的函数等等。lua.h中声明的所有内容都有一个前缀lua_。<br>头文件luaxlib.h声明了辅助库所提供的函数，其中所有的声明均以luaL_开头。辅助库使用lua.h提供的基础API来提供更高层次的抽象，特别是对标准库用到的相关机制进行抽象。基础API追求经济性和正交性，而辅助库则追求对常见任务的实用性。当然，要在程序中创建其他所需的抽象也是非常简单的。请记住，辅助库不能访问Lua的内部元素，而只能通过lua.h中声明的官方基础API完成所有工作。辅助库能实现什么，你的程序就能实现什么。<br>Lua标准库没有定义任何C语言全局变量，它将其所有的状态都保存在动态的结构体lua_State中，Lua中的所有函数都接收一个指向该结构的指针作为参数。这种设计使得Lua是可重入的，并且可以直接用于编程多线程代码。<br>顾名思义，函数luaL_newstate用于创建一个新的Lua状态。当它创建一个新状态时，新环境中没有包含预定义的函数，甚至连print也没有。为了保持Lua语言的精炼，所有的标准库都被组织成不同的包，这样我们在不需要使用某些包时可以忽略它们。头文件lualib.h中声明了用于打开这些库的函数。函数luaL_openlibs用于打开所有的标准库。<br>当创建好一个状态并且在其中加载标准库以后，就可以处理用户的输入了。程序会首先调用函数luaL_loadstring来编译用户输入的每一行内容。如果没有错误，则返回零，并向栈中压入编译后得到的函数。然后，程序调用函数lua_pcall从栈中弹出编译后的函数，并以保护模式运行。与函数lua_loadstring类似，如果没有错误发生，函数lua_pcall则返回零；当发生错误时，这两个函数都会向栈中压入一条错误信息。随后我们可以通过函数lua_tostring获取错误信息，并在打印错误信息后使用函数lua_pop将从栈中删除。<br>在C语言中，真是的错误处理可能会相当复杂，并且如何处理错误取决于应用的性质。Lua核不会直接向任何输出流写入数据，它只会通过返回错误信息来提示错误。每个应用可以用其所需的最恰当的方式来处理这些错误信息。为了简化讨论，假设一下示例使用如下简单的错误处理函数，即打印一条错误信息，关闭Lua状态并结束整个应用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error</span> <span class="params">(lua_State *L,<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>&#123;</span><br><span class="line">	va_list argp;</span><br><span class="line">	va_start(argp,fmt);</span><br><span class="line">	<span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>,fmt,argp);</span><br><span class="line">	va_end(argp);</span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Lua既可以作为C代码来编译，也可以作为C++代码来编译，因此lua.h中并没有包含以下这种在C标准库中的常见的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果将Lua作为C代码编译出来后又要在C++中使用，那么可以引入lua.hpp来替代lua.h，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>Lua和C之间通信的主要组件是无处不在的虚拟栈，几乎所有的API调用都是在操作这个栈中的值，Lua与C之间所有的数据交换都是通过这个栈完成的。此外，还可以利用栈保存中间结果。<br>当我们想在Lua和C之间交换数据时，会面对两个问题：第一个问题是动态类型和静态类型体系之间不匹配；第二个问题是自动内存管理和手动内存管理之间不匹配。<br>在Lua中，如果我们写t[k]&#x3D;v，k和v都可以是几种不同类型；由于元表的存在，甚至t也可以有不同的类型。然而，如果要在C语言中提供这种操作，任意给定的settable函数都必须有一个固定的类型。为了实现这样的操作，我们就需要好几十个不同的函数。<br>可以通过在C语言中声明某种联合体类型来解决这个问题，假设这种类型叫lua_Value，它能够表示Lua语言中所有的值，然后，可以把settable声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_settable</span> <span class="params">(lua_Value a,lua_Value k,lua_Value v)</span>;</span><br></pre></td></tr></table></figure>
<p>这种方法有两个缺点。首先，我们很难将如此复杂的类型映射到其他语言中；而在设计Lua时，我们又要求Lua语言不仅能方便地与C&#x2F;C++交互，而且还能与<code>Java</code>、<code>Fortran</code>、<code>C#</code>等其他语言方便地交互。其次，Lua语言会做垃圾收集：由于Lua预压引擎并不知道Lua中的一个表可能会被保存在一个C语言变量中，因此它可能会认为这个表是垃圾并将其收回。<br>因此，LuaAPI中灭有定义任何类似于lua_Value的类型，而是使用栈在Lua和C之间交换数据。栈中的每个元素都能保存Lua中任意类型的值。当我们想要从Lua中获取一个值时，只需要调用Lua，Lua就会将指定的值压入栈中。当想要将一个值传给Lua时，首先要将这个值压入栈，然后调用Lua将其中栈中弹出即可。尽管我们仍然需要一个不同的函数将每种C语言类型的值压入栈，还需要另一个不同函数从栈中弹出每种C语言类型的值，但是避免了过多的组合。另外，由于这个栈是Lua状态的一部分，因此垃圾收集器知道C语言正在使用哪些值。<br>几乎CAPI中的所有函数都会用到栈。正如第一个示例，函数luaL_loadstring将其结果留在栈中；函数lua_pcall从栈中取出要调用的函数，并且也会将错误消息留在栈中。<br>Lua严格地按照LIFO的规则来操作栈。在调用Lua时只有栈顶部的部分会发生改变，而C语言代码则有更大的自由度。更具体地说，C语言可以检视栈中的任何一个元素，甚至可以在栈的任意位置插入或删除元素。</p>
<h3 id="压入元素"><a href="#压入元素" class="headerlink" title="压入元素"></a>压入元素</h3><p>针对每一种能用C语言直接表示的Lua数据类型，CAPI中都有一个对应的亚栈函数：常量nil使用lua_pushnil；布尔值使用lua_pushboolean;双精度浮点数使用lua_pushnumber；整型使用lua_pushinteger；任意字符串使用lua_pushlstring；以\0终止的字符串使用lua_pushstring。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_pushnil</span>         <span class="params">(lua_State *L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushboolean</span>     <span class="params">(lua_State *L, <span class="type">int</span> <span class="type">bool</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushnumber</span>		 <span class="params">(lua_State *L, lua_Number n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushinteger</span>     <span class="params">(lua_State *L, lua_Integer n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushlstring</span>     <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushstring</span>      <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<p>当然，也有向栈中压入C函数和用户数据的函数。<br>类型Lua_Number相当于Lua语言的浮点数类型，默认为double，但可以在编译时配置Lua，让Lua_Number为float甚至long double。类型lua_Integer相当于Lua语言中的整型，通常被定义为long long ，既有符号64位整型。同样，要把Lua语言中的lua_Integer配置为使用int或long也很容易。如果使用float-int组合，也就是32浮点数类型和整型，即我们所说的精简Lua，对于资源受限的机器和硬件而言，相当高效。<br>Lua语言中的额字符串不是以\0结尾的，它们可以包含任意二进制数据。因此，将字符串压栈的基本函数lua_pushlstring需要一个明确的长度作为参数。对于以\0结尾的字符串，也可以使用函数lua_pushstring，该函数通过strlen来计算字符串的长度。Lua语言不会保留指向外部字符串的指针。对于不得不保留的字符串，Lua要么生成一个内部副本，要么复用已有的字符串。因此，一旦上述函数返回，即使立即释放或修改缓冲区也不会出现问题。<br>无论何时向栈内压入一个元素，我们都应该确保栈中有足够的空间。请注意，现在你是一个C语言程序员，Lua语言不会宠着你。当Lua启动时，以及Lua调用C语言时，栈中至少有20个空闲的位置。对于大多数情况，这个空间是完全够用，所以我们一般无须考虑栈空间的问题。不过，有些任务可能会需要更多的栈空间，特备是循环向栈中压入元素时。在这些情况下，就需要调用哈数lua_checkstack来检查栈中是否有足够的空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lua_checkstack (lua_State *L, <span class="built_in">int</span> sz);</span><br></pre></td></tr></table></figure>
<p>这里，sz是我们所需要的额外栈位置的数量。如果可能，函数lua_checkstack会增加栈的大小，以容纳所需的额外空间；否则，该函数返回零。<br>辅助库也提供了一个高层函数来检查栈空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void luaL_checkstack (lua_State *L, <span class="built_in">int</span> sz, const char *msg);</span><br></pre></td></tr></table></figure>
<p>该函数类似于函数lua_checkstack，但是如果栈空间不能满足请求，该函数会使用指定的错误信息抛出异常，而不是返回错误码。</p>
<h3 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h3><p>CAPI使用索引来引用栈中的元素。第一个被压入栈的元素索引为1，第二个被压入的元素索引为2，依次类推。我们还可以以栈顶为参照，使用负数索引来访问栈中的元素，此时，-1表示栈顶元素，-2表示在它之前被压入栈的元素，依次类推。例如，调用lua_tostring(L,-1)会将栈顶的值作为字符串返回。正如你接下来要看到的，有些情况下从栈底对栈进行索引更加自然，而有些情况下则使用负数索引更好。<br>要检查栈中的一个元素是否为特定的类型，CAPI提供了一系列名为lua_is<em>的函数，其中</em>可以是任意一种Lua数据类型。这些函数包括lua_isnil、lua_isnumber、lua_isstring和lua_istable等。所有这些函数都有同样的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lua_is* (lua_State *L, <span class="type">int</span> index);</span><br></pre></td></tr></table></figure>
<p>实际上，函数lua_isnumber不会检查某个值是否为特定类型，而是检查该值是否能被转换为特定类型。函数lua_isstring与之类似，特别之处在于，它接受数字。<br>还有一个函数lua_type，用于返回栈中元素的类型，每一种类型都由一个对应的常量表示，包括LUA_INIT、LUA_TBOOLEAN、LUA_TUMBER、LUA_TSTRING等。还函数一般与switch语句连用。当需要检查字符串和数值是否存在潜在的强制类型转换时，该函数也同样有用。<br>函数lua_to*用于从栈中获取一个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 				<span class="title function_">lua_toboolean</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> 			*<span class="title function_">lua_tolstring</span><span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">size_t</span> *len)</span>;</span><br><span class="line">lua_State           *<span class="title function_">lua_tothread</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line">lua_Number          <span class="title function_">lua_tonumber</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line">lua_Integer         <span class="title function_">lua_tointeger</span><span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<p>即使指定的元素的类型不正确，调用这些函数也不会有问题。函数lua_toboolean适用于所有类型，它可以按照如下的规则将任意Lua值转换为C的布尔值：nil和false转换为0，所有其他的Lua值转换为1.对于类型不正确的值，函数lua_tolstring和lua_tothread返回NULL。不过，数值相关的函数都无法提示数值的类型错误，因此只能简单地返回0。以前我们需要调用函数lua_isnumber来检查类型，但是Lua5.2引入了如下的新函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_Number      lua_tonumberx(lua_State *L, <span class="built_in">int</span> idx, <span class="built_in">int</span> *isnum)</span><br><span class="line">lua_Integer     lua_tointegerx(lua_State *L,<span class="built_in">int</span> idx, <span class="built_in">int</span> *isnum)</span><br></pre></td></tr></table></figure>
<p>出口参数isnum返回了一个布尔值，来表示Lua值是否被强制转换为期望的类型。<br>函数lua_tolstring返回一个指向该字符串内部副本的指针，并将字符串的长度存入到参数len指定的位置。我们无法修改这个内部副本。Lua语言保证，只要对应的字符串还在栈中，那么这个指针就是有效的。当Lua调用的一个C函数返回时，Lua就会清空栈。因此，作为规则，永远不要指向Lua字符串的指针存放到获取该指针的函数之外。<br>函数lua_tolstring返回的所有字符串在其末尾都会有一个额外的\0，不过这些字符串中也可能会有\0，因此可以通过第三个参数len获取字符串的真实长度。特别的，假设栈顶的值是一个字符串，那么如下推断永远成立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s = lua_tolstring(L, <span class="number">-1</span> ,&amp;len); <span class="comment">/*任意Lua字符串*/</span></span><br><span class="line">assert(s[len] == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">assert(<span class="built_in">strlen</span>(s) &lt;= len);</span><br></pre></td></tr></table></figure>
<p>如果不需要长度信息，可以在调用函数lua_tolstring时将第三个参数设为NULL。不过，使用宏lua_tostring会更好，因此这个宏就是用NULL作为第三个参数来调用函数lua_tolstring的。<br>为了掩饰这些函数的用法，示例提供了一个有用的辅助函数，它输出整个栈的内容。</p>
<blockquote>
<p>对栈进行Dump</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void stackDump(lua_State *L)&#123;</span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="built_in">int</span> top = lua_gettop(L); /*栈的深度*/</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;= top;i++)&#123;</span><br><span class="line">		<span class="built_in">int</span> t = lua_type(L,i);</span><br><span class="line">		switch(t)&#123;</span><br><span class="line">			<span class="keyword">case</span> LUA_TSTRING:&#123;</span><br><span class="line">				printf(<span class="string">&quot;&#x27;%s&#x27;&quot;</span>,lua_tostring(L,i));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> LUA_TBOOLEAN:&#123;</span><br><span class="line">				printf(lua_toboolean(L,i)?<span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> LUA_TUNMBER:&#123;</span><br><span class="line">				printf(<span class="string">&quot;%g&quot;</span>,lua_tonumber(L,i));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			default:&#123;</span><br><span class="line">				printf(<span class="string">&quot;%s&quot;</span>,lua_typename(L,t));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数从栈底向栈顶遍历，并根据每个元素的类型打印其值。它打印字符串时会用单引号将其括起来，对数值类型的值则使用格式”%g”输出，对于其他C语言中不存在等价类型的值则只打印出它们的类型。<br>在Lua5.3中，由于整型总是可以被强制转换为浮点型，因此仍然可以用函数lua_tonumber和”%g”的格式打印所有的数值。但是，我们倾向于将整数打印为整型，以避免损失精度。此时，我们可以用新函数lua_isinteger来区分整型和浮点型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LUA_TNUMBER:&#123;</span><br><span class="line">	<span class="keyword">if</span> (lua_isinteger(L,i))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,lua_tointeger(L,i));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%g&quot;</span>,lua_tonumber(L,i));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他栈操作"><a href="#其他栈操作" class="headerlink" title="其他栈操作"></a>其他栈操作</h3><p>除了上述在C语言和栈之间交换数据的函数外CAPI还提供了下列用于通过栈操作的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lua_gettop</span>			<span class="params">(lua_State *L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_settop</span>         <span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_pushvalue</span>		<span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_rotate</span>			<span class="params">(lua_State *L, <span class="type">int</span> index, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_remove</span>  		<span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_insert</span> 		<span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_replace</span>        <span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lua_copy</span> 			<span class="params">(lua_State *L, <span class="type">int</span> fromidx,<span class="type">int</span> toidx)</span>;</span><br></pre></td></tr></table></figure>
<p>函数lua_gettop返回栈中元素的个数，也即栈顶元素的索引。函数lua_settop将栈顶设置为一个指定的值，即修改栈中的元素数量。如果之前的栈顶比新设置的更高，那么高出来的这些元素就会被丢弃；反之，该函数会向栈中压入nil来不足大小。特别的，函数lua_settop(L,0)用于清空栈。在调用函数lua_settop时也可以使用负数索引；基于这个功能，CAPI提供了下面的宏，用于从栈中弹出n个元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_pop(L,n)  lua_settop(L,-(n) -1)</span></span><br></pre></td></tr></table></figure>
<p>函数lua_pushvalue用于将指定索引上的元素的副本压入栈。<br>函数lua_rotate是Lua5.3中新引入的。顾名思义，该函数将指定索引的元素向栈顶转动n个位置。若n为整数，表示将元素向栈顶方向转动，而n为负数则表示向相反的方向转动。这是一个非常有用的函数，另外两个CAPI操作实际上是基于使用该函数的宏定义的。其中一个是lua_remove，用于删除指定索引的元素，并将该位置上的所有元素下移以填补空缺，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_remove(L,idx) \ (lua_rotate(L,(idx),-1),lua_pop(L,1))</span></span><br></pre></td></tr></table></figure>
<p>也就是说，该函数会将栈顶转动一格，把想要的那个元素移动到栈顶，然后弹出该元素。另一个宏是lua_insert，用于将栈顶元素移动到指定位置，并上移指定位置之上的所有元素以开辟出一个元素的空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_insert(L,inx)    lua_rotate(L,(idx),1)</span></span><br></pre></td></tr></table></figure>
<p>函数lua_replace弹出一个值，并将栈顶设置为指定索引上的值，而不移动任何元素。最后，函数lua_copy将一个索引上的值复制到另一个索引上，并且原值不受影响。请注意，以下的操作不会对空栈产生影响：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lua_settop(L,<span class="number">-1</span>);<span class="comment">/*将栈顶设为当前值*/</span></span><br><span class="line">lua_insert(L,<span class="number">-1</span>);<span class="comment">/*将栈顶的元素移动到栈顶*/</span></span><br><span class="line">lua_copy(L,x,x);<span class="comment">/*把一个元素复制到它当前的位置*/</span></span><br><span class="line">lua_rotate(L,x,<span class="number">0</span>);<span class="comment">/*旋转零个位置*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例 栈操作示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;luaxlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stackDump</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	参见上面那个示例</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	lua_State *L = luaL_newstate();</span><br><span class="line">	lua_pushboolean(L,<span class="number">1</span>);</span><br><span class="line">	lua_pushnumber(L,<span class="number">10</span>);</span><br><span class="line">	lua_pushnil(L);</span><br><span class="line">	lua_pushstring(L,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	stackDump(L):</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; */</span></span><br><span class="line">	lua_pushvalue(L.<span class="number">-4</span>); stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; true */</span></span><br><span class="line">	lua_replace(L,<span class="number">3</span>); stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; */</span></span><br><span class="line">	lua_settop(L,<span class="number">6</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 true &#x27;hello&#x27; nil nil */</span></span><br><span class="line">	lua_rotate(L,<span class="number">3</span>,<span class="number">1</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil true &#x27;hello&#x27; nil */</span></span><br><span class="line">	lua_remove(L,<span class="number">-3</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true 10 nil &#x27;hello&#x27; nil*/</span></span><br><span class="line">	lua_settop(L,<span class="number">-5</span>);stackDump(L);</span><br><span class="line">	<span class="comment">/*将输出：true */</span></span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用CAPI进行错误处理"><a href="#使用CAPI进行错误处理" class="headerlink" title="使用CAPI进行错误处理"></a>使用CAPI进行错误处理</h2><p>Lua中所有的结构都是动态的：它们会按需扩展，并且在可能时最后重新收缩。这意味着在Lua中内存分配失败可能无处不在，几乎所有的操作最终都可能会面临内存分配失败。此外，许多操作可能会抛出异常。例如，访问一个全局变量可能会触发__index元方法，而该元方法又可能会抛出异常。最后，分配内存的操作会触发垃圾收集器，而垃圾收集器又可能会调用同样可能抛出异常的析构器。简而言之，Lua API中的绝大部分函数都可能抛出异常。<br>Lua语言使用异常来提示错误，而没有再API的每个操作中使用错误码。与C++或Java不同，C语言没有提供异常处理机制。为了解决这个问题，Lua使用了C语言中的setjmp机制，setjmp营造了一个类似异常处理的机制。因此，大多数API函数都可以跑出异常而不是直接返回。<br>在编写库代码时，由于Lua会捕获所有异常，因此，对我们来说使用longjmp并不是进行额外的操作。不过，在编写应用程序代码时，则必须提供一种捕获异常的方法。</p>
<h3 id="处理应用代码中的错误"><a href="#处理应用代码中的错误" class="headerlink" title="处理应用代码中的错误"></a>处理应用代码中的错误</h3><p>如果应用调用了Lua API中的函数，就可能发生错误。Lua语言通常通过长跳转来提示错误。但是，如果没有相应的setjmp，解释器就无法进行长跳转。此时，API中的任何错误都会导致Lua调用紧急函数，当这个函数返回后，应用就会退出。我们可以通过函数lua_atpanic来设置自己的紧急函数，但作用不大。<br>要正确地处理应用代码中的错误，就必须通过Lua语言调用我们自己的代码，这样Lua语言才能设置适合的上下文来捕获异常，即在setjmp的上下文中运行代码。类似于通过函数pcall在保护模式中运行Lua代码，我们也可以用函数lua_pcall运行C代码。更具体地说，可以把C代码封装到一个函数F中，然后使用lua_pcall调用这个函数F。通过这种方式，我们的C代码会在保护模式下运行。即便发生内存分配失败，函数lua_pcall也会返回一个对应的错误码，是解释器能够保持一致的状态，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	code to run in protected <span class="title function_">mode</span><span class="params">(要以保护模式运行的代码)</span></span><br><span class="line">	<span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">secure_foo</span><span class="params">(lua_State *L)</span>&#123;</span><br><span class="line">	lua_pushcfunction(L,foo)<span class="comment">/*将foo作为Lua函数压栈*/</span></span><br><span class="line">	<span class="keyword">return</span> (lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，无论发生什么，调用secure_foo时都会返回一个布尔值，来表示foo执行是否成功。特别的，请注意，栈中已经预先分配了空间，而且函数lua_pushcfunction不会分配内存，这样才不会引发错误。</p>
<h3 id="处理库代码中的错误"><a href="#处理库代码中的错误" class="headerlink" title="处理库代码中的错误"></a>处理库代码中的错误</h3><p>Lua是一种安全的语言。这意味着不管用Lua写什么，也不管写出来的内容多么不正确，我们总能用它自身的机制来理解程序的行为。此外，程序中的错误也是通过Lua语言的机制来检测和解释的。与之相比，许多C语言代码中的错误只能从底层硬件的角度来解释。<br>只要往Lua中加入新的C函数，这种安全性就可能被打破。例如，一个等价于BASIC命令poke的函数就可能导致各种各样的内存崩溃。因此，我们必须确保新加入的内容对Lua语言来说是安全的，并提供妥善的错误处理。<br>正如之前讨论的，C语言程序必须通过lua_pcall设置错误处理。不过，在为lua编写库函数时，通常无须处理错误。库函数抛出的错误要么被Lua中的pcall捕获，要么被应用代码中的lua_pcall捕获。因此，当C语言库中的函数检测到错误时，只需要简单地调用lua_error即可。函数lua_error会收拾Lua系统中的残局，然后跳转回保护模式调用处，并传递错误信息。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Lua语言核心对内存分配不进行任何假设，它既不会调用malloc也不会调用realloc来分配内存。相反，Lua语言核心只会通过一个分配函数来分配和释放内存，当用户创建Lua状态时必须提供该函数。<br>luaL_newstate是一个用默认分配函数来创建Lua状态的辅助函数。该默认分配函数使用了来自C语言标准函数库的标准函数malloc-realloc-free，对于大多数应用程序来说，这几个函数够用了。但是，要完全控制Lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的Lua状态即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_State *<span class="title function_">lua_newstate</span><span class="params">(lua_Alloc f, <span class="type">void</span> *ud)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的Lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。<br>分配函数必须满足lua_Alloc的类型声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> * (*lua_Alloc) (<span class="type">void</span> *ud,</span><br><span class="line">							 <span class="type">void</span> *ptr,</span><br><span class="line">							 <span class="type">size_t</span> osize,</span><br><span class="line">							 <span class="type">size_t</span> nsize);</span><br></pre></td></tr></table></figure>
<p>第一个参数始终为lua_newstate所提供的用户数据；第二个参数是正要被分配或者释放的地址；第三个参数是原始块的大小；最后一个参数是请求的块大小。如果ptr不是NULL，Lua会保证其之前被分配的大小就是osize。<br>Lua语言使用NULL表示大小为零的块。当nsize为零时，分配函数必须释放ptr指向的块并返回NULL，对应于所要求的大小的块。当ptr是NULL时，该函数必须分配并返回一个指定大小的块；如果无法分配指定的块，则必须返回NULL。如果ptr是NULL并且nsize为零，则两条规则都适用：最终结果是分配函数什么都不做，返回NULL。<br>最后，当ptr不是NULL并且nsize不为零时，分配函数应该像realloc一样重新分配块并且返回新地址。同样，当出现错误分配函数必须返回NULL。Lua假定分配函数在块的新尺寸小于或等于旧尺寸时不会失败。<br>luaL_newstate使用的标准分配函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">l_alloc</span> <span class="params">(<span class="type">void</span> *ud , <span class="type">void</span> *ptr, <span class="type">size_t</span> osize, <span class="type">size_t</span> nsize)</span>&#123;</span><br><span class="line">	(<span class="type">void</span>)ud; (<span class="type">void</span>)osie;<span class="comment">/*未使用*/</span></span><br><span class="line">	<span class="keyword">if</span>(nsize == <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">free</span>(ptr);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">realloc</span> (ptr,nsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数假设free(NULL)什么也不做，并且realloc(NULL,size)等价于malloc(size)。IOSC标准会托管这两种行为。<br>我们可以通过调用lua_getallocf恢复Lua状态的内存分配器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_Alloc <span class="title function_">lua_getallocf</span> <span class="params">(lua_State *L, <span class="type">void</span> **ud)</span>;</span><br></pre></td></tr></table></figure>
<p>如果ud不是NULL，那么该函数会把*ud设置为该分配器的用户数据。我们可以通过调用lua_setallocf来更改Lua状态的内存分配器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_setallocf</span> <span class="params">(lua_State *L, Lua_Alloc f, <span class="type">void</span> *ud)</span>;</span><br></pre></td></tr></table></figure>
<p>请记住，所有新的分配函数都有责任释放由前一个分配函数分配的块。通常情况下，新的分配函数是在旧分配函数的基础上做了包装，来追踪或同步访问堆的。<br>Lua在内部不会为了重用而缓存空闲内存。它假定分配函数会完成这种缓存工作；而优秀的分配函数确实也会这么做。Lua不会试图压缩内存碎片。研究表明，内存碎片更多是由糟糕的分配决策导致的，而非程序的行为造成的；而优秀的分配函数不会造成太多内存碎片。<br>对于已有的优秀分配函数，想要做到比它更好是很难的，但有时候也不妨试一试。例如，Lua会告诉你已经释放或者重新分配的块的大小。因此，一个特定的分配函数不需要保存有关块大小的信息，以此减少每个块的内存开销。<br>还有一种可以改善的内存分配的场景，是在多线程系统中。这种系统通常需要对内存分配函数进行线程同步，因为这些函数使用的是全局资源。不过，对Lua状态的访问也必须是同步的——或者更好的情况是，限制只有一个线程能够访问Lua状态。如果每个Lua状态都从私有的内存池中分配内存，那么分配函数就可以避免线程同步导致的额外开销了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/07/Lua%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/Lua%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Lua使用协程实现多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-07 17:35:20" itemprop="dateCreated datePublished" datetime="2020-06-07T17:35:20+08:00">2020-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>协程能够实现一种协作式多线程。每个协程都等价于一个线程。一对yield-resume可以将执行权在不同线程之间切换。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>不过，与普通的多线程的不同，协程是非抢占的。当一个协程正在运作时，是无法从外部停止它的。只有当协程显式地要求时它才会挂起执行。对于有些应用而言，这并没有问题，而对于另外一些应用则不行。当不存在抢占时，编程简单得多。由于在程序中所有的线程间同步都是显式的，所以我们无须为线程同步问题抓狂，只需要确保一个协程只在它的临界区之外调用yield即可。</p>
<p>不过，对于非抢占式多线程来说，只要有一个线程调用了阻塞操作，整个程序在该操作完成前都会阻塞。对于很多应用来说，这种行为是无法接受的，而这也正是导致许多程序员不把协程看作传统多线程的一种实现的原因。<br>让我们假设一个典型的多线程的场景：我们希望通过HTTP下载多个远程文件。为了下载多个远程文件，我们必须先知道如何下载一个远程文件。要下载一个文件，必须先打开一个到对应站点的连接，然后发送下载文件的请求，接收文件，最后关闭连接。在Lua语言中，可以按以下步骤来完成这项任务。首先，加载LuaSocket库：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> socket = <span class="built_in">require</span> <span class="string">&quot;socket&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后，定义主机和要下载的文件。在本例中，我们从Lua语言官网下载Lua5.3手册：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">&quot;www.lua.org&quot;</span></span><br><span class="line">file = <span class="string">&quot;/manual/5.3/manual.html&quot;</span></span><br></pre></td></tr></table></figure>
<p>接下来，打开一个TCP连接，连接到站点的80端口：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">assert</span>(socket.connect(host,<span class="number">80</span>))</span><br></pre></td></tr></table></figure>
<p>这步操作返回一个连接对象，可以用它来发送下载文件的请求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> request = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;GET %s HTTP/1.0\r\nhost: %s\r\n\r\n&quot;</span>,file,host)</span><br><span class="line">c:send(request)</span><br></pre></td></tr></table></figure>
<p>接下来，以1KB为一块读取文件，并将每块写入到标准输出中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">	<span class="keyword">local</span> s ,<span class="built_in">status</span>,partial = c:receive(<span class="number">2</span>^<span class="number">10</span>)</span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(s <span class="keyword">or</span> partial)</span><br><span class="line"><span class="keyword">until</span> <span class="built_in">status</span> == <span class="string">&quot;closed&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数receive要么返回它读取到的字符串，要么在发生错误时返回nil外加错误码及出错前读取到的内容。当主机关闭连接时，把输入流中剩余的内容打印出来，然后退出接收循环。<br>下载完文件后，关闭连接：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>既然我们知道了如何下载一个文件，那么再回到下载多个文件的问题上。最简单的做法是逐个地下载文件。不过，这种串行的做法太慢了，它只能在下载完一个文件后再下载一个文件。当读取一个远程文件时，程序把大部分的时间耗费在了等待数据到达上。更确切地说，程序将时间耗费在了对receive的阻塞调用上。因此，如果一个程序能够同时并行下载所有文件的话，就会快很多。当一个连接没有可用数据时，程序便可以从其他连接读取数据。很明显，协程为构造这种并发下载的代码结构提供了一种简单的方式。我们可以为每个下载任务创建一个新线程，当一个线程无可用数据时，它就可以将控制权传递给一个简单的调度器，这个调度器再去调用其他的线程。<br>在用协程重写程序前，我们先把之前下载的代码重写成一个函数。</p>
<blockquote>
<p>示例 下载Web页面的数据</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span> <span class="params">(host,file)</span></span></span><br><span class="line">	<span class="keyword">local</span> c = <span class="built_in">assert</span>(socket.connect(host,<span class="number">80</span>))</span><br><span class="line">	<span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">local</span> request = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;GET %s HTTP/1.0\r\nhost:%s\r\n\r\n&quot;</span>,file,host)</span><br><span class="line">	c:send(request)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> s ,<span class="built_in">status</span> = receive(c)</span><br><span class="line">		count = count + #s</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">status</span> == <span class="string">&quot;closed&quot;</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	c:<span class="built_in">close</span>()</span><br><span class="line">	<span class="built_in">print</span>(file,count)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于我们对远程文件的内容并不感兴趣，所以不需要将文件内容写入到标准输出中，只要计算并输出文件大小即可。<br>在新版本中，我们使用一个辅助函数receiver从连接接收数据。在串行的下载方式中，receive的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(connection)</span></span></span><br><span class="line">	<span class="keyword">local</span> s,<span class="built_in">status</span>,partial = connection:receive(<span class="number">2</span>^<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">return</span> s <span class="keyword">or</span> partial,<span class="built_in">status</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在并行的实现中，这个函数在接收数据时不能阻塞。因此，在没有足够的可用数据时，该函数会挂起，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(connection)</span></span></span><br><span class="line">	connection:settimeout(<span class="number">0</span>) <span class="comment">--不阻塞 </span></span><br><span class="line">	<span class="keyword">local</span> s ,<span class="built_in">status</span>,partial = connection:receive(<span class="number">2</span>^<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">status</span> == <span class="string">&quot;timeout&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(connection)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> s <span class="keyword">or</span> partial,<span class="built_in">status</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用settimeout(0)是的后续所有对连接进行的操作不会则塞。如果返回状态为”timeout”，就表示该操作在返回时还未完成。此时，线程就会挂起。传递给yield的非假参数通知调度器线程仍在执行任务中。请注意，即使在超时的情况下，连接也会返回超时前已读取到的内容，也就是变量partial中的内容。</p>
<blockquote>
<p>示例 调度器</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">tasks = &#123;&#125;			<span class="comment">-- 所有活跃任务的列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span> <span class="params">(host,file)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		download(host,file)</span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(tasks,co)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> <span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> tasks[i] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">if</span> tasks[<span class="number">1</span>] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			i = <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">local</span> res = tasks[i]()</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">table</span>.<span class="built_in">remove</span>(tasks,i)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在tasks为调度器保存着所有正在运行中的线程的列表。函数get保证每个下载任务运行在一个独立的线程中。调度器本身主要就是一个循环，它遍历所有的线程，逐个唤醒它们。调度器还必须在线程完成任务后，将该线程从列表中删除。在所有线程都完成运行后，调度器停止循环。<br>最后，主程序创建所有需要的线程并调起调度器。例如，如果要从Lua官网下载几个发行包，主程序可能如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.3.2.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.3.1.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.3.0.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.2.4.tar.gz&quot;</span>)</span><br><span class="line">get(<span class="string">&quot;www.lua.org&quot;</span>,<span class="string">&quot;/ftp/lua-5.2.3.tar.gz&quot;</span>)</span><br><span class="line">dispatch()</span><br></pre></td></tr></table></figure>
<p>在笔者的机器上，串行实现花了15秒下载到这些文件，而协程实现比串行实现快了三倍多。<br>尽管速度提高了，但最后一种实现还有很大的优化空间。当至少由一个线程有数据可读取时不会有问题；然而，如果所有的线程都没有数据可读，调度程序就会陷入忙等待，不断地从一个线程切换到另一个线程来检查是否有数据可读。这样，会导致协程版的实现比串行版实现耗费多达3倍的CPU时间。<br>为了避免这样的情况，可以使用LuaSocket中的函数select，该函数允许程序阻塞直到一组套接字的状态发生改变。要实现这种改动，只需要修改调度器即可。</p>
<blockquote>
<p>示例 使用select的调度器</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line">	<span class="keyword">local</span> timedout = &#123;&#125;</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> tasks[i] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">if</span> tasks[<span class="number">1</span>] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			i = <span class="number">1</span></span><br><span class="line">			timedout =&#123;&#125;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">local</span> res = tasks[i]()</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">table</span>.<span class="built_in">remove</span>(tasks,i)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">			timeout[#timedout + <span class="number">1</span>] = res</span><br><span class="line">			<span class="keyword">if</span> #timedout == #tasks <span class="keyword">then</span></span><br><span class="line">				socket.<span class="built_in">select</span>(timedout)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在循环中，新的调度器将所有超时的连接收集到表timedout中。请记住，函数receive将这种超时的连接传递给yield，然后由resume返回。如果所有的连接均超时，那么调度器调用select等待这些连接的状态就会发生改变。这个最终的实现与上一个使用协程的实现一样快。另外，由于它不会有忙等待，所以与串行实现耗费的CPU资源一样多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/26/Lua%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/26/Lua%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">Lua连续教程之Lua反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 15:17:09" itemprop="dateCreated datePublished" datetime="2020-05-26T15:17:09+08:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>反射是程序用来检查和修改其自身某些部分的能力。像Lua语言这样的动态语言支持几种反射机制：环境允许运行时观察全局变量；</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>诸如type和pairs这样的函数允许运行时检查和遍历未知数据结构；诸如load和require这样的函数允许程序在自身中追加代码或更新代码。不过，还有很多方面仍然是缺失的：程序不能检查局部变量，开发人员不能跟踪代码的执行，函数也不知道是被谁调用的，等等。调试库填补了上述缺陷。<br>调试库是由两类函数组成：自省函数和钩子。自省函数允许我们检查一个正在运行中的程序的几个方面，例如活动函数的额栈、当前正在执行的代码行、局部变量的名称和值。钩子则允许我们跟踪一个程序的执行。<br>虽然名字里带有”调试“的字眼，但调试库提供的并不是Lua语言的调试器。不过，调试库提供了编写我们自己的调试器所需要的不同层次的所有底层机制。<br>调试库与其他库不同，必须被慎重地使用。首先，调试库中的某些功能的性能不高。其次，调试库会打破语言的一些固有规则，例如不能从一个局部变量的词法定界范围外访问这个局部变量。虽然调试库作为标准库直接可用，但笔者建议在使用调试库的代码段中显示地加载调试库。</p>
<h2 id="自省机制"><a href="#自省机制" class="headerlink" title="自省机制"></a>自省机制</h2><p>调试库中主要的自省函数是getinfo，该函数的第一个参数可以是一个函数或一个栈层次。当为某个函数foo调用debug.getinfo(foo)时，该函数会返回一个包含与该函数有关的一些数据的表。这个表可能具有以下字段：<br>  <strong>source:</strong>  该字段用于说明函数定义的位置。如果函数定义在一个字符串中（通过调用load），那么source就是这个字符串；如果函数定义在一个文件中，那么source就是使用@作为前缀的文件名。<br> <strong>short_src:</strong> 该字段是source的精简版本，对于错误信息十分有用。<br> <strong>linedefined:</strong> 该字段是该函数定义在源代码中第一行的行号。<br>  <strong>lastlinedefined:</strong> 该字段是该函数定义在源代码中最后一行的行号。<br> <strong>what:</strong> 该字段用于说明函数的类型。如果foo是一个普通的Lua函数，则为“Lua”；如果是一个C函数，则为“C”;如果是一个Lua语言代码段的主要部分，则为“main”。<br> <strong>name:</strong> 该字段是该函数的一个适当的名称，例如保存该函数的全局变量的名称。<br> <strong>namewhat:</strong> 该字段用于说明上一个子弹的含义，可能是”global”、”local”、”method”、”filed”或””(空字符串)。空字符串表示Lua原因找不到该函数的名称。<br> <strong>nups:</strong> 该字段是该函数的上值的个数。<br> <strong>nparams:</strong> 该字段是该函数的参数个数。<br> <strong>isvararg:</strong> 该字段表明该函数是否为可变长参数函数。<br> <strong>activelines:</strong> 该字段是一个包含该函数所有活跃行的集合。活跃行时指除空行和只包含注释的外行的其他行。<br> <strong>func:</strong> 该字段是该函数本身。<br> 当foo是一个C函数时，Lua语言没有多少关于该函数的信息。对于这种函数，只有字段what、name、namewhat、nups和func是有意义的。<br>当使用给一个数字n作为参数调用函数debug.getinfo(n)时，可以得到有关相应栈层次上活跃函数的数据。栈层次是一个数字，代表某个时刻上活跃的特定函数。调用getinfo的函数A的层次是1，而调用A的函数的层次是2，以此类推。如果n大于栈中活跃函数的数量，那么函数debug.getinfo返回nil。当通过带有栈层次的debug.getinfo查询一个活跃函数时，返回的表中海油两个额外字段：currentline，表示当前该函数正在执行的代码所在的行；istailcall，如果为真则表示函数是被尾调用所调起。<br>字段name有些特殊。请注意，由于函数在Lua语言中是第一类值，因此函数既可以没有名称也可以有多个名称。Lua语言会通过检查调用该函数的代码来看函数是如何被调用的，进而尝试找到该函数的名称。这种方法只有在以一个数字为参数调用getinfo时才会起作用，即我们只能获取关于某一具体调用的信息。<br>函数getinfo的效率不高。Lua语言以一种不影响程序执行的形式来保存调试信息，至于获取这些调试信息的效率则是次要的。为了实现更好的性能，函数getinfo有一个可选的第二参数，该参数用于指定希望获取哪些信息。通过这个参数，函数getinfo就不会浪费时间去收集用户不需要的数据。这个参数是一个字符串，其中每个字母代表选择一组字段，如下表所示：</p>
<hr>
<p>n 选择name和namewhat<br>f 选择func<br>S 选择source、short_src、what、linedefined和lastlinedefined<br>l 选择currentline<br>L 选择activelines<br>u 选择nup、nparams和isvararg</p>
<hr>
<p>下面这个函数演示了函数debug.getinfo的用法，它打印出了活跃栈的栈回溯：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="built_in">traceback</span>()</span><br><span class="line">	<span class="keyword">for</span> level = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level,<span class="string">&quot;Sl&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span> back <span class="keyword">end</span></span><br><span class="line">		<span class="keyword">if</span> info.what == <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d\tC function&quot;</span>,level))</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d\t[%s]:%d&quot;</span>,level,</span><br><span class="line">				info.short_src, info.currentline))</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>要改进这个函数并不难，只需要让函数getinfo返回更多数据即可。实事上，调试库也提供了这样一个改进版本，即函数traceback。与我们的版本不同的是，函数debug.traceback不会打印结果，而是返回一个包含栈回溯的字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>())</span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">	<span class="built_in">stdin</span>:<span class="number">1</span>:<span class="keyword">in</span> main chunk</span><br><span class="line">	[C]:<span class="keyword">in</span> ?</span><br></pre></td></tr></table></figure>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们可以通过函数debug.getlocal来检查任意活跃函数的局部变量。该函数有两个参数，一个是要查询函数的栈层次，另一个是变量的索引。该函数返回两个值，变量名和变量的当前值。如果变量索引大于活跃变量的数量，那么函数getlocal返回nil。如果栈层次无效，则会抛出异常。<br>Lua语言按局部变量在函数中的出现顺序对它们进行编号，但编号只限于在函数当前作用域中活跃的变量。例如，考虑如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> x </span><br><span class="line">	<span class="keyword">do</span> <span class="keyword">local</span> c = a - b <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> name ,value = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(<span class="number">1</span>,a)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="built_in">print</span>(name , value)</span><br><span class="line">		a = a + <span class="number">1</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用foo(10,20)会输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a	<span class="number">10</span></span><br><span class="line">b 	<span class="number">20</span></span><br><span class="line">x 	<span class="literal">nil</span></span><br><span class="line">a 	<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>索引为1的变量a，索引为2的变量b，索引为3的变量是x，索引为4的变量时内层的a。在getlocal被调用的时候，c已经完成了作用域，而name和value还未出现于作用域。<br>从Lua5.2开始，值为负的索引获取可变长参数函数的额外参数，索引-1指向第一个额外参数。此时，变量的名称永远是”(*vararg)”。<br>我们还可以通过函数debug.setlocal改变局部变量的值，该函数的前两个参数与getlocal相同，分别是栈层次和变量索引，而第三个参数是该局部变量的新值。该函数的返回值是变量名，如果变量索引超出了范围则返回nil。</p>
<h3 id="访问非局部变量"><a href="#访问非局部变量" class="headerlink" title="访问非局部变量"></a>访问非局部变量</h3><p>测试库还提供了函数getupvalue，该函数允许我们访问一个被Lua函数所使用的非局部变量。与局部变量不同，被一个函数所引用的非局部变量即使在引用它的函数已经不活跃的情况下也会一直存在。因此，函数getupvalue的第一个参数不是栈层次，而是一个函数。函数getupvalue的第二个参数是变量索引，Lua语言按照函数引用非局部变量的顺序对它们编号，但由于一个函数不能用同一个名称访问两个非局部变量，所以这个顺序是无关紧要的。<br>我们还可以通过函数debug.setupvalue更新非局部变量的值。就像读者可能预想的一样，该函数有三个参数：一个闭包、一个变量索引和一个新值。与函数setlocal一样，该函数返回变量名，如果索引超出范围则返回nil。</p>
<blockquote>
<p>示例 获取变量的值</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getvarvalue</span><span class="params">(name,level,isenv)</span></span></span><br><span class="line">	<span class="keyword">local</span> value</span><br><span class="line">	<span class="keyword">local</span> found = <span class="literal">false</span></span><br><span class="line">	level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">	<span class="comment">--尝试局部变量</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> , <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">		lcoal n, v = <span class="built_in">debug</span>,<span class="built_in">getlocal</span> (level,i)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">			value = v</span><br><span class="line">			found = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;local&quot;</span>, value <span class="keyword">end</span></span><br><span class="line">	<span class="comment">--尝试非局部变量</span></span><br><span class="line">	<span class="keyword">local</span> fun = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level,<span class="string">&quot;f&quot;</span>).func</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> n,v = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(func,i)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="keyword">if</span> n == name <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;upvalue&quot;</span>, v <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">if</span> isenv <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span> <span class="keyword">end</span>	<span class="comment">--避免循环</span></span><br><span class="line">	<span class="comment">--没找到；从环境中获取值</span></span><br><span class="line">	<span class="keyword">local</span> _, env = getvarvalue(<span class="string">&quot;_ENV&quot;</span>,level,<span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> env <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;global&quot;</span> , env[name]</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>用法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">local</span> a = <span class="number">4</span>; <span class="built_in">print</span>(getvarvalue(<span class="string">&quot;a&quot;</span>))		<span class="comment">-- local 4</span></span><br><span class="line">&gt; a = <span class="string">&quot;xx&quot;</span>;<span class="built_in">print</span>(getvarvalue(<span class="string">&quot;a&quot;</span>))			<span class="comment">-- global xx</span></span><br></pre></td></tr></table></figure>
<p>参数level指明在那个栈层次中寻找函数，1意味着直接的调用者。代码中多加1将层次纠正为包括getvarvalue自己。<br>该函数首先查找局部变量。如果有多个局部变量的名称与给定的名称相同，则获取具有最大索引的那个局部变量。因此，函数必须执行完整个循环。如果找不到指定名称的局部变量，那么就查找非局部变量。为了遍历非局部变量，该函数使用debug.getinfo函数获取调用闭包，然后遍历非局部变量。最后，如果还是找不到指定名字的非局部变量，就检索全局变量：该函数递归地调用自己来访问合适的_ENV变量并在相应环境中查找指定的名字。<br>参数isenv避免了一个诡异的问题。该参数用于说明我们是否处于一个从_ENV变量中查询全局名称的递归调用中。一个不使用全局变量的函数可能没有上值_ENV。在这种情况下，如果我们试图把_ENV当做全局变量来查询，那么由于我们需要_ENV来得到其自身的值，所以可能会陷入无限递归循环。因此，当isenv为真且函数getvarvalue找不到局部变量或上值时，getvarvalue就不应该再尝试全局变量。</p>
<h3 id="访问其他协程"><a href="#访问其他协程" class="headerlink" title="访问其他协程"></a>访问其他协程</h3><p>调试库中的所有自省函数都能够接受一个可选的协程作为第一个参数，这样就可以从外部来检查这个协程。例如，考虑使用如下的示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> x = <span class="number">10</span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">	<span class="built_in">error</span>(<span class="string">&quot;some error&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>(co))</span><br></pre></td></tr></table></figure>
<p>对函数traceback的调用作用在协程co上，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack traceback:</span><br><span class="line">	[C]:in function &#x27;yield&#x27;</span><br><span class="line">	temp:3:in function &lt;temp:1&gt;</span><br></pre></td></tr></table></figure>
<p>由于协程和主程序运行在不同的栈上，所以回溯没有跟踪到对函数resume的调用。<br>当协程引发错误时并不会进行栈展开，这就意味着可以在错误发生后检查错误。继续上面的示例，如果再次唤醒协程，它会提示引起了一个错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))		<span class="comment">-- false temp:4:some error</span></span><br></pre></td></tr></table></figure>
<p>现在，如果输出栈回溯，会得到这样的结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">	[C]:<span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &#x27;<span class="title">error</span>&#x27;</span></span><br><span class="line"><span class="function">	<span class="title">temp</span>:4:<span class="title">in</span> <span class="title">function</span> &lt;<span class="title">temp</span>:1&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使在错误发生后，也可以检查协程中的局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">getlocal</span>(co,<span class="number">1</span>,<span class="number">1</span>))		<span class="comment">-- x 10</span></span><br></pre></td></tr></table></figure>

<h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><p>调试库中的钩子机制允许用户注册一个钩子函数，这个钩子函数会在程序运行中某个特定事件发生时被调用。有四种时间能够触发一个钩子：</p>
<ul>
<li>每当调用一个函数时产生的call事件；</li>
<li>每当函数返回时产生的return事件；</li>
<li>每当开始执行一行新代码时产生的line事件；</li>
<li>执行完制定数量的指令后产生的count事件。<br>Lua语言用给一个描述导致钩子函数被调用的事件的字符串为参数来调用钩子函数，包括”call”、”return”、”line”或”count”。对于line事件来说，还有第二个参数，即新行号。我们可以在钩子函数内部调用函数debug.getinfo来获取更多的信息。<br>要注册一个钩子，需要用两个或三个参数来调用函数debug.sethook:第一个参数是钩子函数，第二个参数是描述要监控事件的掩码字符串，第三个参数是一个用于描述以何种频度获取count事件的可选数字。如果要监控call、return和line事件，那么需要把这几个事件的首字母放入掩码字符串。如果要监控count事件，则只需要在第三个参数中指定一个计数器。如果要关闭钩子，只需不带任何参数第调用函数sethook即可。<br>作为一个简单的示例，以下代码安装了一个简单的跟踪器，它会输出解释器执行的每一行代码：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(<span class="built_in">print</span>,<span class="string">&quot;l&quot;</span>)</span><br></pre></td></tr></table></figure>
这句调用只是简单地把函数print安装为一个钩子函数，并告诉Lua语言在line事件发生时调用它。一个更精巧的跟踪器可以使用函数getinfo获取当前文件名并添加到输出中：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span><span class="params">(event,line)</span></span></span><br><span class="line">	<span class="keyword">local</span> s = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>).short_src</span><br><span class="line">	<span class="built_in">print</span>(s .. <span class="string">&quot;:&quot;</span> .. line)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(trace,<span class="string">&quot;l&quot;</span>)</span><br></pre></td></tr></table></figure>
与钩子一起被使用的一个很有用的函数debug.debug。这个简单的函数可以提供一个能够执行任意Lua语言命令的提示符，其等价于如下的代码：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debug1</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;debug&gt; &quot;</span>)</span><br><span class="line">		<span class="keyword">local</span> line = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;cont&quot;</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		<span class="built_in">assert</span>(<span class="built_in">load</span>(line))()</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
当用户输入”命令“cont时，函数返回。这种标准的实现十分简单，并且在全局环境中运行命令，位于正在被调试代码的定界范围之外。</li>
</ul>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>除了调试，反射的另外一个常见用法是用于调优，即程序使用资源的行为分析。对于时间相关的调优，最好使用C接口，因为每次钩子调用函数开销太大从而可能导致测试结果无效。不过，对于计数性质的调优，Lua代码就可以做得很好。<br>性能调优工具的主要数据结构是两个表，其中一个表将函数和它们的调用计数关联起来，另一个表关联函数和函数名。这两个表的索引都是函数自身：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Counters = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> Names = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在性能分析完成后再获取函数的名称，但是如果能在一个函数F处于活动状态时获取其名称可能会得到更好的结果。这是因为，在函数F处于活动状态时，Lua语言可以通过分析正在调用函数F的代码来找出函数F的名称。<br>现在，我们定义一个钩子函数，该钩子函数的任务是获取当前正在被调用的函数，并递增相应的计数器，再收集函数名。</p>
<blockquote>
<p>示例 用于计算调用次数的钩子</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> f = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;f&quot;</span>).func </span><br><span class="line">	<span class="keyword">local</span> count = Counters[f]</span><br><span class="line">	<span class="keyword">if</span> count == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">		Counters[f] = <span class="number">1</span></span><br><span class="line">		Names[f] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;Sn&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		Counters[f] = count + <span class="number">1</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>接下来，运行带有钩子的程序。假设我们要分析的程序位于一个文件中，且用户通过参数把该文件名传递个性能分析器，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% lua profile main-prog</span><br></pre></td></tr></table></figure>
<p>这样，性能分析器就可以从arg[1]中得到文件名、设置钩子并运行文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(<span class="built_in">arg</span>[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook,<span class="string">&quot;c&quot;</span>)</span><br><span class="line">f()</span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>()</span><br></pre></td></tr></table></figure>
<p>最后一步是显示结果。</p>
<blockquote>
<p>示例  获取一个函数的函数名</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getname</span> <span class="params">(func)</span></span></span><br><span class="line">	<span class="keyword">local</span> n = Names[func]</span><br><span class="line">	<span class="keyword">if</span> n.what == <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> n.name </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> lc = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;[%s]:%d&quot;</span>,n.short_src, n.linedefined)</span><br><span class="line">	<span class="keyword">if</span> n.what ~= <span class="string">&quot;main&quot;</span> <span class="keyword">and</span> n.namewhat ~= <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)&quot;</span>,lc, n.name)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> lc</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有Lua语言中的函数名不是特别确定，所以我们给每个函数再加上位置信息，以file:file这样的形式给出。如果一个函数没有名称，那么就只使用它的位置。如果函数是C函数，那么就只使用它的名称（因为没有位置）。在上述函数定义后，我们输出每个函数及其计数器的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> func,count <span class="keyword">in</span> <span class="built_in">pairs</span>(Counters) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(getname(func),count)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><p>由于Lua语言通过库函数完成所有与外部世界的通信，因此一旦移除了这些函数也就排除了一个脚本能够影响外部环境的可能。不过尽管如此，我们仍然可能会被消耗大量CPU时间或内存的脚本进行拒绝服务Dos攻击。反射，以调试钩子的形式，提供了一种避免这种攻击的有趣方式。<br>首先，我们使用count时间钩子来限制一段代码能够执行的指令数。</p>
<blockquote>
<p>示例  一个使用钩子的简单沙盒</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">local</span> steplimit = <span class="number">1000</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setp</span><span class="params">()</span></span></span><br><span class="line">	count = count + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; steplimit <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;script uses too much CPU&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(<span class="built_in">arg</span>[<span class="number">1</span>],<span class="string">&quot;t&quot;</span>,&#123;&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">sethook</span>(step,<span class="string">&quot;&quot;</span>,<span class="number">100</span>)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>这个程序加载了指定的文件，设置了钩子，然后运行文件。该程序把钩子设置为监听count事件，使得Lua语言每执行100条执行就调用一次钩子函数。钩子只是递增一个计数器，然后检查其是否超过了某个固定的限制。这样做之后还会有问题么？<br>当然有问题。我们还必须限制所加载的代码段的大小：一段很长的代码只要被加载就可能消耗尽内存。另一个问题是，程序可以通过少量指令消耗大量的内存。例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="string">&quot;123456789012345&quot;</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">36</span> <span class="keyword">do</span> s = s .. s <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述的几行代码用不到150行的指令就试图创建一个1字节的字符串。显然，单纯限制指令数量和程序大小是不够的。<br>一种改进是检查和限制函数step使用的内存。</p>
<blockquote>
<p>示例  控制内存使用</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最大能够使用的内存（单位 KB）</span></span><br><span class="line"><span class="keyword">local</span> memlimit = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最大能够执行的&quot;steps&quot;</span></span><br><span class="line"><span class="keyword">local</span> steplimit = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">checkmem</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>) &gt; memlimit <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;script uses too much memory&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">step</span><span class="params">()</span></span></span><br><span class="line">	checkmem()</span><br><span class="line">	count = count + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; steplimit <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;script uses too much CPU&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于通过少量指令就可以消耗很多内存，所以我们应该设置一个很低的限制或以很小的步进来调用钩子函数。更具体地说，一个程序用40行以内的指令就能把一个字符串的大小增加上千倍。因此，我们要么以比40条指令更高的频率调用钩子，要么把内存限制设为我们能够承受的最大值的一千分之一。<br>一个微妙的问题是字符串标准库。我们可以对字符串调用该库中的所有函数。因此，即使环境中没有这些函数，我们也可以调用它们：字符串常量把它们“走私”到了我们的沙盒中。字符串标准库中没有函数能够影响外部世界，但是它们绕过了我们的指令计数器。字符串标准库中的有些函数对于DoS攻击而言可能会非常危险。</p>
<blockquote>
<p>示例 使用钩子阻止对未授权函数的访问</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> steplimit = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> validfunc = &#123;</span><br><span class="line">	[<span class="built_in">string</span>.<span class="built_in">upper</span>] = <span class="literal">true</span>,</span><br><span class="line">	[<span class="built_in">string</span>.<span class="built_in">lower</span>] = <span class="literal">true</span>,</span><br><span class="line">	... <span class="comment">-- 其他授权的函数</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span><span class="params">(event)</span></span></span><br><span class="line"> 	<span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span></span><br><span class="line"> 		<span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;fn&quot;</span>)</span><br><span class="line"> 		<span class="keyword">if</span> <span class="keyword">not</span> validfunc[info.func] <span class="keyword">then</span></span><br><span class="line"> 			<span class="built_in">error</span>(<span class="string">&quot;calling bad function :&quot;</span> .. (info.name <span class="keyword">or</span> <span class="string">&quot;?&quot;</span>))</span><br><span class="line"> 		<span class="keyword">end</span></span><br><span class="line"> 	<span class="keyword">end</span></span><br><span class="line"> 	count = count + <span class="number">1</span></span><br><span class="line"> 	<span class="keyword">if</span> count &gt; steplimit <span class="keyword">then</span></span><br><span class="line"> 		<span class="built_in">error</span>(<span class="string">&quot;script uses too much CPU&quot;</span>)</span><br><span class="line"> 	<span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 加载代码段</span></span><br><span class="line"> <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(<span class="built_in">arg</span>[<span class="number">1</span>],<span class="string">&quot;t&quot;</span>,&#123;&#125;))</span><br><span class="line"> <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook,<span class="string">&quot;&quot;</span>,<span class="number">100</span>)</span><br><span class="line"> f()</span><br></pre></td></tr></table></figure>
<p>在上述代码中，表validfunc表示一个包含程序所能够调用的函数的集合。函数hook使用调试库来访问正在被调用的函数，然后检查函数是否在集合validfunc中。<br>对于任何一种沙盒的实现而言，很重要的一点是沙盒内允许使用哪些函数。用于数据描述的沙盒可以限制所有或大部分函数；其他的沙盒则需要更加宽容，也许应该对某些函数提供它们自己带限制的实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/17/Lua%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/17/Lua%E5%8D%8F%E7%A8%8B/" class="post-title-link" itemprop="url">Lua协程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-17 14:22:53" itemprop="dateCreated datePublished" datetime="2020-05-17T14:22:53+08:00">2020-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>协程可以颠倒调用者和被调用者的关系，而且这种灵活性解决了软件架构中被称为“谁是老大”或者”谁拥有主循环“的问题。这正是对诸如事件驱动编程、通过构造器构建迭代器和协作式多线程等几个看上去并不相关的问题的泛化，而协程以简单和高效的方式解决了这些问题。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>从多线程的角度看，协程与线程类似：协程是一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享了全局变量和其他几乎一切资源。线程与协程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程却需要彼此协作地运行，即在任意指定的时刻只能有一个协程运行。且只有当正在运行的协程显式地要求被挂起时其执行才会暂停。</p>
<h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><p>Lua语言中协程相关的所有函数都被放在表coroutine中。函数create用于创建新协程，该函数只有一个参数，即协程要执行的代码的函数。函数create返回一个”thread”类型的值，即新协程。通常，函数create的参数是一个匿名函数，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span><span class="built_in">print</span>(<span class="string">&quot;hi&quot;</span>)<span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co))			<span class="comment">-- thread</span></span><br></pre></td></tr></table></figure>
<p>一个协程有以下四种状态，即挂起、运行、正常和死亡。我们可以通过函数coroutine.status来检查协程的状态：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.statye(co))		<span class="comment">-- suspended</span></span><br></pre></td></tr></table></figure>
<p>如果在交互模式下运行上述代码，最好在最后一行加上一个分号来阻止输出函数resume的返回值。在上例中，协程体只是简单地打印了”hi”后便终止了，然后协程就编程了死亡状态：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co)) <span class="comment">-- end</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，协程看上去也就是一种复杂的调用函数的方式。协程的真正强大之处在于函数yield，函数可以让一个运行中的协程挂起自己，然后在后续恢复运行。例如下面这个简单示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>,i)</span><br><span class="line">		<span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>其中，协程进行了一个循环，在循环中输出数字并在每次打印后挂起。当唤醒协程后，它就会开始执行直到遇见第一个yield:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 	1</span></span><br></pre></td></tr></table></figure>
<p>此时，如果我们查看协程状态，会发现协程处于挂起状态，因此可以再次恢复运行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))			<span class="comment">-- suspended</span></span><br></pre></td></tr></table></figure>
<p>从协程的角度看，在挂起期间发生的活动都发生协程调用yield期间。当我们唤醒协程时，函数yield才会最终返回，然后协程会继续执行直到遇到下一个yield或执行结束：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 2</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 3</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 10</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- 不输出任何数据</span></span><br></pre></td></tr></table></figure>
<p>在最后一次调用resume时，协程体执行完毕并返回，比输出任何数据。如果我们试图再次唤醒它，函数resume将返回false及一条错误信息：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))</span><br><span class="line"><span class="comment">-- false cannot resume dead coroutine</span></span><br></pre></td></tr></table></figure>
<p>请注意，像函数pcall一样，函数resume也运行在保护模式中。因此，如果协程在执行中出错，Lua语言不会显示错误信息，而是将错误信息返回给函数resume。<br>当协程A唤醒协程B时，协程A既不是挂起状态，也不是运行状态。所以，协程A此时的状态就被称为正常状态。<br>Lua语言中一个非常有用的机制是通过一对resume-yield来交换数据。第一个resume函数会把所有的额外参数传递给协程的主函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a,b,c)</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>,a,b,c+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)		<span class="comment">-- co  1 2 5</span></span><br></pre></td></tr></table></figure>
<p>在函数coroutine.resume的返回值中，第一个返回值为true时表示没有错误，之后的返回值对应函数yield的参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+b,a-b)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">20</span>,<span class="number">10</span>))		<span class="comment">-- true 30 10</span></span><br></pre></td></tr></table></figure>
<p>与之对应的是，函数 coroutine.yield的返回值是对应的resume的参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;co1&quot;</span>,x)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;co2&quot;</span>,<span class="built_in">coroutine</span>.<span class="built_in">yield</span>())</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="string">&quot;hi&quot;</span>)		<span class="comment">-- co1 hi</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">4</span>,<span class="number">5</span>)		<span class="comment">-- co2 4 5</span></span><br></pre></td></tr></table></figure>
<p>最后，当一个协程运行结束时，主函数所返回的值都将变成对应函数resume的返回值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span>,<span class="number">7</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))		<span class="comment">-- true 6,7</span></span><br></pre></td></tr></table></figure>
<p>我们很少在同一个协程中用到所有这些机制，但每种机制都有各自的用处。<br>虽然协程的概念很容易理解，但涉及的细节其实有很多。因此，对于那些已经对协程有一定了解的读者来首，有必要再进行进一步学习前先理清一些细节。Lua语言提供的是所谓的非对称协程，也就是说需要两个函数来控制协程的执行，一个用于挂起协程的执行，另外一个用于恢复协程的执行。而其他一些语言提供的是对称协程，只提供一个函数用于在一个协程和另一个协程之间切换控制权。<br>一些人将非对称协程称为semi-coroutines。然而，其他人则用相同的术语半协程表示协程的一种受限制版实现。在这种实现中，一个协程只能在它没有调用其他函数时才可以挂起，即在调用栈中没有挂起的调用时。换句话说，只有这种半协程的主函数才能让出执行权。</p>
<h2 id="哪个协程占据主循环"><a href="#哪个协程占据主循环" class="headerlink" title="哪个协程占据主循环"></a>哪个协程占据主循环</h2><p>有关协程的最经典实例之一就是生产者-消费者问题。在生产者-消费者问题中设计两个函数，一个函数不断产生值，另一个函数不断地消费这些值。这两个函数可能形式如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()		<span class="comment">-- 产生新值</span></span><br><span class="line">		send(x)					<span class="comment">-- 发给消费者</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(  )</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> x = receive()		<span class="comment">-- 接收来自生产者的值</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(x,<span class="string">&quot;\n&quot;</span>)		<span class="comment">-- 消费 </span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>为了简化这个示例，生产者和消费者都是无限循环的；不过，可以很容易地将其修改为没有数据需要处理时退出循环。这里的问题在于如何将send与receive匹配起来，也就是”谁占据主循环“问题的典型示例。其中，生产者和消费者都处于活跃状态，它们各自具有自己的循环，并且都将对方视为一个可调用的服务。对于这个特定的示例，可以很容易地修改其中一个函数的结构，展开它的循环使其成为一个被动的代理。不过，在其他的真实场景下，这样的代码结构改动可能会很不容易。<br>由于成对的resume-yield可以颠倒调用者与被调用者之间的关系，因此协程提供了一种无须修改生产者和消费者的代码结构就能匹配它们执行顺序的理想工具。当一个协程调用函数yield时，它不是进入了一个新函数，而是返回一个挂起的调用。同样地，对函数resume的调用也不会启动一个新函数，而是返回一个对函数yield的调用。这种特性正好可以用于匹配send和receive,使得双方都认为自己是主动方而对方是被动方。因此，receive唤醒生产者的执行使其能生成一个新值，然后send则让出执行权，将生成的值传递给消费者：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">status</span>, value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(producer)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当然，生产者现在必须运行在一个协程里：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer - <span class="built_in">coroutine</span>.<span class="built_in">create</span>(producer)</span><br></pre></td></tr></table></figure>
<p>在这种设计中，程序通过调用消费者启动。当消费者需要新值时就唤醒生产者，生产者向消费者返回新值后挂起，直到消费者再次将其唤醒。因此，我们将这种设计称为消费者驱动式的设计。另一种方式则是使用生产者驱动式的设计，其中消费者是协程。虽然上述两种设计思路看上去是相反的，但实际上它们的整体思路相同。<br>我们可以使用过滤器来扩展上述设计。过滤器位于生产者和消费者之间，用于完成一些对数据进行某种变换的任务。过滤器即是一个消费者又是一个生产者，它通过唤醒一个生产者来获得新值，然后又将变换后的值传递给消费者。例如，我们可以在前面代码中添加一个过滤器以实现在每行的起始处插入行号：</p>
<blockquote>
<p>示例  使用过滤器的生产者和消费者</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(prod)</span></span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">status</span>, value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(prod)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">local</span>  x = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">			send(x)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">(prod)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">for</span> line = <span class="number">1</span>,<span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">local</span> x = receive(prod)</span><br><span class="line">			x = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%5d %s&quot;</span>,line,x)</span><br><span class="line">			send(x)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(prod)</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> x = receive(prod)</span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(x,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">consumer(filter(producer()))</span><br></pre></td></tr></table></figure>
<p>代码的最后一行只是简单地创建出所需的各个组件，将这些组件连接在一起，然后启动消费者。</p>
<h2 id="将协程用作迭代器"><a href="#将协程用作迭代器" class="headerlink" title="将协程用作迭代器"></a>将协程用作迭代器</h2><p>我们可以讲循环迭代器视为生产者-消费者模式的一种特例：一个迭代器会生产由循环体消费的内容。因此，用协程来实现迭代器看上去就很合适。的确。协程为实现这类任务提供了一种强大的工具。同时，协程最关键的特行是能够颠倒调用者与被调用者之间的关系。有了这种特性，我们在编写迭代器时就无须担心如何保存连续调用之间的状态了。<br>为了说明这类用途，让我们编写一个遍历指定数组所有排列的迭代器。要直接编写这种迭代器并不容易，但如果要编写一个递归函数来产生所有的排列则不是很难。思路很简单，只要依次将每个数组元素放到最后一个位置，然后递归地生成其余元素的所有排列即可。</p>
<blockquote>
<p>示例 一个生成排列的函数</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span><span class="params">(a,n)</span></span></span><br><span class="line">	n = n <span class="keyword">or</span> #a</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">		printResult(a)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span>, n <span class="keyword">do</span></span><br><span class="line">			a[n],a[i] = a[i], a[n]</span><br><span class="line">			permgen(a,n<span class="number">-1</span>)</span><br><span class="line">			a[n],a[i] = a[i], a[n]</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还需要定义一个合适的函数printResult来输出结果，并使用恰当的参数调用premgen</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printResult</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span> <span class="built_in">io</span>.<span class="built_in">write</span>(a[i],<span class="string">&quot;&quot;</span>) <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">permgen(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment">--	2 3 4 1</span></span><br><span class="line"><span class="comment">--  3 2 4 1</span></span><br><span class="line"><span class="comment">--  3 4 2 1</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">--  2 1 3 4</span></span><br><span class="line"><span class="comment">--  1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>当有了生成器之后，将其转换为迭代器就很容易了。首先，我们把printResult改为yield:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span><span class="params">(a,n)</span></span></span><br><span class="line">	n = n <span class="keyword">or</span> #a</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		同前</span><br></pre></td></tr></table></figure>
<p>然后，我们定义一个将生成器放入协程运行并创建迭代函数的工厂。迭代器只是简单地唤醒协程，让其生产下一个排列：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permutations</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>permgen(a) <span class="keyword">end</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">local</span> code ,res = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有了上面的这些，在for循环中遍历一个数组的所有排列就非常简单了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> permutations&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125; <span class="keyword">do</span></span><br><span class="line">	printResult(p)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--	b c a</span></span><br><span class="line"><span class="comment">--	c b a</span></span><br><span class="line"><span class="comment">--	c a b</span></span><br><span class="line"><span class="comment">--	a c b</span></span><br><span class="line"><span class="comment">-- 	b a c </span></span><br><span class="line"><span class="comment">--	a b c</span></span><br></pre></td></tr></table></figure>
<p>函数permutations使用了Lua语言中一种常见的模式，就是唤醒对应协程的调用包装在一个函数中。由于这种模式比较常见，所以Lua语言专门提供了一种特殊的函数coroutine.wrap来完成这个功能。与函数create类似，函数wrap也用来创建一个新的协程。但不同的是，函数wrap返回的不是协程本身而是一个函数，当这个函数被调用时会唤醒协程。与原始的函数resume不同，该函数的第一个返回值不是错误代码，当遇到错误时该函数会抛出异常，我们可以使用函数wrap改写permutations:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permutations</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> permgen(a) <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>通常，函数coroutine.wrap比函数coroutine.create更易于使用。它为我们提供了对于操作协程而言所需的功能，即一个唤醒协程的函数。不过，该函数缺乏灵活性。我们无法检查通过函数wrap所创建的协程的状态，也无法检查运行的异常。</p>
<h2 id="事件驱动式编程"><a href="#事件驱动式编程" class="headerlink" title="事件驱动式编程"></a>事件驱动式编程</h2><p>虽然第一眼看上去不是特别明显，但实际上传统的时间驱动编程伴随的典型问题就是衍生自who-is-the-boss问题。<br>在典型的事件驱动平台下，一个外部的实体向我们程序中所谓的事件循环或运行循环生成事件。这里，我们的代码很明显不是主循环。我们的程序变成了事件循环的附属品，使得我们的程序成为了一组无须任何显式关联的、相互独立的事件处理程序的集合。<br>再举一个更加具体的例子，假设有一个与libuv类似的异步I&#x2F;O库，该库中有四个与我们的示例有关的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lib.runloop();</span><br><span class="line">lib.readline(stream,callback);</span><br><span class="line">lib.writeline(stream,line,callback);</span><br><span class="line">lib.stop();</span><br></pre></td></tr></table></figure>
<p>第一个函数运行事件循环，在其中处理所有发生的事件并调用对应的回调函数。一个典型的事件驱动程序初始化某些机制然后调用这个函数，这个函数就变成了应用的主循环。第二个函数指示库从指定的流中读取一行，并在读取完成后带着读取的结果调用指定的回调函数。第三个函数与第二个函数类似，只是该函数写入一行。最后一个函数打破事件循环，通常用于结束程序。</p>
<blockquote>
<p>示例 异步I&#x2F;O库的简单实现</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cmdQueue = &#123;&#125;		<span class="comment">-- 挂起操作的队列</span></span><br><span class="line"><span class="keyword">local</span> lib = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.readline</span> <span class="params">(stream,callback)</span></span></span><br><span class="line">	<span class="keyword">local</span> nextCmd = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		callback(stream:<span class="built_in">read</span>())</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(cmdQueue,nextCmd)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.writeline</span><span class="params">(stream,line,callback)</span></span></span><br><span class="line">	<span class="keyword">local</span> nextCmd = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		callback(stream:<span class="built_in">write</span>(line))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(cmdQueue,nextCmd)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.stop</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(cmdQueue,<span class="string">&quot;stop&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.runloop</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> nextCmd = <span class="built_in">table</span>.<span class="built_in">remove</span>(cmdQueue,<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> nextCmd == <span class="string">&quot;stop&quot;</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nextCmd()</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> lib</span><br></pre></td></tr></table></figure>
<p>上述代码是一种简单而丑陋的实现。该程序的”事件队列“实际上是一个由挂起操作组成的列表，当这些操作被异步调用时会产生事件。尽管很丑陋，但该程序还是完成了之前我们提到的功能，也使得我们无须使用真实的异步库就可以测试接下来的例子。<br>现在，让我们编写一个使用这个库的简单程序，这个程序把输入流中的所有行读取到一个表中，然后再逆序将其写到输出流中。如果使用同步I&#x2F;O，那么代码可能如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> inp = <span class="built_in">io</span>.<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">local</span> out = <span class="built_in">io</span>.<span class="built_in">output</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> inp:<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	t[#t + <span class="number">1</span>] = line </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = #t, <span class="number">1</span> , <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">	out:<span class="built_in">write</span>(t[i],<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>现在，让我们再使用异步I&#x2F;O库按照时间驱动的方式重写这个程序。</p>
<blockquote>
<p>示例  使用事件驱动方式逆序一个文件</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;async-lib&quot;</span></span><br><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> inp = <span class="built_in">io</span>.<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">local</span> out = <span class="built_in">io</span>.<span class="built_in">output</span>()</span><br><span class="line"><span class="keyword">local</span> i </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写入行的时间处理函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">putline</span><span class="params">()</span></span></span><br><span class="line">	i = i - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		lib.stop()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		lib.writeline(out,t[i] .. <span class="string">&quot;\n&quot;</span>,putline)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读取行的事件处理函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getline</span> <span class="params">(line)</span></span></span><br><span class="line">	<span class="keyword">if</span> line <span class="keyword">then</span></span><br><span class="line">		t[#t + <span class="number">1</span>] = line</span><br><span class="line">		lib.readline(inp,getline)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i = #t + <span class="number">1</span></span><br><span class="line">		putline()</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">lib.readline(inp,getline)</span><br><span class="line">lib.runloop()</span><br></pre></td></tr></table></figure>
<p>作为一种典型的事件驱动场景，由于主循环位于库中，因此所有的循环都消失了，这些循环被以事件区分的递归调用所取代。尽管我们可以通过使用闭包以后续传递风格进行改进，但仍然不能编写我们自己的循环。如果要这么做，那么必须通过递归来重写。<br>协程可以让我们使用事件循环来简化循环的代码，其核心思想是使用协程运行主要代码，即在每次调用库时将回调函数设置为唤醒协程的函数然后让出执行权。</p>
<blockquote>
<p>示例  是用异步库运行同步代码</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;async-lib&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(code)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		code()</span><br><span class="line">		lib.stop()</span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line">	co()</span><br><span class="line">	lib.runloop()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putline</span> <span class="params">(stream,line)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">running</span>()</span><br><span class="line">	<span class="keyword">local</span> callback = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co) <span class="keyword">end</span>)</span><br><span class="line">	lib.writeline(stream,line,callback)</span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getline</span><span class="params">(stream,line)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">running</span>()</span><br><span class="line">	<span class="keyword">local</span> callback = (<span class="function"><span class="keyword">function</span><span class="params">(l)</span></span> <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,l) <span class="keyword">end</span>)</span><br><span class="line">	lib.readline(stream,callback)</span><br><span class="line">	<span class="keyword">local</span> line = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">	<span class="keyword">return</span> line </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>顾名思义，run函数运行通过参数传入的同步代码。该函数首先创建一个协程来运行指定的代码，并在完成后停止事件循环。然后，该函数唤醒协程，进入事件循环。<br>函数getline和putline模拟了同步I&#x2F;O。正如之前强调的，这两个函数都调用了恰当的异步函数，这些异步函数被当做唤醒调用协程的回调函数传入。之后，异步函数挂起，然后将控制权返回给事件循环。一旦异步操作完成，事件循环就会调用函数来唤醒触发异步函数的协程。<br>使用这个库，我们可以在异步库上运行同步代码了。如下示例再次实现了逆序行的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">	<span class="keyword">local</span> inp = <span class="built_in">io</span>.<span class="built_in">input</span>()</span><br><span class="line">	<span class="keyword">local</span> out = <span class="built_in">io</span>.<span class="built_in">output</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> line = getline(inp)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		t[#t + <span class="number">1</span>] = line</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = #t, <span class="number">1</span> ,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		putline(out,t[i] .. <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>除了使用get&#x2F;putline来进行I&#x2F;O操作和运行在run以内，上述代码与之前的同步示例等价。在同步代码结构的外表之下，程序其实是以事件驱动模式运行的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/15/Lua%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/Lua%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">Lua连续教程之Lua垃圾收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 23:17:59" itemprop="dateCreated datePublished" datetime="2020-05-15T23:17:59+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言使用自动内存管理。程序可以创建对象，但却没有函数来删除对象。Lua语言通过垃圾收集自动删除称为垃圾的对象，从而将程序员从内存管理的绝大部分负担中解放出来。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>更重要的是，将程序员从与内存管理相关的大多数Bug中解放出来。例如无效指针和内存泄露等问题。<br>在一个理想的环境中，垃圾收集器对程序员来说是不可见的，就像一个好的清洁工不会和其他工人打交道一样。不过，有时即使是智能的垃圾收集器也会需要我们的辅助。在某些关键的性能阶段，我们可能需要将其停止，或者让只在特定的时间运行。另外，一个垃圾收集器只能收集它确定是垃圾的内容，而不能猜测我们把什么当作垃圾。没有垃圾收集器能够做到让我们完全不用操心资源管理的问题，比如驻留内存和外部资源。<br>弱引用表、析构器和函数collectgarbage是在Lua语言中用来辅助垃圾收集器的主要机制。弱引用表允许收集Lua语言中还可以被程序访问的对象；析构器允许收集不在垃圾收集器直接控制下的外部对象；函数collectgarbage则允许我们控制垃圾收集器的步长。</p>
<h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>我们知道，数组的有效部分总是向顶部扩展的，但Lua语言却不知道。如果弹出一个元素时只是简单地递减顶部索引，那么这个仍然留在数组中的对象对于Lua语言来说并不是垃圾。同理，即使是程序不会再用到的、存储在全局变量中的对象，对于Lua语言来说也不是垃圾。在这两种情况下，都需要我们将这些对象所在的位置赋值为nil，以便这些位置不会锁定可释放的对象。<br>不过，简单地清除引用可能还不够。在有些情况下，还需要程序和垃圾收集器之间的协作。一个典型的例子是，当我们要保存某些类型的活跃对象的列表时。这个需要看上去简单，我们只需要把每个新对象插入数组即可；但是，一旦一个对象成为了数组的一部分，它就再也无法被回收！虽然已经没有其他任何地方在引用它，但数组依然在引用它。除非我们告诉Lua语言数组对该对象的引用不应该阻碍对此对象的回收，否则Lua语言本身是无从知晓的。<br>弱引用表就是这样一个用来告知Lua语言一个引用不应阻止一个对象回收的机制。所谓所引用是一种不在垃圾收集器考虑范围内的对象引用。如果一个对象的所有引用都是弱引用，弱引用表就是元素均为弱引用的表，这意味着如果一个对象只被一个弱引用持有，那么Lua语言最终会回收这个对象。<br>表由键值对组成，其两者都可以容纳任何类型的对象。在正常情况下，垃圾收集器不会回收一个在可访问的表中作为键或值的对象。也就是说，键和值都是强引用，它们会阻止对其所指向对象的回收。在一个弱引用表中，键和值都可以是弱引用的。这就意味着有三种类型的弱引用表，即具有弱引用键的表、具有弱引用值的表及同时具有弱引用键和值的表。不论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。<br>一个表是否为弱引用表是由其元表中的__mode字段决定的。当这个字段存在时，其值应为一个字符串：如果这个字符串是”k”，那么这个表的键是弱引用的；如果这个字符串是”v”，那么这个表的值是弱引用的；如果这个字符串是”kv”，那么这个表的键和值都是弱引用的。下面的示例虽然有些可以，但演示了弱引用表的基本行为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">mt = &#123;<span class="built_in">__mode</span> = <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(a,mt)		<span class="comment">-- 现在&#x27;a&#x27;的键是弱引用的了</span></span><br><span class="line">key = &#123;&#125;</span><br><span class="line">a[key] = <span class="number">1</span>				<span class="comment">-- 创建第一个键</span></span><br><span class="line">key = &#123;&#125;</span><br><span class="line">a[key] = <span class="number">2</span>				<span class="comment">-- 创建第二个键</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 强制进行垃圾回收</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span>		<span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
<p>在本例中，第二句赋值key &#x3D; {}覆盖了指向第一个键的索引。调用collectgarbage强制垃圾收集器进行一次完整的垃圾手机。由于已经没有指向第一个键的其他引用个，因此Lua语言会回收这个键并从表中删除对应的元素。然而，由于第二个键仍然被变量key所引用，因此Lua不会回收它。<br>请注意，只有对象可以从弱引用表中被移除，而像数字和布尔这样的“值”是不可回收的。例如，如果我们在表a中插入一个数值类型的键，那么垃圾收集器永远不会回收它。当然，如果在一个值为弱引用的弱引用表中，一个数值类型键相关联的值被回收了，那么整个元素都会从这个弱引用表中被删除。<br>字符串在这里表现了一些细微的差别，虽然从实现的角度看字符串是可回收的，但字符串又与其他的可回收对象不同。其他的对象，例如表和闭包，都是被显式创建的。例如，当Lua语言对表达式{}求值时会创建一个新表。</p>
<h2 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h2><p>空间换时间是一种常见的编程技巧。我们可以通过记忆函数的执行结果，在后续使用相同参数再次调用该函数时直接返回之前记忆的结果，来加快函数的运行速度。<br>假设有一个通用的服务器，该服务器接收的请求是以字符串形式表示的Lua语言代码。每当服务器接收到一个请求时，它就对字符串运行load函数，然后再调用编译后的函数。不过，函数load的开销很昂贵，而且发送给服务器的某些命令的出现频率可能很高。这样，与其每次收到一条诸如”closeconnection()”这样的常见命令就重复地调用函数load，还不如让服务器用一个辅助表记忆所有函数load的执行结果。在调用函数load前，服务器先在表中检查指定的字符串是否已经被处理过。如果没有，就调用函数load并将返回值保存到表中。我们可以将这种行为封装为一个新的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mem_loadstring</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = results[s]</span><br><span class="line">	<span class="keyword">if</span> res == nli <span class="keyword">then</span></span><br><span class="line">		res = <span class="built_in">assert</span>(laod(s))</span><br><span class="line">		results[s] = res</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种模式节省的开销非常可观。但是，它也可能导致不易察觉的资源浪费。虽然有些命令会重复出现，但也有很多命令可能就出现一次。渐渐地，表results会堆积上服务器收到的所有命令及编译结果；在运行一段足够长的时间后，这种行为会耗尽服务器的内存。<br>弱引用表为解决这个问题提供了一种简单的方案，如果表results具有弱引用的值，那么每个垃圾收集周期都会删除所有那个时刻未使用的编译结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(results,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;v&quot;</span>&#125;)		<span class="comment">-- 让值称为弱引用</span></span><br><span class="line">funciton mem_loadstring(s)</span><br><span class="line"><span class="comment">--下面内容同前</span></span><br></pre></td></tr></table></figure>
<p>实际上，因为索引永远是字符串，所以如果愿意的话，我们可以让这个表变成完全弱引用的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(results,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;kv&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>最终达到的效果是完全一样的。<br>记忆技术还可以用来确保某类对象的唯一性。例如，假设一个系统用具有三个相同取值范围的字段red、green和blue的表来表示颜色，一个简单的颜色工厂函数每被调用一次就生成一个颜色：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRGB</span><span class="params">(r,g,b)</span></span></span><br><span class="line">	<span class="keyword">return</span> &#123;red = r, green = g ,blue = b&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>使用记忆技术，我们就可以为相同的颜色复用相同的表。要为每一种颜色创建一个唯一的键，只需要使用分隔符把颜色的索引连接起来即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(results,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;v&quot;</span>&#125;)		<span class="comment">-- 让值称为弱引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRGB</span><span class="params">( r,g,b )</span></span></span><br><span class="line">	<span class="keyword">local</span> key = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,r,g,b)</span><br><span class="line">	<span class="keyword">local</span> color = results[key]</span><br><span class="line">	<span class="keyword">if</span> color == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">		color = &#123;red = r, green = g, blue = b&#125;</span><br><span class="line">		results[key] = color</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> color</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种实现的一个有趣结果是，由于两种颜色存在的颜色必定是由同一个表来表示，所以用户可以使用基本的相等运算符比较两种颜色。因为随着时间的迁移垃圾收集器会清理表results，所以一种指定的颜色在不同的时间内可能由不同的表来表示。不过，只要一种颜色正在被使用，它就不会从results中被移除。因此，一种颜色与一种新颜色相比已经存在了多长时间，这种颜色对应的表也存在了对应长度的时间，也可以被新颜色复用。</p>
<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><p>弱引用表的另外一种重要应用是将属性与对象关联起来。在各种各样的情况下，我们都需要把某种属性绑定到某个对象，例如函数名、表的默认值及数组的大小等。<br>当对象是一个表时，可以通过适当的唯一键把属性存储在这个表自身中。不过，如果对象不是一个表，那么它就不能保存它自己的属性。另外，即使是表，有时我们也不想把属性保存在原始的对象。例如，当想保持属性的私有性时，或不想让属性干扰表的遍历时，就需要用其他办法来关联对象和属性。<br>当然，外部表为对象和属性的映射提供了一种理性的方法，即对偶表示，其中将对象用作键、将对象的属性用作值。由于Lua语言允许使用任意类型的对象作为键，因此一个外部表可以保存任意类型对象的属性。此外，存储在外部表中的属性不会干扰其他对象，并且可以像表本身一样是私有的。<br>不过，这个看似完美的方案有一个重大缺陷：一旦我们把一个对象当作表中的一个键，那么就是引用了它。Lua语言无法回收一个正在被用作键的对象。例如，如果使用一个普通的表来映射函数和函数名，那么这些函数就永远无法被回收。</p>
<h2 id="回顾具有默认值的表"><a href="#回顾具有默认值的表" class="headerlink" title="回顾具有默认值的表"></a>回顾具有默认值的表</h2><p>在第一种解决方案中，我们使用了一个弱引用表来映射每一个表和它的默认值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> defaults = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(defaults,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;k&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span> <span class="keyword">return</span> defaults[t] <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefault</span> <span class="params">(t,d)</span></span></span><br><span class="line">	defaults[t] = d</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这是对偶表示的一种典型应用，其中使用了defaults[t]来表示t.defaults。如果表defaults没有弱引用的键，那么所有具有默认值的表就会永远存在下去。<br>在第二种解决方案中，我们对不同的默认值使用了不同的元素，在遇到重复的默认值时会复用相同的元表。这是记忆技术的一种典型应用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> metas = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(metas,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;v&quot;</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefault</span><span class="params">(t,d)</span></span></span><br><span class="line">	<span class="keyword">local</span> mt = metas[d]</span><br><span class="line">	<span class="keyword">if</span> mt == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">		mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> d <span class="keyword">end</span>&#125;</span><br><span class="line">		metas[d] = mt</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们使用弱引用的值使得不再被使用的元表能够回收。<br>这两种实现哪种更好取决于具体的情况。这两种实现具有类似的复杂度和性能表现，第一种实现需要为每个具有默认值的表分配几个字节的内存，而第二种实现则需要为每个不同的默认值分配若干内存。因此，如果应用中有上千个具有少量不同默认值的表，那么第二种实现明显更好。不过，如果只有少量共享默认值的表，那么就应该选择第一种实现。</p>
<h2 id="瞬表"><a href="#瞬表" class="headerlink" title="瞬表"></a>瞬表</h2><p>一种棘手的情况是，一个具有弱引用键的表中的值又引用了对应的键。<br>这种情况看上去更加常见。一个典型的示例是常量函数工厂。这种工厂的参数是一个对象，返回值是一个被调用时返回传入对象的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factory</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> o <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种工厂时实现记忆的一种很好的手段，可以避免在闭包已经存在时又创建新的闭包。</p>
<blockquote>
<p>示例  使用记忆技术的常量函数工厂</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> mem = &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(mem, &#123;<span class="built_in">__mode</span> = <span class="string">&quot;k&quot;</span>&#125;)</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">factory</span><span class="params">(o)</span></span></span><br><span class="line">		<span class="keyword">local</span> res = mem[o]</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">			res = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> o <span class="keyword">end</span>)</span><br><span class="line">			mem[o] = res</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，这里另有玄机。请注意，表mem中与一个对象关联的值回指了它自己的键。虽然表中的键是弱引用的，但是表中的值却不是弱引用的。从一个弱引用表的标准理解看，记忆表中没有任何东西会被移除。由于值不是弱引用的，所以对于每一个函数来说都存在一个强引用。每一个函数都指向其对应的对象，因而对于每一个键来说都存在一个强应用。因此，即使有弱引用的键，这些对象也不会被回收。<br>不过，这种严格的理解不是特别有用。大多数人希望一个表中的值只能通过对应的键来访问。我们可以认为之前的情况是某种环，其中闭包引用了指回闭包的对象。<br>Lua语言通过瞬表的概念来解决上述问题。在Lua语言中，一个具有弱引用键和强引用值的表是一个瞬表。在一个顺表中，一个键的可访问性控制着对应值的可访问性。更确切地说，考虑瞬表中的一个元素，指向的v的引用只有当存在某些指向k的其他外部引用存在时才是强引用，否则，即使v引用了k，垃圾收集器最终会收集k并把元素从表中移除。</p>
<h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>虽然垃圾收集器的目标是回收对象，但是它可以帮助程序员来释放外部资源。处于这种目的，几种编程语言提供了析构器。析构器是一个与对象关联的函数，当该对象即将被回收时该函数会被调用。<br>Lua语言通过元方法__gc实现析构器，如下例所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o,&#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span>&#125;)</span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>在本例中，我们首先创建一个带有__gc元方法元表的表。然后，抹去与这个表的唯一联系，再强制进行一次完整的垃圾回收。在垃圾回收期间，Lua语言发现表已经不再是可访问的了，因此调用表的析构器，也就是元方法__gc。<br>Lua语言中，析构器的一个微妙之处在于“将一个对象标记为需要析构”的概念。通过给对象设置一个具有非空__gc元方法的元表，就可以把一个对象标记为需要进行析构处理。如果不标记对象，那么对象就不会被析构。我们编写的大多数代码会正常运行，但会发生某些奇怪的行为，比如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line">mt = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o,mt)</span><br><span class="line">mt.<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span></span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- (print nothing)</span></span><br></pre></td></tr></table></figure>
<p>这里，我们确实要给对象o设置了元表，但是这个元表没有__gc方法，因此对象没有被标记为需要进行析构处理。即使我们后续给元表增加了元方法__gc，Lua语言也发现不了这种赋值的特殊之处，因此不会把对象标记为需要进行析构处理。<br>正如我们所提到的，这很少会有问题。在设置元表后，很少会改变元方法。如果真的需要在后续设置元方法，那么可以给字段__gc先赋一个任意值作为占位符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line">mt = &#123;<span class="built_in">__gc</span> = <span class="literal">true</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o,mt)</span><br><span class="line">mt.<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span></span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>现在，由于元表有了__gc字段，因此对象会被正确地标记为需要析构处理。如果后续再设置元方法也不会有问题，只要元方法时一个正确的函数，Lua语言就能够调用它。<br>当垃圾收集器在同一个周期中析构多个对象时，它会按照对象被标记为需要析构处理的顺序逆序调用这些对象的析构器。请考虑如下的示例，该示例创建了一个由带有析构器的对象所组成的链表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mt = &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o[<span class="number">1</span>]) <span class="keyword">end</span>&#125;</span><br><span class="line">list = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> , <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">	list = <span class="built_in">setmetatable</span>(&#123;i,link = list&#125;,mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">list = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()</span><br></pre></td></tr></table></figure>
<p>第一个被析构的对象是3，也就是最后一个被标记的对象。<br>一种常见的误解是认为正在被回收的对象之间的关联会影响对象析构的顺序。例如，有些人可能认为上例中的对象2必须在对象1之前被析构，因为存在从2到1的关联。但是，关联会行程环。所以，关联并不会影响析构器执行的顺序。<br>有关析构器的另个一微妙之处是复苏。当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新编程活跃的。笔者把这称为临时复苏。在析构器执行期间，我们无法阻止析构器把该对象存储在全局变量中，使得该对象在析构器返回后仍然可以访问，笔者把这称为永久复苏。</p>
<p>复苏必须是可传递的。考虑如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;x = <span class="string">&quot;this is A&quot;</span>&#125;</span><br><span class="line">B = &#123;f = A&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(B,&#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.f.x) <span class="keyword">end</span>&#125;)</span><br><span class="line">A,B = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>() 		<span class="comment">-- this is A</span></span><br></pre></td></tr></table></figure>
<p>B的析构器访问了A，因此A在B析构前不能被回收，Lua语言在运行析构器之前必须同时复苏B和A。<br>由于复苏的存在，Lua语言会在两个阶段中回收具有析构器的对象。当垃圾收集器首次发生某个具有析构器的对象不可达时，垃圾收集器就把这个对象复苏并将其放入等待被析构的队列中。一旦析构器开始执行，Lua语言就将对该对象标记为已被析构。当下一次垃圾收集器又发现这个对象不可达时，它就将这个对象删除。如果想保证我们程序中的所有垃圾都被真正地释放了的话，那么必须调用collectgarbage两次，第二次调用才会删除第一次调用中被析构的对象。<br>由于Lua语言在析构对象上设置了标记，每一个对象的析构器都会精确地运行一次。如果一个对象直到程序运行结束还没有被回收，那么Lua语言就会在整个Lua虚拟机关闭后调用它的析构器。这种特行在Lua语言中实现了某种形式的atexit函数，即在程序终结前立即运行的函数。我们所要做的就是创建一个带有析构器的表，然后把它锚定在某处，例如锚定到全局表中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;finishing Lua program&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,t)</span><br><span class="line"><span class="built_in">_G</span>[<span class="string">&quot;*AA*&quot;</span>] = t</span><br></pre></td></tr></table></figure>
<p>另外一个有趣的技巧会允许程序在每次完成垃圾回收后调用指定的函数。由于析构器只运行一次，所以这种技巧是让每个析构器创建一个用来运行下一个析构器的新对象，参考示例：</p>
<blockquote>
<p>示例 在每次GC后运行一个函数</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> mt = &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;new cycle&quot;</span>)</span><br><span class="line">		<span class="built_in">setmetatable</span>(&#123;&#125;,<span class="built_in">getmetatable</span>(o))</span><br><span class="line">	<span class="keyword">end</span>&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(&#123;&#125;,mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 一次垃圾收集</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 一次垃圾收集</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 一次垃圾收集</span></span><br></pre></td></tr></table></figure>
<p>具有析构器的对象和弱引用表之间的交互也有些微妙。在每个垃圾收集周期内，垃圾收集器会在调用析构器前清理弱应用表中的值，在调用析构器之后再清理键。这种行为的原理在于我们经常使用带有弱引用键的表来保存对象的属性，因此，析构器可能需要访问那些属性。不过，我们也会使用具有弱引用值的表来重用活跃的对象，在这种情况下，正在被析构的对象就不再有用了。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>一直到Lua5.0，Lua语言使用的都是一个简单的标记-清除式垃圾收集器。这种收集器又被称为“stop-the-world（全局暂停）”式的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期。每一个垃圾收集周期由四个阶段组成：标记、清理、清除和析构。<br>标记阶段把根节点集合标记为活跃，根结点集合由Lua语言可以直接访问的对象组成。在Lua语言中，这个集合只包括C注册表。<br>保存在一个活跃对象中的对象是程序可达的，因此也会被标记活跃。当所有可达对象都被标记为活跃后，标记阶段完成。<br>在开始清除阶段前，Lua语言先执行清理阶段，在这个阶段中处理析构器和弱引用表。首先，Lua语言遍历所有被标记为需要进行析构、但又没有被标记为活跃状态的对象。这些没有标记为活跃状态的对象会被标记为活跃，并被放在一个单独的列表中，这个列表会在析构阶段用到。然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。<br>清理阶段遍历所有对象。如果一个对象没有被标记为活跃，Lua语言就将其回收，否则，Lua语言清理标记，然后准备进行下一个清理周期。<br>最后，在析构阶段，Lua语言调用清理阶段被分离出的对象的析构器。<br>使用真正的垃圾收集器意味着Lua语言能够处理对象引用之间的环。在使用环形数据结构时，我们不需要花费外的精力，它们会像其他数据一样被回收。<br>Lua5.1使用了增量式垃圾收集器。这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是不需要在垃圾收集期间停止主程序的运行。相反，它与解释器一起交替运行。每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步（这意味着，在垃圾收集器工作期间，解释器可能会改变一个对象的可达性。为了保证垃圾收集器的正确性，垃圾收集器中的有些操作具有发现危险改动和纠正所涉及对象标记的内存屏障）。<br>Lua5.2引入了紧急垃圾收集。当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。</p>
<h2 id="控制垃圾收集的步长"><a href="#控制垃圾收集的步长" class="headerlink" title="控制垃圾收集的步长"></a>控制垃圾收集的步长</h2><p>通过函数collectgarbage可以对垃圾收集器进行一些额外的控制，该函数实际上是几个函数的集合体：第一个参数是一个可选的字符串，用来说明进行何种操作；有些选项使用一个整型作为第二个参数，称为data。<br>第一个参数的选项包括如下七个。<br>“stop”:停止垃圾收集器，知道使用选项”restart”再次调用collectgarbage。<br>“restart”:重启垃圾收集器。<br>“collect”:执行一次完整的垃圾收集，回收和析构所有不可达的对象。这是默认的选项。<br>“step”:执行某些垃圾收集工作，第二个参数data指明工作量，即在分配了data字节后垃圾收集器应该做什么。<br>“count”:以KB为单位返回当前自己已用内存数，该结果是一个浮点数，乘以1024得到的就是精确的字节数。该值包括了尚未被回收的死对象。<br>“setpause”:设置收集器的stepmul参数。参数data给出新值，也是以百分比为单位。<br>两个参数pause和stepmul控制着垃圾收集器的角色。任何垃圾收集器都是使用CPU时间换内存空间。在极端情况下，垃圾收集器可能根本不会运行。但是，不耗费CPU时间是以巨大的内存消耗为代价的。在另外一种极端的情况下，收集器可能每进行一次赋值就得运行一次完整的垃圾收集。程序能够使用尽可能少的内存，但是是以巨大的CPU消耗为代价的。pause和stepmul的默认值正式试图在这两个极端之间找到的对大多数应用来说足够好的平衡点。不过，在某些情况下，还是值得试着对它们进行优化。<br>参数pause用于控制垃圾收集器在一次手机完成后等待多久再开始新的一次手机。当值为零时，表示Lua语言在上一次垃圾回收结束后立即开始一次新的收集。当值为200%时表示在重启垃圾收集器前等待内存使用翻番。如果想消耗更多的CPU时间换取更低的内存消耗，那么可以把这个值设置得小一点。通常，我们应该把这个值设在0到200%之间。<br>参数stepmul控制对于每分配1KB内存，垃圾收集器应该进行多少工作。这个值越高，垃圾收集器使用的增量越小。一个像10000000%一样巨大的值会让收集器表现得像一个非增量的垃圾收集器。默认值是200%，地于100%的值会让收集器运行得很慢，以至于可能一次收集也完不成。<br>函数collectgarbage的另外一些参数用来在垃圾收集器运行时控制它的行为。同样，对于大多数程序员来说，默认值已经足够好了，但是对于一些特殊的应用，用手工控制可能会更好，游戏就经常需要这种类型的控制。例如，如果我们不想让垃圾收集在某些阶段运行，那么可以通过调用函数collectgarbage(“stop”)停止垃圾收集器，然后再调用collectgarbage(“restart”)重新启动垃圾收集器。在一些具有周期性休眠阶段的代码中，可以让垃圾收集器停止，然后在程序休眠期间调用collectgarbage(“step”,n)。要设置在每一个休眠期间进行多少工作，要么为n实验性地选择一个恰当的值，要么把n设成零，然后在一个循环中调用函数collectgarbage直到休眠结束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/10/Lua%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Lua%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">Lua中的环境(Environment)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 15:17:38" itemprop="dateCreated datePublished" datetime="2020-05-10T15:17:38+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>全局变量在大多数变成语言中是让人爱恨交织又不可或缺的。一方面，使用管全局变量会明显地使无关的代码部分纠缠在一起，容易导致代码复杂。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>另一方面，谨慎地使用全局变量又能更好地表达程序中真正的全局概念；此外，虽然全局常量看似无害，但像Lua语言这样的动态语言是无法区分常量和变量的。像Lua这样的嵌入式语言更复杂：虽然全局变量时再整个程序中均可见的变量，但由于Lua语言是由宿主应用调用代码段的，因此“程序”的概念不明确。<br>Lua语言通过不使用全局变量的方法来解决这个难题，但又不遗余力地在Lua语言汇总对全局变量进行模拟。在第一种近似的模拟中，我们可以认为Lua语言把所有的全局变量保存在一个称为全局环境的普通表中。<br>由于不需要再为全局变量创造一种新的数据结构，因此使用一个表来保存全局变量的一个优点是简化了Lua 语言的内部实现。另一个优点是，可以像操作其他表一样操作这个表。为了便于实现这种操作方式，Lua语言将全局环境自身保存在全局变量_G中。例如，如下代码输出了全局环境中所有全局变量的名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">_G</span>) <span class="keyword">do</span> <span class="built_in">print</span>(n) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="具有动态名称的全局变量"><a href="#具有动态名称的全局变量" class="headerlink" title="具有动态名称的全局变量"></a>具有动态名称的全局变量</h2><p>通常，赋值操作对于访问和设置全局变量已经足够了。<br>通常，赋值操作对于访问和设置全局变量已经足够了。然而，有时我们也需要某些形式的元变成。例如，我们需要操作一个全局变量，而这个全局变量的名称却存储在另一个变量中或者经由运行时计算得到。为了获取这个变量的值，许多程序员会写出下面的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="built_in">load</span>(<span class="string">&quot;return &quot;</span> .. varname)()</span><br></pre></td></tr></table></figure>
<p>例如，如果varname是x，那么字符串连接的结果就是”return x”，当执行时就能得到期望的结果。然而，在这段代码中涉及一个新代码段的创建和编译，在一定程度上开销昂贵。我们可以使用下面的代码来实现相同的效果，但效率却比之前的高出一个数量级：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value  = <span class="built_in">_G</span>[varname]</span><br></pre></td></tr></table></figure>
<p>由于全局环境是一个普通的表，因此可以简单地使用个对应的键直接进行索引。<br>类似地，我们可以通过编写_G[varname] &#x3D; value给一个名称为动态计算出的全局变量赋值。不过，请注意，有些程序员对于这种机制的使用可能有些过度而写出诸如_G[“a”] &#x3D; _G[“b”]这样的代码，而这仅仅是a &#x3D; b 的一种复杂写法。<br>上述问题的一般化形式是，允许字段使用诸如”io.read”或”a.b.c.d”这样的动态名称。如果直接使用_G[“io.read”]，显然是不能从表io中得到字段read的。但我们可以编写一个函数getfield让getfield(“io.read”)返回想要的结果。这个函数主要是一个循环，从_G开始逐个字段地进行求值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getfield</span><span class="params">(f)</span></span></span><br><span class="line">	<span class="keyword">local</span> v = <span class="built_in">_G</span></span><br><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(f,<span class="string">&quot;[%a_][%w_]*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		v = v[w]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们使用函数gmatch来遍历f中的所有标识符。<br>与之对应的设置字段的函数稍显复杂。像a.b.c.d &#x3D; v这样的赋值等价于一下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> temp = a.b.c</span><br><span class="line">temp.d = v</span><br></pre></td></tr></table></figure>
<p>也就是说，我们必须一直取到最后一个名称，然后再单独处理最后的这个名称。</p>
<blockquote>
<p>示例 函数setfield</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setfield</span><span class="params">(f,v)</span></span></span><br><span class="line">	<span class="keyword">local</span> t = <span class="built_in">_G</span></span><br><span class="line">	<span class="keyword">for</span> w, d <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(f, <span class="string">&quot;([%a_][%w_]*)(%.?)&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> d == <span class="string">&quot;.&quot;</span> <span class="keyword">then</span></span><br><span class="line">			t[w] = t[w] <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">			t = t[w]</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t[w] = v</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上例中使用的模式将捕获字段名称保存在变量w中，并将其后可选的点保存在变量d中。如果字段名后没有点，那么该字段就是最后一个名称。<br>下面的代码通过上例中的函数创建了全局表t和t.x，并将10赋值给了t.x.y:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setfield(<span class="string">&quot;t.x.y&quot;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(t.x.y)</span><br><span class="line"><span class="built_in">print</span>(getfield(<span class="string">&quot;t.x.y&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h2><p>Lua语言中的全局变量不需要声明就可以使用。虽然这种行为对于小型程序来说较为方便，但在大型程序中一个简单的手误可能造成难以发现的bug。不过，如果我们乐意的话，也可以改变这种行为。由于Lua语言将全局变量存放在一个普通的表中，所以可以通过元表来访问不存在全局变量的情况。<br>一种方法是简单地检测所有对全局表中不存在键的访问：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>,&#123;</span><br><span class="line">	<span class="built_in">__newindex</span> = funciton (_,n)</span><br><span class="line">	<span class="built_in">error</span>(<span class="string">&quot;attempt to write to undeclared variable&quot;</span> .. n, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_,n)</span></span></span><br><span class="line">	<span class="built_in">error</span>(<span class="string">&quot;attempt to read undeclared variable &quot;</span> .. n , <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码执行后，所有试图对不存在全局变量的访问都将引发一个错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>:attempt to <span class="built_in">read</span> undeclared variable a </span><br></pre></td></tr></table></figure>
<p>但是，我们应该如何声明一个新的变量呢？方法之一是使用函数rawset,它可以绕过元方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">declare</span> <span class="params">(name initval)</span></span></span><br><span class="line">	<span class="built_in">rawset</span>(<span class="built_in">_G</span>,name,initval <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中，or 和false保证新变量一定会得到一个不为nil的值。<br>另外一种更简单的方法是把对新全局变量的赋值限制在仅能在函数内进行，而代码段外层的代码则被允许自有赋值。<br>要检查赋值是否在主代码段中必须用到调试库。调用函数debug.getinfo(2,”S”)将返回一个表。其中的字段what表示调用元方法的函数是主代码段还是普通的Lua函数还是C函数。使用该函数，可以将__newindex元方法重写：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__newindex</span> = funciton (t,n,v)</span><br><span class="line">	<span class="keyword">local</span> w = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;S&quot;</span>).wath</span><br><span class="line">	<span class="keyword">if</span> w ~= <span class="string">&quot;main&quot;</span> <span class="keyword">and</span> w ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span> (<span class="string">&quot;attempt to write to undeclared variable&quot;</span> .. n , <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	rewset(t,n,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个新版本还可以接受来自C代码的赋值，因为一般C代码都知道自己究竟在做什么。<br>如果要测试一个变量是否存在，并不能简单地将它与nil比较。因为如果它为nil，那么访问就回引发一个错误。这是，应该使用rawget来绕过元方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">rawset</span>(<span class="built_in">_G</span>, var) == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>正如前面所提到的，我们不允许值为nil的全局变量，因为值为nil的全局变量都会被自动地认为未声明。但是，要允许值为nil的全局变量也不难，只需要引入一个辅助表来保存已声明变量的名称即可。一旦调用了元方法，元方法就会检查该表，看变量是否是未声明过的。</p>
<blockquote>
<p>示例 检查全局变量的声明</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> declareNames = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>,&#123;</span><br><span class="line">	<span class="built_in">__newindex</span> = funciton(t,n,v)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> declareNames[n] <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">local</span> w = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;S&quot;</span>).wath </span><br><span class="line">		<span class="keyword">if</span> w ~= <span class="string">&quot;main&quot;</span> <span class="keyword">and</span> w ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">error</span>(<span class="string">&quot;attempt to write to undeclared variable &quot;</span> .. n, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		declareNames[n] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">rawset</span>(t,n,v)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(_,v)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> declareNames[n] <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;attempt to read undeclared variable &quot;</span> .. n , <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在，即使像 x &#x3D; nil这样的赋值也能够声明全局变量了。<br>上述两种方法所导致的开销都基本可以忽略不计。在第一种方法中，在普通操作期间元方法不会被调用。在第二种方法中，元方法只有当程序访问一个值为nil的变量时才会被调用。</p>
<h2 id="非全局环境"><a href="#非全局环境" class="headerlink" title="非全局环境"></a>非全局环境</h2><p>在Lua语言中，全局变量并一定非得是真正全局的。正如笔者此前所提到的，Lua语言甚至根本没有全局变量。Lua语言竭尽全力地让程序员有全局变量存在的幻觉。现在，让我们看看Lua语言是如何构建这种幻觉的。<br>首先，让我们忘掉全局变量而从自由名称的概念开始讨论。一个自由名称是指没有关联到显示声明上的名称，即它不出现在对应局部变量的范围内。例如，在下面的代码段中，x和y是自由名称，而z不是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">x = y + z</span><br></pre></td></tr></table></figure>
<p>接下来就到了关键的部分：Lua语言编译器将代码段中的所有自由名称x转换为_ENV.x。因此，此前的代码段完全等价于：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line"><span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br></pre></td></tr></table></figure>
<p>但是这里新出现的_ENV变量又究竟是什么呢？</p>
<p>我们刚才说过，Lua语言中没有全局变量。因此，_ENV不可能是全局变量。在这里，编译器实际上又进行了一次巧妙的工作。笔者已经提到过，Lua语言包所有代码段都当做匿名函数。所以，Lua语言编译器实际上将原来的代码段编译为如下形式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = some value</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">	<span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>也就是说，Lua语言是在一个名为_ENV的预定义上值（一个外部的局部变量，upvalue）存在的情况下编译所有的代码段的。因此，所有的变量要么是绑定到了一个名称的局部变量，要么是_ENV中的一个字段，而_ENV本身是一个局部变量。<br>_ENV的初始值可以是任意的表。任何一个这样的表都被称为一个环境。为了维持全局变量存在的幻觉，Lua语言在内部维护了一个表来用作全局变量。通过，当加载一个代码段时，函数load会使用预定义上的值来初始化全局环境。因此，原始的代码段等价于：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = the global environment</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">	<span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述赋值的结果是，全局环境中的字段x得到全局环境中字段y加10的结果。<br>乍一看，这可能像是操作全局变量的一种相当拐弯抹角的方式。笔者也不会去争辩说这是最简单的方式，但是，这种方式比那些更简单的实现方法具有更多的灵活性。<br>在继续学习前，让我们总结一下Lua语言中处理全局变量的方式：</p>
<ul>
<li>编译器在编译所有代码段前，在外层创建局部变量_ENV；</li>
<li>编译器将所有自由名称var变换为_ENV.var；</li>
<li>函数load使用全局环境初始化代码段的第一个上值，即Lua语言内部维护的一个普通的表。<br>实际上，这也不是太复杂。<br>有些人由于试图从这些规则中引申出额外的“魔法”而感到困惑；其实，这些规则并没有额外的含义。尤其是，前两条规则完全是由编译器进行的。除了是由编译器预定的，_ENV只是一个单纯的普通变量。抛开编译器，名称_ENV对于Lua语言来说根本没有特殊含义。类似地，从x到_ENV.x的转换时纯粹的语法转换，没有隐藏的含义。尤其是，在转换后，按照标准的可见性规则，_ENV引用的是所在位置所有可见的额_ENV变量。</li>
</ul>
<h2 id="使用-ENV"><a href="#使用-ENV" class="headerlink" title="使用_ENV"></a>使用_ENV</h2><p>由于_ENV只是一个普通的变量，因此可以对其赋值或像访问其他变量一样访问它。赋值语句_ENV &#x3D; nil会使得后续代码不能直接访问全局变量。这可以赢来控制代码使用哪种变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">print</span>, <span class="built_in">sin</span> = <span class="built_in">print</span>,<span class="built_in">math</span>.<span class="built_in">sin</span></span><br><span class="line"><span class="built_in">_ENV</span> = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">13</span>) 		<span class="comment">-- 13</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sin</span>(<span class="number">13</span>))  <span class="comment">-- 0.42016703682664</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">cos</span>(<span class="number">13</span>))  <span class="comment">-- error</span></span><br></pre></td></tr></table></figure>
<p>任何对自由名称的赋值都会引发类似的错误。<br>我们可以显式地使用_ENV来绕过局部声明：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">13</span>     <span class="comment">-- 全局的</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">12</span> </span><br><span class="line"><span class="built_in">print</span>(a)		<span class="comment">-- 12(局部的)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_ENV</span>.a)   <span class="comment">-- 13(全局的)</span></span><br></pre></td></tr></table></figure>
<p>用_G也可以：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">13</span>    <span class="comment">-- 全局的</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">12</span> </span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">-- 12 局部的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_G</span>.a) <span class="comment">-- 13 局部的</span></span><br></pre></td></tr></table></figure>
<p>通常，_G和_ENV指向的是同一个表。但是，尽管如此，它们是很不一样的实体。_ENV是一个局部变量，所有对“全局变量”的访问实际上访问的都是_ENV。_G则是一个在任何情况下都没有任何特殊状态的全局变量。按照定义，_ENV永远指向的是当前的环境；而假设在可见且无人改变过其值的前提下，_G通常指向的是全局变量。<br>_ENV的主要用途是用来改变代码段使用的环境。一旦改变了环境，所有的全局访问就都将使用新表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将当前的环境改为一个新的空表</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span>	<span class="comment">-- 在_ENV中创建字段</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">-- stdin:4:attempt to call global &#x27;print&#x27; (a nil value)</span></span><br></pre></td></tr></table></figure>
<p>如果新环境是空的，就会丢失所有的全局变量，包括函数print。因此，应该首先把一些有用的值放入新环境，比如全局环境：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">15</span>		<span class="comment">-- 创建一个全局变量</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;g = <span class="built_in">_G</span>&#125;		<span class="comment">-- 改变当前环境</span></span><br><span class="line">a = <span class="number">1</span>		<span class="comment">-- 在_ENV中创建字段</span></span><br><span class="line">g.<span class="built_in">print</span>(<span class="built_in">_ENV</span>.a,g.a)		<span class="comment">-- 1, 15</span></span><br></pre></td></tr></table></figure>
<p>这时，当访问“全局”的g（位于_ENV而不是全局环境中）时，我们使用的是全局环境，在其中能够找到函数print。<br>我们可以使用_G代替g，从而重写前面的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">15</span>					<span class="comment">-- 创建一个全局变量</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>&#125;		<span class="comment">-- 改变的当前环境</span></span><br><span class="line">a = <span class="number">1</span>					<span class="comment">-- 在_ENV中创建字段</span></span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">print</span>(<span class="built_in">_ENV</span>.a,_g.a)	<span class="comment">-- 1	15</span></span><br></pre></td></tr></table></figure>
<p>_G只有在Lua语言创建初始化的全局表并让字段_G指向它自己的时候，才会出现特殊状态。Lua语言并不关心该变量的当前值。不过尽管如此，就像我们在上面重写的示例中所看到的那样，将指向全局环境的变量命名为同一个名字(_G)是一个惯例。<br>另一种把旧环境装入新环境的方式是使用继承：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> newgt = &#123;&#125;		<span class="comment">-- 创建新环境</span></span><br><span class="line"><span class="built_in">setmetatable</span>(newgt,&#123;<span class="built_in">__index</span> = <span class="built_in">_G</span>&#125;)</span><br><span class="line"><span class="built_in">_ENV</span> = newgt			<span class="comment">-- 设置新环境</span></span><br><span class="line"><span class="built_in">print</span>(a)		<span class="comment">--1 </span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，新环境从全局环境中继承了函数print和a。不过，任何赋值都会发生在新表中，虽然我们仍然能通过_G来修改全局环境中的变量，但如果误改全局环境中的变量也不会有什么影响。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接此前的代码</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a,<span class="built_in">_G</span>.a)			<span class="comment">-- 10 	1</span></span><br><span class="line"><span class="built_in">_G</span>.a  = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_G</span>.a)				<span class="comment">-- 20</span></span><br></pre></td></tr></table></figure>
<p>作为一个普通的变量，_ENV遵循通常的定界规则。特别地，在一段代码中定义的函数可以按照访问其他外部变量一样的规则访问_ENV:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">_ENV</span> = &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>&#125;</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">_G</span>.<span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">foo()			<span class="comment">-- 10</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>, a = <span class="number">20</span>&#125;</span><br><span class="line">foo()		<span class="comment">-- 20</span></span><br></pre></td></tr></table></figure>
<p>如果定义一个名为_ENV的局部变量，那么对自由名称的引用将会绑定绑定到这个新变量上：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">_ENV</span> - &#123;<span class="built_in">print</span> = <span class="built_in">print</span>,a = <span class="number">14</span>&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)			<span class="comment">-- 14</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(a)			<span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
<p>因此，，可以跟很容易地使用私有环境定义一个函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factory</span><span class="params">(_ENV)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="keyword">return</span> a <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f1 = factory&#123;a = <span class="number">6</span>&#125;</span><br><span class="line">f2 = factory&#123;a = <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(f1())			<span class="comment">-- 6</span></span><br><span class="line"><span class="built_in">print</span>(f2())			<span class="comment">-- 7</span></span><br></pre></td></tr></table></figure>
<p>factory函数创建了一个简单的闭包，这个闭包返回了其中“全局”的a。每当闭包被创建时，闭包可见的变量_ENV就成了外部factory函数的参数_ENV。因此，每个闭包都会使用自己的外部变量来访问其自由名称。<br>使用普遍的定界规则，我们可以有几种方式操作环境。例如，可以让多个函数共享一个公共环境，或者让一个函数改变它与其他函数共享的环境。</p>
<h2 id="环境和模块"><a href="#环境和模块" class="headerlink" title="环境和模块"></a>环境和模块</h2><p>模块的缺点之一在于很容易污染全局空间，例如在私有声明中忘记local关键字。环境为解决这个问题提供了一种有趣的方式。一旦模块的主程序有一个独占的环境，则不仅该模块所有的函数共享了这个环境，该模块的全局变量也进入到了这个环境中。我们可以将所有的公有函数声明为全局变量，这样它们就会自动地进入分开的环境中。模块索要做的就是将这个环境赋值给变量_ENV。之后，当我们声明函数add时，它会变成M.add:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="built_in">_ENV</span> = M</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r + c2.r, c1.i + c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>此外，我们在调用同一模块中的其他函数时不需要任何前缀。在此前的代码中，add会从其环境中得到new，也就是M.new。<br>这种方法为模块提供了一种良好的支持，只需要程序员多做一点额外的工作。使用这种方法，完全不需要前缀，并且调用一个导出的函数与调用一个私有函数没有什么区别。即使程序员忘记了local关键词，也不会污染全局命名空间。相反，他只是让一个私有函数编程了公有函数而已。<br>不过尽管如此，笔者目前还是倾向于使用原始的基本方法，也许原始的基本方法需要更多的工作，但代码会更加清晰。为了避免错误地创建全局变量，笔者使用把nil赋给_ENV的方式。在把_ENV设为nil后，任何对全局变量的复制都会抛出异常。这种方式的另一个好处是无须修改代码也可以在老版本的Lua语言中运行。<br>为了访问其他模块，我们可以声明一个保存全局环境的局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">_G</span> = <span class="built_in">_G</span></span><br><span class="line"><span class="built_in">_ENV</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>然后在全局名称前加上_G和模块名M即可。<br>另一种更规范的访问其他模块的做法是只把需要的函数或模块声明为局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 模块初始化</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入部分：</span></span><br><span class="line"><span class="comment">-- 声明该模块需要的外部函数或模块等</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">sqrt</span> = <span class="built_in">math</span>.<span class="built_in">sqrt</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">io</span> = <span class="built_in">io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从此以后不能再进行外部访问</span></span><br><span class="line"><span class="built_in">_ENV</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>这种方式需要做更多的工作，但是它能清晰地列出模块的依赖。</p>
<h2 id="ENV-和load"><a href="#ENV-和load" class="headerlink" title="_ENV 和load"></a>_ENV 和load</h2><p>正如笔者此前提到的，函数load通常把被加载代码段上的值_ENV初始化为全局环境。不过，函数load还有一个可选的第四个参数来让我们为_ENV指定一个不同的初始值。<br>例如，假设我们有一个典型的配置文件，该配置文件定义了程序要使用的几个常量和函数，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件&#x27;config.lua&#x27;</span></span><br><span class="line">width = <span class="number">200</span></span><br><span class="line">height = <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>可以使用如下的代码加载该文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env = &#123;&#125;</span><br><span class="line"><span class="built_in">loadfile</span>(<span class="string">&quot;config.lua&quot;</span>,<span class="string">&quot;t&quot;</span>,env)()</span><br></pre></td></tr></table></figure>
<p>配置文件中的所有代码会运行在空的环境env中，类似于某种沙盒。特别地，所有的定义都会进入这个环境中。即使出错，配置文件也无法影响任何别的东西，甚至是恶意的代码也不能对其他东西造成任何破坏。除了通过消耗CPU时间和内存来制造拒绝服务攻击，恶意代码也做不了什么其他的事。<br>有时，我们可能想重复运行一段代码数次，每一次使用一个不同的环境。在这种情况下，函数load可选的参数就没用了。此时，我们有另外两种选择。<br>第一种选择是使用调试库中的函数debug.setupvalue。顾名思义，函数setupvalue允许改变任何指定函数的上值，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">load</span>(<span class="string">&quot;b = 10; return a&quot;</span>)</span><br><span class="line">env = &#123;a = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">setupvalue</span>(f,<span class="number">1</span>,env)</span><br><span class="line"><span class="built_in">print</span>(f())			<span class="comment">-- 20</span></span><br><span class="line"><span class="built_in">print</span>(env.b)		<span class="comment">-- 10</span></span><br></pre></td></tr></table></figure>
<p>setupvalue的第一个参数是指定的函数，第二个参数是上值的索引，第三个参数是新的上值。对于这种用法，第二个参数永远是1：当函数表示的是一段代码时，Lua语言可以保证它只有一个上值且上值就是_ENV。<br>这种方式的一个小缺点在于依赖调试库。调试库打破了有关程序的一些常见假设。例如，debug.setupvalue打破了Lua语言的可见性规则，而可见性规则可以保证我们不能从词法定界的范围外访问局部变量。<br>另一种在几个不同环境中运行代码段的方式是每次加载代码时稍微对其进行一下修改。假设我们在要加载的代码段钱加入一行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">_ENV</span> = ...;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意，由于Lua语言把所有的代码段都当做可变长参数函数进行编译，因此，多出的这一行代码会把传给代码段的第一个参数赋值_ENV，从而把参数设为环境。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prefix = <span class="string">&quot;_ENV = ...;&quot;</span></span><br><span class="line">f = loadwithprefix(prefix,<span class="built_in">io</span>.<span class="built_in">lines</span>(filename,<span class="string">&quot;*L&quot;</span>))</span><br><span class="line">...</span><br><span class="line">env1 = &#123;&#125;</span><br><span class="line">f(env1)</span><br><span class="line">env2 = &#123;&#125;</span><br><span class="line">f(env2)</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/27/Lua%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/Lua%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">Lua教程之Lua打乱数组排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-27 14:59:49" itemprop="dateCreated datePublished" datetime="2020-04-27T14:59:49+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>打乱有序数组，生成随机数组,在很多场景中都会用到这个函数，非常好用</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/27/Lua%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="南锋"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">南锋</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">174</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com/" title="http:&#x2F;&#x2F;yoursite.com" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南锋</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
