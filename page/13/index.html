<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="南锋">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/17/Lua%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/17/Lua%E5%8D%8F%E7%A8%8B/" class="post-title-link" itemprop="url">Lua协程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-17 14:22:53" itemprop="dateCreated datePublished" datetime="2020-05-17T14:22:53+08:00">2020-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>协程可以颠倒调用者和被调用者的关系，而且这种灵活性解决了软件架构中被称为“谁是老大”或者”谁拥有主循环“的问题。这正是对诸如事件驱动编程、通过构造器构建迭代器和协作式多线程等几个看上去并不相关的问题的泛化，而协程以简单和高效的方式解决了这些问题。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>从多线程的角度看，协程与线程类似：协程是一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享了全局变量和其他几乎一切资源。线程与协程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程却需要彼此协作地运行，即在任意指定的时刻只能有一个协程运行。且只有当正在运行的协程显式地要求被挂起时其执行才会暂停。</p>
<h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><p>Lua语言中协程相关的所有函数都被放在表coroutine中。函数create用于创建新协程，该函数只有一个参数，即协程要执行的代码的函数。函数create返回一个”thread”类型的值，即新协程。通常，函数create的参数是一个匿名函数，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span><span class="built_in">print</span>(<span class="string">&quot;hi&quot;</span>)<span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co))			<span class="comment">-- thread</span></span><br></pre></td></tr></table></figure>
<p>一个协程有以下四种状态，即挂起、运行、正常和死亡。我们可以通过函数coroutine.status来检查协程的状态：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.statye(co))		<span class="comment">-- suspended</span></span><br></pre></td></tr></table></figure>
<p>如果在交互模式下运行上述代码，最好在最后一行加上一个分号来阻止输出函数resume的返回值。在上例中，协程体只是简单地打印了”hi”后便终止了，然后协程就编程了死亡状态：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co)) <span class="comment">-- end</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，协程看上去也就是一种复杂的调用函数的方式。协程的真正强大之处在于函数yield，函数可以让一个运行中的协程挂起自己，然后在后续恢复运行。例如下面这个简单示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>,i)</span><br><span class="line">		<span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>其中，协程进行了一个循环，在循环中输出数字并在每次打印后挂起。当唤醒协程后，它就会开始执行直到遇见第一个yield:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 	1</span></span><br></pre></td></tr></table></figure>
<p>此时，如果我们查看协程状态，会发现协程处于挂起状态，因此可以再次恢复运行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))			<span class="comment">-- suspended</span></span><br></pre></td></tr></table></figure>
<p>从协程的角度看，在挂起期间发生的活动都发生协程调用yield期间。当我们唤醒协程时，函数yield才会最终返回，然后协程会继续执行直到遇到下一个yield或执行结束：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 2</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 3</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- co 10</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)	<span class="comment">-- 不输出任何数据</span></span><br></pre></td></tr></table></figure>
<p>在最后一次调用resume时，协程体执行完毕并返回，比输出任何数据。如果我们试图再次唤醒它，函数resume将返回false及一条错误信息：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))</span><br><span class="line"><span class="comment">-- false cannot resume dead coroutine</span></span><br></pre></td></tr></table></figure>
<p>请注意，像函数pcall一样，函数resume也运行在保护模式中。因此，如果协程在执行中出错，Lua语言不会显示错误信息，而是将错误信息返回给函数resume。<br>当协程A唤醒协程B时，协程A既不是挂起状态，也不是运行状态。所以，协程A此时的状态就被称为正常状态。<br>Lua语言中一个非常有用的机制是通过一对resume-yield来交换数据。第一个resume函数会把所有的额外参数传递给协程的主函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a,b,c)</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>,a,b,c+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)		<span class="comment">-- co  1 2 5</span></span><br></pre></td></tr></table></figure>
<p>在函数coroutine.resume的返回值中，第一个返回值为true时表示没有错误，之后的返回值对应函数yield的参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+b,a-b)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">20</span>,<span class="number">10</span>))		<span class="comment">-- true 30 10</span></span><br></pre></td></tr></table></figure>
<p>与之对应的是，函数 coroutine.yield的返回值是对应的resume的参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;co1&quot;</span>,x)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;co2&quot;</span>,<span class="built_in">coroutine</span>.<span class="built_in">yield</span>())</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="string">&quot;hi&quot;</span>)		<span class="comment">-- co1 hi</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">4</span>,<span class="number">5</span>)		<span class="comment">-- co2 4 5</span></span><br></pre></td></tr></table></figure>
<p>最后，当一个协程运行结束时，主函数所返回的值都将变成对应函数resume的返回值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span>,<span class="number">7</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))		<span class="comment">-- true 6,7</span></span><br></pre></td></tr></table></figure>
<p>我们很少在同一个协程中用到所有这些机制，但每种机制都有各自的用处。<br>虽然协程的概念很容易理解，但涉及的细节其实有很多。因此，对于那些已经对协程有一定了解的读者来首，有必要再进行进一步学习前先理清一些细节。Lua语言提供的是所谓的非对称协程，也就是说需要两个函数来控制协程的执行，一个用于挂起协程的执行，另外一个用于恢复协程的执行。而其他一些语言提供的是对称协程，只提供一个函数用于在一个协程和另一个协程之间切换控制权。<br>一些人将非对称协程称为semi-coroutines。然而，其他人则用相同的术语半协程表示协程的一种受限制版实现。在这种实现中，一个协程只能在它没有调用其他函数时才可以挂起，即在调用栈中没有挂起的调用时。换句话说，只有这种半协程的主函数才能让出执行权。</p>
<h2 id="哪个协程占据主循环"><a href="#哪个协程占据主循环" class="headerlink" title="哪个协程占据主循环"></a>哪个协程占据主循环</h2><p>有关协程的最经典实例之一就是生产者-消费者问题。在生产者-消费者问题中设计两个函数，一个函数不断产生值，另一个函数不断地消费这些值。这两个函数可能形式如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()		<span class="comment">-- 产生新值</span></span><br><span class="line">		send(x)					<span class="comment">-- 发给消费者</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(  )</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> x = receive()		<span class="comment">-- 接收来自生产者的值</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(x,<span class="string">&quot;\n&quot;</span>)		<span class="comment">-- 消费 </span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>为了简化这个示例，生产者和消费者都是无限循环的；不过，可以很容易地将其修改为没有数据需要处理时退出循环。这里的问题在于如何将send与receive匹配起来，也就是”谁占据主循环“问题的典型示例。其中，生产者和消费者都处于活跃状态，它们各自具有自己的循环，并且都将对方视为一个可调用的服务。对于这个特定的示例，可以很容易地修改其中一个函数的结构，展开它的循环使其成为一个被动的代理。不过，在其他的真实场景下，这样的代码结构改动可能会很不容易。<br>由于成对的resume-yield可以颠倒调用者与被调用者之间的关系，因此协程提供了一种无须修改生产者和消费者的代码结构就能匹配它们执行顺序的理想工具。当一个协程调用函数yield时，它不是进入了一个新函数，而是返回一个挂起的调用。同样地，对函数resume的调用也不会启动一个新函数，而是返回一个对函数yield的调用。这种特性正好可以用于匹配send和receive,使得双方都认为自己是主动方而对方是被动方。因此，receive唤醒生产者的执行使其能生成一个新值，然后send则让出执行权，将生成的值传递给消费者：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">status</span>, value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(producer)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当然，生产者现在必须运行在一个协程里：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer - <span class="built_in">coroutine</span>.<span class="built_in">create</span>(producer)</span><br></pre></td></tr></table></figure>
<p>在这种设计中，程序通过调用消费者启动。当消费者需要新值时就唤醒生产者，生产者向消费者返回新值后挂起，直到消费者再次将其唤醒。因此，我们将这种设计称为消费者驱动式的设计。另一种方式则是使用生产者驱动式的设计，其中消费者是协程。虽然上述两种设计思路看上去是相反的，但实际上它们的整体思路相同。<br>我们可以使用过滤器来扩展上述设计。过滤器位于生产者和消费者之间，用于完成一些对数据进行某种变换的任务。过滤器即是一个消费者又是一个生产者，它通过唤醒一个生产者来获得新值，然后又将变换后的值传递给消费者。例如，我们可以在前面代码中添加一个过滤器以实现在每行的起始处插入行号：</p>
<blockquote>
<p>示例  使用过滤器的生产者和消费者</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(prod)</span></span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">status</span>, value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(prod)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">local</span>  x = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">			send(x)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">(prod)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">for</span> line = <span class="number">1</span>,<span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">local</span> x = receive(prod)</span><br><span class="line">			x = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%5d %s&quot;</span>,line,x)</span><br><span class="line">			send(x)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(prod)</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> x = receive(prod)</span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(x,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">consumer(filter(producer()))</span><br></pre></td></tr></table></figure>
<p>代码的最后一行只是简单地创建出所需的各个组件，将这些组件连接在一起，然后启动消费者。</p>
<h2 id="将协程用作迭代器"><a href="#将协程用作迭代器" class="headerlink" title="将协程用作迭代器"></a>将协程用作迭代器</h2><p>我们可以讲循环迭代器视为生产者-消费者模式的一种特例：一个迭代器会生产由循环体消费的内容。因此，用协程来实现迭代器看上去就很合适。的确。协程为实现这类任务提供了一种强大的工具。同时，协程最关键的特行是能够颠倒调用者与被调用者之间的关系。有了这种特性，我们在编写迭代器时就无须担心如何保存连续调用之间的状态了。<br>为了说明这类用途，让我们编写一个遍历指定数组所有排列的迭代器。要直接编写这种迭代器并不容易，但如果要编写一个递归函数来产生所有的排列则不是很难。思路很简单，只要依次将每个数组元素放到最后一个位置，然后递归地生成其余元素的所有排列即可。</p>
<blockquote>
<p>示例 一个生成排列的函数</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span><span class="params">(a,n)</span></span></span><br><span class="line">	n = n <span class="keyword">or</span> #a</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">		printResult(a)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span>, n <span class="keyword">do</span></span><br><span class="line">			a[n],a[i] = a[i], a[n]</span><br><span class="line">			permgen(a,n<span class="number">-1</span>)</span><br><span class="line">			a[n],a[i] = a[i], a[n]</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还需要定义一个合适的函数printResult来输出结果，并使用恰当的参数调用premgen</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printResult</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span> <span class="built_in">io</span>.<span class="built_in">write</span>(a[i],<span class="string">&quot;&quot;</span>) <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">permgen(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment">--	2 3 4 1</span></span><br><span class="line"><span class="comment">--  3 2 4 1</span></span><br><span class="line"><span class="comment">--  3 4 2 1</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">--  2 1 3 4</span></span><br><span class="line"><span class="comment">--  1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>当有了生成器之后，将其转换为迭代器就很容易了。首先，我们把printResult改为yield:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span><span class="params">(a,n)</span></span></span><br><span class="line">	n = n <span class="keyword">or</span> #a</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		同前</span><br></pre></td></tr></table></figure>
<p>然后，我们定义一个将生成器放入协程运行并创建迭代函数的工厂。迭代器只是简单地唤醒协程，让其生产下一个排列：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permutations</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>permgen(a) <span class="keyword">end</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">local</span> code ,res = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有了上面的这些，在for循环中遍历一个数组的所有排列就非常简单了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> permutations&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125; <span class="keyword">do</span></span><br><span class="line">	printResult(p)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--	b c a</span></span><br><span class="line"><span class="comment">--	c b a</span></span><br><span class="line"><span class="comment">--	c a b</span></span><br><span class="line"><span class="comment">--	a c b</span></span><br><span class="line"><span class="comment">-- 	b a c </span></span><br><span class="line"><span class="comment">--	a b c</span></span><br></pre></td></tr></table></figure>
<p>函数permutations使用了Lua语言中一种常见的模式，就是唤醒对应协程的调用包装在一个函数中。由于这种模式比较常见，所以Lua语言专门提供了一种特殊的函数coroutine.wrap来完成这个功能。与函数create类似，函数wrap也用来创建一个新的协程。但不同的是，函数wrap返回的不是协程本身而是一个函数，当这个函数被调用时会唤醒协程。与原始的函数resume不同，该函数的第一个返回值不是错误代码，当遇到错误时该函数会抛出异常，我们可以使用函数wrap改写permutations:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permutations</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> permgen(a) <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>通常，函数coroutine.wrap比函数coroutine.create更易于使用。它为我们提供了对于操作协程而言所需的功能，即一个唤醒协程的函数。不过，该函数缺乏灵活性。我们无法检查通过函数wrap所创建的协程的状态，也无法检查运行的异常。</p>
<h2 id="事件驱动式编程"><a href="#事件驱动式编程" class="headerlink" title="事件驱动式编程"></a>事件驱动式编程</h2><p>虽然第一眼看上去不是特别明显，但实际上传统的时间驱动编程伴随的典型问题就是衍生自who-is-the-boss问题。<br>在典型的事件驱动平台下，一个外部的实体向我们程序中所谓的事件循环或运行循环生成事件。这里，我们的代码很明显不是主循环。我们的程序变成了事件循环的附属品，使得我们的程序成为了一组无须任何显式关联的、相互独立的事件处理程序的集合。<br>再举一个更加具体的例子，假设有一个与libuv类似的异步I&#x2F;O库，该库中有四个与我们的示例有关的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lib.runloop();</span><br><span class="line">lib.readline(stream,callback);</span><br><span class="line">lib.writeline(stream,line,callback);</span><br><span class="line">lib.stop();</span><br></pre></td></tr></table></figure>
<p>第一个函数运行事件循环，在其中处理所有发生的事件并调用对应的回调函数。一个典型的事件驱动程序初始化某些机制然后调用这个函数，这个函数就变成了应用的主循环。第二个函数指示库从指定的流中读取一行，并在读取完成后带着读取的结果调用指定的回调函数。第三个函数与第二个函数类似，只是该函数写入一行。最后一个函数打破事件循环，通常用于结束程序。</p>
<blockquote>
<p>示例 异步I&#x2F;O库的简单实现</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cmdQueue = &#123;&#125;		<span class="comment">-- 挂起操作的队列</span></span><br><span class="line"><span class="keyword">local</span> lib = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.readline</span> <span class="params">(stream,callback)</span></span></span><br><span class="line">	<span class="keyword">local</span> nextCmd = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		callback(stream:<span class="built_in">read</span>())</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(cmdQueue,nextCmd)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.writeline</span><span class="params">(stream,line,callback)</span></span></span><br><span class="line">	<span class="keyword">local</span> nextCmd = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		callback(stream:<span class="built_in">write</span>(line))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(cmdQueue,nextCmd)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.stop</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">insert</span>(cmdQueue,<span class="string">&quot;stop&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.runloop</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> nextCmd = <span class="built_in">table</span>.<span class="built_in">remove</span>(cmdQueue,<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> nextCmd == <span class="string">&quot;stop&quot;</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nextCmd()</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> lib</span><br></pre></td></tr></table></figure>
<p>上述代码是一种简单而丑陋的实现。该程序的”事件队列“实际上是一个由挂起操作组成的列表，当这些操作被异步调用时会产生事件。尽管很丑陋，但该程序还是完成了之前我们提到的功能，也使得我们无须使用真实的异步库就可以测试接下来的例子。<br>现在，让我们编写一个使用这个库的简单程序，这个程序把输入流中的所有行读取到一个表中，然后再逆序将其写到输出流中。如果使用同步I&#x2F;O，那么代码可能如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> inp = <span class="built_in">io</span>.<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">local</span> out = <span class="built_in">io</span>.<span class="built_in">output</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> inp:<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	t[#t + <span class="number">1</span>] = line </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = #t, <span class="number">1</span> , <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">	out:<span class="built_in">write</span>(t[i],<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>现在，让我们再使用异步I&#x2F;O库按照时间驱动的方式重写这个程序。</p>
<blockquote>
<p>示例  使用事件驱动方式逆序一个文件</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;async-lib&quot;</span></span><br><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> inp = <span class="built_in">io</span>.<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">local</span> out = <span class="built_in">io</span>.<span class="built_in">output</span>()</span><br><span class="line"><span class="keyword">local</span> i </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写入行的时间处理函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">putline</span><span class="params">()</span></span></span><br><span class="line">	i = i - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		lib.stop()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		lib.writeline(out,t[i] .. <span class="string">&quot;\n&quot;</span>,putline)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读取行的事件处理函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getline</span> <span class="params">(line)</span></span></span><br><span class="line">	<span class="keyword">if</span> line <span class="keyword">then</span></span><br><span class="line">		t[#t + <span class="number">1</span>] = line</span><br><span class="line">		lib.readline(inp,getline)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i = #t + <span class="number">1</span></span><br><span class="line">		putline()</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">lib.readline(inp,getline)</span><br><span class="line">lib.runloop()</span><br></pre></td></tr></table></figure>
<p>作为一种典型的事件驱动场景，由于主循环位于库中，因此所有的循环都消失了，这些循环被以事件区分的递归调用所取代。尽管我们可以通过使用闭包以后续传递风格进行改进，但仍然不能编写我们自己的循环。如果要这么做，那么必须通过递归来重写。<br>协程可以让我们使用事件循环来简化循环的代码，其核心思想是使用协程运行主要代码，即在每次调用库时将回调函数设置为唤醒协程的函数然后让出执行权。</p>
<blockquote>
<p>示例  是用异步库运行同步代码</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;async-lib&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(code)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		code()</span><br><span class="line">		lib.stop()</span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line">	co()</span><br><span class="line">	lib.runloop()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putline</span> <span class="params">(stream,line)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">running</span>()</span><br><span class="line">	<span class="keyword">local</span> callback = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co) <span class="keyword">end</span>)</span><br><span class="line">	lib.writeline(stream,line,callback)</span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getline</span><span class="params">(stream,line)</span></span></span><br><span class="line">	<span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">running</span>()</span><br><span class="line">	<span class="keyword">local</span> callback = (<span class="function"><span class="keyword">function</span><span class="params">(l)</span></span> <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,l) <span class="keyword">end</span>)</span><br><span class="line">	lib.readline(stream,callback)</span><br><span class="line">	<span class="keyword">local</span> line = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">	<span class="keyword">return</span> line </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>顾名思义，run函数运行通过参数传入的同步代码。该函数首先创建一个协程来运行指定的代码，并在完成后停止事件循环。然后，该函数唤醒协程，进入事件循环。<br>函数getline和putline模拟了同步I&#x2F;O。正如之前强调的，这两个函数都调用了恰当的异步函数，这些异步函数被当做唤醒调用协程的回调函数传入。之后，异步函数挂起，然后将控制权返回给事件循环。一旦异步操作完成，事件循环就会调用函数来唤醒触发异步函数的协程。<br>使用这个库，我们可以在异步库上运行同步代码了。如下示例再次实现了逆序行的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">	<span class="keyword">local</span> inp = <span class="built_in">io</span>.<span class="built_in">input</span>()</span><br><span class="line">	<span class="keyword">local</span> out = <span class="built_in">io</span>.<span class="built_in">output</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> line = getline(inp)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		t[#t + <span class="number">1</span>] = line</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = #t, <span class="number">1</span> ,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		putline(out,t[i] .. <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>除了使用get&#x2F;putline来进行I&#x2F;O操作和运行在run以内，上述代码与之前的同步示例等价。在同步代码结构的外表之下，程序其实是以事件驱动模式运行的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/15/Lua%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/Lua%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">Lua连续教程之Lua垃圾收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 23:17:59" itemprop="dateCreated datePublished" datetime="2020-05-15T23:17:59+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言使用自动内存管理。程序可以创建对象，但却没有函数来删除对象。Lua语言通过垃圾收集自动删除称为垃圾的对象，从而将程序员从内存管理的绝大部分负担中解放出来。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>更重要的是，将程序员从与内存管理相关的大多数Bug中解放出来。例如无效指针和内存泄露等问题。<br>在一个理想的环境中，垃圾收集器对程序员来说是不可见的，就像一个好的清洁工不会和其他工人打交道一样。不过，有时即使是智能的垃圾收集器也会需要我们的辅助。在某些关键的性能阶段，我们可能需要将其停止，或者让只在特定的时间运行。另外，一个垃圾收集器只能收集它确定是垃圾的内容，而不能猜测我们把什么当作垃圾。没有垃圾收集器能够做到让我们完全不用操心资源管理的问题，比如驻留内存和外部资源。<br>弱引用表、析构器和函数collectgarbage是在Lua语言中用来辅助垃圾收集器的主要机制。弱引用表允许收集Lua语言中还可以被程序访问的对象；析构器允许收集不在垃圾收集器直接控制下的外部对象；函数collectgarbage则允许我们控制垃圾收集器的步长。</p>
<h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>我们知道，数组的有效部分总是向顶部扩展的，但Lua语言却不知道。如果弹出一个元素时只是简单地递减顶部索引，那么这个仍然留在数组中的对象对于Lua语言来说并不是垃圾。同理，即使是程序不会再用到的、存储在全局变量中的对象，对于Lua语言来说也不是垃圾。在这两种情况下，都需要我们将这些对象所在的位置赋值为nil，以便这些位置不会锁定可释放的对象。<br>不过，简单地清除引用可能还不够。在有些情况下，还需要程序和垃圾收集器之间的协作。一个典型的例子是，当我们要保存某些类型的活跃对象的列表时。这个需要看上去简单，我们只需要把每个新对象插入数组即可；但是，一旦一个对象成为了数组的一部分，它就再也无法被回收！虽然已经没有其他任何地方在引用它，但数组依然在引用它。除非我们告诉Lua语言数组对该对象的引用不应该阻碍对此对象的回收，否则Lua语言本身是无从知晓的。<br>弱引用表就是这样一个用来告知Lua语言一个引用不应阻止一个对象回收的机制。所谓所引用是一种不在垃圾收集器考虑范围内的对象引用。如果一个对象的所有引用都是弱引用，弱引用表就是元素均为弱引用的表，这意味着如果一个对象只被一个弱引用持有，那么Lua语言最终会回收这个对象。<br>表由键值对组成，其两者都可以容纳任何类型的对象。在正常情况下，垃圾收集器不会回收一个在可访问的表中作为键或值的对象。也就是说，键和值都是强引用，它们会阻止对其所指向对象的回收。在一个弱引用表中，键和值都可以是弱引用的。这就意味着有三种类型的弱引用表，即具有弱引用键的表、具有弱引用值的表及同时具有弱引用键和值的表。不论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。<br>一个表是否为弱引用表是由其元表中的__mode字段决定的。当这个字段存在时，其值应为一个字符串：如果这个字符串是”k”，那么这个表的键是弱引用的；如果这个字符串是”v”，那么这个表的值是弱引用的；如果这个字符串是”kv”，那么这个表的键和值都是弱引用的。下面的示例虽然有些可以，但演示了弱引用表的基本行为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">mt = &#123;<span class="built_in">__mode</span> = <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(a,mt)		<span class="comment">-- 现在&#x27;a&#x27;的键是弱引用的了</span></span><br><span class="line">key = &#123;&#125;</span><br><span class="line">a[key] = <span class="number">1</span>				<span class="comment">-- 创建第一个键</span></span><br><span class="line">key = &#123;&#125;</span><br><span class="line">a[key] = <span class="number">2</span>				<span class="comment">-- 创建第二个键</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 强制进行垃圾回收</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span>		<span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
<p>在本例中，第二句赋值key &#x3D; {}覆盖了指向第一个键的索引。调用collectgarbage强制垃圾收集器进行一次完整的垃圾手机。由于已经没有指向第一个键的其他引用个，因此Lua语言会回收这个键并从表中删除对应的元素。然而，由于第二个键仍然被变量key所引用，因此Lua不会回收它。<br>请注意，只有对象可以从弱引用表中被移除，而像数字和布尔这样的“值”是不可回收的。例如，如果我们在表a中插入一个数值类型的键，那么垃圾收集器永远不会回收它。当然，如果在一个值为弱引用的弱引用表中，一个数值类型键相关联的值被回收了，那么整个元素都会从这个弱引用表中被删除。<br>字符串在这里表现了一些细微的差别，虽然从实现的角度看字符串是可回收的，但字符串又与其他的可回收对象不同。其他的对象，例如表和闭包，都是被显式创建的。例如，当Lua语言对表达式{}求值时会创建一个新表。</p>
<h2 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h2><p>空间换时间是一种常见的编程技巧。我们可以通过记忆函数的执行结果，在后续使用相同参数再次调用该函数时直接返回之前记忆的结果，来加快函数的运行速度。<br>假设有一个通用的服务器，该服务器接收的请求是以字符串形式表示的Lua语言代码。每当服务器接收到一个请求时，它就对字符串运行load函数，然后再调用编译后的函数。不过，函数load的开销很昂贵，而且发送给服务器的某些命令的出现频率可能很高。这样，与其每次收到一条诸如”closeconnection()”这样的常见命令就重复地调用函数load，还不如让服务器用一个辅助表记忆所有函数load的执行结果。在调用函数load前，服务器先在表中检查指定的字符串是否已经被处理过。如果没有，就调用函数load并将返回值保存到表中。我们可以将这种行为封装为一个新的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mem_loadstring</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = results[s]</span><br><span class="line">	<span class="keyword">if</span> res == nli <span class="keyword">then</span></span><br><span class="line">		res = <span class="built_in">assert</span>(laod(s))</span><br><span class="line">		results[s] = res</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种模式节省的开销非常可观。但是，它也可能导致不易察觉的资源浪费。虽然有些命令会重复出现，但也有很多命令可能就出现一次。渐渐地，表results会堆积上服务器收到的所有命令及编译结果；在运行一段足够长的时间后，这种行为会耗尽服务器的内存。<br>弱引用表为解决这个问题提供了一种简单的方案，如果表results具有弱引用的值，那么每个垃圾收集周期都会删除所有那个时刻未使用的编译结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(results,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;v&quot;</span>&#125;)		<span class="comment">-- 让值称为弱引用</span></span><br><span class="line">funciton mem_loadstring(s)</span><br><span class="line"><span class="comment">--下面内容同前</span></span><br></pre></td></tr></table></figure>
<p>实际上，因为索引永远是字符串，所以如果愿意的话，我们可以让这个表变成完全弱引用的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(results,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;kv&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>最终达到的效果是完全一样的。<br>记忆技术还可以用来确保某类对象的唯一性。例如，假设一个系统用具有三个相同取值范围的字段red、green和blue的表来表示颜色，一个简单的颜色工厂函数每被调用一次就生成一个颜色：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRGB</span><span class="params">(r,g,b)</span></span></span><br><span class="line">	<span class="keyword">return</span> &#123;red = r, green = g ,blue = b&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>使用记忆技术，我们就可以为相同的颜色复用相同的表。要为每一种颜色创建一个唯一的键，只需要使用分隔符把颜色的索引连接起来即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(results,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;v&quot;</span>&#125;)		<span class="comment">-- 让值称为弱引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRGB</span><span class="params">( r,g,b )</span></span></span><br><span class="line">	<span class="keyword">local</span> key = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,r,g,b)</span><br><span class="line">	<span class="keyword">local</span> color = results[key]</span><br><span class="line">	<span class="keyword">if</span> color == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">		color = &#123;red = r, green = g, blue = b&#125;</span><br><span class="line">		results[key] = color</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> color</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种实现的一个有趣结果是，由于两种颜色存在的颜色必定是由同一个表来表示，所以用户可以使用基本的相等运算符比较两种颜色。因为随着时间的迁移垃圾收集器会清理表results，所以一种指定的颜色在不同的时间内可能由不同的表来表示。不过，只要一种颜色正在被使用，它就不会从results中被移除。因此，一种颜色与一种新颜色相比已经存在了多长时间，这种颜色对应的表也存在了对应长度的时间，也可以被新颜色复用。</p>
<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><p>弱引用表的另外一种重要应用是将属性与对象关联起来。在各种各样的情况下，我们都需要把某种属性绑定到某个对象，例如函数名、表的默认值及数组的大小等。<br>当对象是一个表时，可以通过适当的唯一键把属性存储在这个表自身中。不过，如果对象不是一个表，那么它就不能保存它自己的属性。另外，即使是表，有时我们也不想把属性保存在原始的对象。例如，当想保持属性的私有性时，或不想让属性干扰表的遍历时，就需要用其他办法来关联对象和属性。<br>当然，外部表为对象和属性的映射提供了一种理性的方法，即对偶表示，其中将对象用作键、将对象的属性用作值。由于Lua语言允许使用任意类型的对象作为键，因此一个外部表可以保存任意类型对象的属性。此外，存储在外部表中的属性不会干扰其他对象，并且可以像表本身一样是私有的。<br>不过，这个看似完美的方案有一个重大缺陷：一旦我们把一个对象当作表中的一个键，那么就是引用了它。Lua语言无法回收一个正在被用作键的对象。例如，如果使用一个普通的表来映射函数和函数名，那么这些函数就永远无法被回收。</p>
<h2 id="回顾具有默认值的表"><a href="#回顾具有默认值的表" class="headerlink" title="回顾具有默认值的表"></a>回顾具有默认值的表</h2><p>在第一种解决方案中，我们使用了一个弱引用表来映射每一个表和它的默认值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> defaults = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(defaults,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;k&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span> <span class="keyword">return</span> defaults[t] <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefault</span> <span class="params">(t,d)</span></span></span><br><span class="line">	defaults[t] = d</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这是对偶表示的一种典型应用，其中使用了defaults[t]来表示t.defaults。如果表defaults没有弱引用的键，那么所有具有默认值的表就会永远存在下去。<br>在第二种解决方案中，我们对不同的默认值使用了不同的元素，在遇到重复的默认值时会复用相同的元表。这是记忆技术的一种典型应用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> metas = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(metas,&#123;<span class="built_in">__mode</span> = <span class="string">&quot;v&quot;</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefault</span><span class="params">(t,d)</span></span></span><br><span class="line">	<span class="keyword">local</span> mt = metas[d]</span><br><span class="line">	<span class="keyword">if</span> mt == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">		mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> d <span class="keyword">end</span>&#125;</span><br><span class="line">		metas[d] = mt</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们使用弱引用的值使得不再被使用的元表能够回收。<br>这两种实现哪种更好取决于具体的情况。这两种实现具有类似的复杂度和性能表现，第一种实现需要为每个具有默认值的表分配几个字节的内存，而第二种实现则需要为每个不同的默认值分配若干内存。因此，如果应用中有上千个具有少量不同默认值的表，那么第二种实现明显更好。不过，如果只有少量共享默认值的表，那么就应该选择第一种实现。</p>
<h2 id="瞬表"><a href="#瞬表" class="headerlink" title="瞬表"></a>瞬表</h2><p>一种棘手的情况是，一个具有弱引用键的表中的值又引用了对应的键。<br>这种情况看上去更加常见。一个典型的示例是常量函数工厂。这种工厂的参数是一个对象，返回值是一个被调用时返回传入对象的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factory</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> o <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种工厂时实现记忆的一种很好的手段，可以避免在闭包已经存在时又创建新的闭包。</p>
<blockquote>
<p>示例  使用记忆技术的常量函数工厂</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> mem = &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(mem, &#123;<span class="built_in">__mode</span> = <span class="string">&quot;k&quot;</span>&#125;)</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">factory</span><span class="params">(o)</span></span></span><br><span class="line">		<span class="keyword">local</span> res = mem[o]</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">			res = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> o <span class="keyword">end</span>)</span><br><span class="line">			mem[o] = res</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，这里另有玄机。请注意，表mem中与一个对象关联的值回指了它自己的键。虽然表中的键是弱引用的，但是表中的值却不是弱引用的。从一个弱引用表的标准理解看，记忆表中没有任何东西会被移除。由于值不是弱引用的，所以对于每一个函数来说都存在一个强引用。每一个函数都指向其对应的对象，因而对于每一个键来说都存在一个强应用。因此，即使有弱引用的键，这些对象也不会被回收。<br>不过，这种严格的理解不是特别有用。大多数人希望一个表中的值只能通过对应的键来访问。我们可以认为之前的情况是某种环，其中闭包引用了指回闭包的对象。<br>Lua语言通过瞬表的概念来解决上述问题。在Lua语言中，一个具有弱引用键和强引用值的表是一个瞬表。在一个顺表中，一个键的可访问性控制着对应值的可访问性。更确切地说，考虑瞬表中的一个元素，指向的v的引用只有当存在某些指向k的其他外部引用存在时才是强引用，否则，即使v引用了k，垃圾收集器最终会收集k并把元素从表中移除。</p>
<h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>虽然垃圾收集器的目标是回收对象，但是它可以帮助程序员来释放外部资源。处于这种目的，几种编程语言提供了析构器。析构器是一个与对象关联的函数，当该对象即将被回收时该函数会被调用。<br>Lua语言通过元方法__gc实现析构器，如下例所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o,&#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span>&#125;)</span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>在本例中，我们首先创建一个带有__gc元方法元表的表。然后，抹去与这个表的唯一联系，再强制进行一次完整的垃圾回收。在垃圾回收期间，Lua语言发现表已经不再是可访问的了，因此调用表的析构器，也就是元方法__gc。<br>Lua语言中，析构器的一个微妙之处在于“将一个对象标记为需要析构”的概念。通过给对象设置一个具有非空__gc元方法的元表，就可以把一个对象标记为需要进行析构处理。如果不标记对象，那么对象就不会被析构。我们编写的大多数代码会正常运行，但会发生某些奇怪的行为，比如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line">mt = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o,mt)</span><br><span class="line">mt.<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span></span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- (print nothing)</span></span><br></pre></td></tr></table></figure>
<p>这里，我们确实要给对象o设置了元表，但是这个元表没有__gc方法，因此对象没有被标记为需要进行析构处理。即使我们后续给元表增加了元方法__gc，Lua语言也发现不了这种赋值的特殊之处，因此不会把对象标记为需要进行析构处理。<br>正如我们所提到的，这很少会有问题。在设置元表后，很少会改变元方法。如果真的需要在后续设置元方法，那么可以给字段__gc先赋一个任意值作为占位符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line">mt = &#123;<span class="built_in">__gc</span> = <span class="literal">true</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o,mt)</span><br><span class="line">mt.<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span></span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>现在，由于元表有了__gc字段，因此对象会被正确地标记为需要析构处理。如果后续再设置元方法也不会有问题，只要元方法时一个正确的函数，Lua语言就能够调用它。<br>当垃圾收集器在同一个周期中析构多个对象时，它会按照对象被标记为需要析构处理的顺序逆序调用这些对象的析构器。请考虑如下的示例，该示例创建了一个由带有析构器的对象所组成的链表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mt = &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o[<span class="number">1</span>]) <span class="keyword">end</span>&#125;</span><br><span class="line">list = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> , <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">	list = <span class="built_in">setmetatable</span>(&#123;i,link = list&#125;,mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">list = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()</span><br></pre></td></tr></table></figure>
<p>第一个被析构的对象是3，也就是最后一个被标记的对象。<br>一种常见的误解是认为正在被回收的对象之间的关联会影响对象析构的顺序。例如，有些人可能认为上例中的对象2必须在对象1之前被析构，因为存在从2到1的关联。但是，关联会行程环。所以，关联并不会影响析构器执行的顺序。<br>有关析构器的另个一微妙之处是复苏。当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新编程活跃的。笔者把这称为临时复苏。在析构器执行期间，我们无法阻止析构器把该对象存储在全局变量中，使得该对象在析构器返回后仍然可以访问，笔者把这称为永久复苏。</p>
<p>复苏必须是可传递的。考虑如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;x = <span class="string">&quot;this is A&quot;</span>&#125;</span><br><span class="line">B = &#123;f = A&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(B,&#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.f.x) <span class="keyword">end</span>&#125;)</span><br><span class="line">A,B = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>() 		<span class="comment">-- this is A</span></span><br></pre></td></tr></table></figure>
<p>B的析构器访问了A，因此A在B析构前不能被回收，Lua语言在运行析构器之前必须同时复苏B和A。<br>由于复苏的存在，Lua语言会在两个阶段中回收具有析构器的对象。当垃圾收集器首次发生某个具有析构器的对象不可达时，垃圾收集器就把这个对象复苏并将其放入等待被析构的队列中。一旦析构器开始执行，Lua语言就将对该对象标记为已被析构。当下一次垃圾收集器又发现这个对象不可达时，它就将这个对象删除。如果想保证我们程序中的所有垃圾都被真正地释放了的话，那么必须调用collectgarbage两次，第二次调用才会删除第一次调用中被析构的对象。<br>由于Lua语言在析构对象上设置了标记，每一个对象的析构器都会精确地运行一次。如果一个对象直到程序运行结束还没有被回收，那么Lua语言就会在整个Lua虚拟机关闭后调用它的析构器。这种特行在Lua语言中实现了某种形式的atexit函数，即在程序终结前立即运行的函数。我们所要做的就是创建一个带有析构器的表，然后把它锚定在某处，例如锚定到全局表中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;finishing Lua program&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,t)</span><br><span class="line"><span class="built_in">_G</span>[<span class="string">&quot;*AA*&quot;</span>] = t</span><br></pre></td></tr></table></figure>
<p>另外一个有趣的技巧会允许程序在每次完成垃圾回收后调用指定的函数。由于析构器只运行一次，所以这种技巧是让每个析构器创建一个用来运行下一个析构器的新对象，参考示例：</p>
<blockquote>
<p>示例 在每次GC后运行一个函数</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> mt = &#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;new cycle&quot;</span>)</span><br><span class="line">		<span class="built_in">setmetatable</span>(&#123;&#125;,<span class="built_in">getmetatable</span>(o))</span><br><span class="line">	<span class="keyword">end</span>&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(&#123;&#125;,mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 一次垃圾收集</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 一次垃圾收集</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()		<span class="comment">-- 一次垃圾收集</span></span><br></pre></td></tr></table></figure>
<p>具有析构器的对象和弱引用表之间的交互也有些微妙。在每个垃圾收集周期内，垃圾收集器会在调用析构器前清理弱应用表中的值，在调用析构器之后再清理键。这种行为的原理在于我们经常使用带有弱引用键的表来保存对象的属性，因此，析构器可能需要访问那些属性。不过，我们也会使用具有弱引用值的表来重用活跃的对象，在这种情况下，正在被析构的对象就不再有用了。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>一直到Lua5.0，Lua语言使用的都是一个简单的标记-清除式垃圾收集器。这种收集器又被称为“stop-the-world（全局暂停）”式的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期。每一个垃圾收集周期由四个阶段组成：标记、清理、清除和析构。<br>标记阶段把根节点集合标记为活跃，根结点集合由Lua语言可以直接访问的对象组成。在Lua语言中，这个集合只包括C注册表。<br>保存在一个活跃对象中的对象是程序可达的，因此也会被标记活跃。当所有可达对象都被标记为活跃后，标记阶段完成。<br>在开始清除阶段前，Lua语言先执行清理阶段，在这个阶段中处理析构器和弱引用表。首先，Lua语言遍历所有被标记为需要进行析构、但又没有被标记为活跃状态的对象。这些没有标记为活跃状态的对象会被标记为活跃，并被放在一个单独的列表中，这个列表会在析构阶段用到。然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。<br>清理阶段遍历所有对象。如果一个对象没有被标记为活跃，Lua语言就将其回收，否则，Lua语言清理标记，然后准备进行下一个清理周期。<br>最后，在析构阶段，Lua语言调用清理阶段被分离出的对象的析构器。<br>使用真正的垃圾收集器意味着Lua语言能够处理对象引用之间的环。在使用环形数据结构时，我们不需要花费外的精力，它们会像其他数据一样被回收。<br>Lua5.1使用了增量式垃圾收集器。这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是不需要在垃圾收集期间停止主程序的运行。相反，它与解释器一起交替运行。每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步（这意味着，在垃圾收集器工作期间，解释器可能会改变一个对象的可达性。为了保证垃圾收集器的正确性，垃圾收集器中的有些操作具有发现危险改动和纠正所涉及对象标记的内存屏障）。<br>Lua5.2引入了紧急垃圾收集。当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。</p>
<h2 id="控制垃圾收集的步长"><a href="#控制垃圾收集的步长" class="headerlink" title="控制垃圾收集的步长"></a>控制垃圾收集的步长</h2><p>通过函数collectgarbage可以对垃圾收集器进行一些额外的控制，该函数实际上是几个函数的集合体：第一个参数是一个可选的字符串，用来说明进行何种操作；有些选项使用一个整型作为第二个参数，称为data。<br>第一个参数的选项包括如下七个。<br>“stop”:停止垃圾收集器，知道使用选项”restart”再次调用collectgarbage。<br>“restart”:重启垃圾收集器。<br>“collect”:执行一次完整的垃圾收集，回收和析构所有不可达的对象。这是默认的选项。<br>“step”:执行某些垃圾收集工作，第二个参数data指明工作量，即在分配了data字节后垃圾收集器应该做什么。<br>“count”:以KB为单位返回当前自己已用内存数，该结果是一个浮点数，乘以1024得到的就是精确的字节数。该值包括了尚未被回收的死对象。<br>“setpause”:设置收集器的stepmul参数。参数data给出新值，也是以百分比为单位。<br>两个参数pause和stepmul控制着垃圾收集器的角色。任何垃圾收集器都是使用CPU时间换内存空间。在极端情况下，垃圾收集器可能根本不会运行。但是，不耗费CPU时间是以巨大的内存消耗为代价的。在另外一种极端的情况下，收集器可能每进行一次赋值就得运行一次完整的垃圾收集。程序能够使用尽可能少的内存，但是是以巨大的CPU消耗为代价的。pause和stepmul的默认值正式试图在这两个极端之间找到的对大多数应用来说足够好的平衡点。不过，在某些情况下，还是值得试着对它们进行优化。<br>参数pause用于控制垃圾收集器在一次手机完成后等待多久再开始新的一次手机。当值为零时，表示Lua语言在上一次垃圾回收结束后立即开始一次新的收集。当值为200%时表示在重启垃圾收集器前等待内存使用翻番。如果想消耗更多的CPU时间换取更低的内存消耗，那么可以把这个值设置得小一点。通常，我们应该把这个值设在0到200%之间。<br>参数stepmul控制对于每分配1KB内存，垃圾收集器应该进行多少工作。这个值越高，垃圾收集器使用的增量越小。一个像10000000%一样巨大的值会让收集器表现得像一个非增量的垃圾收集器。默认值是200%，地于100%的值会让收集器运行得很慢，以至于可能一次收集也完不成。<br>函数collectgarbage的另外一些参数用来在垃圾收集器运行时控制它的行为。同样，对于大多数程序员来说，默认值已经足够好了，但是对于一些特殊的应用，用手工控制可能会更好，游戏就经常需要这种类型的控制。例如，如果我们不想让垃圾收集在某些阶段运行，那么可以通过调用函数collectgarbage(“stop”)停止垃圾收集器，然后再调用collectgarbage(“restart”)重新启动垃圾收集器。在一些具有周期性休眠阶段的代码中，可以让垃圾收集器停止，然后在程序休眠期间调用collectgarbage(“step”,n)。要设置在每一个休眠期间进行多少工作，要么为n实验性地选择一个恰当的值，要么把n设成零，然后在一个循环中调用函数collectgarbage直到休眠结束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/10/Lua%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Lua%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">Lua中的环境(Environment)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 15:17:38" itemprop="dateCreated datePublished" datetime="2020-05-10T15:17:38+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>全局变量在大多数变成语言中是让人爱恨交织又不可或缺的。一方面，使用管全局变量会明显地使无关的代码部分纠缠在一起，容易导致代码复杂。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>另一方面，谨慎地使用全局变量又能更好地表达程序中真正的全局概念；此外，虽然全局常量看似无害，但像Lua语言这样的动态语言是无法区分常量和变量的。像Lua这样的嵌入式语言更复杂：虽然全局变量时再整个程序中均可见的变量，但由于Lua语言是由宿主应用调用代码段的，因此“程序”的概念不明确。<br>Lua语言通过不使用全局变量的方法来解决这个难题，但又不遗余力地在Lua语言汇总对全局变量进行模拟。在第一种近似的模拟中，我们可以认为Lua语言把所有的全局变量保存在一个称为全局环境的普通表中。<br>由于不需要再为全局变量创造一种新的数据结构，因此使用一个表来保存全局变量的一个优点是简化了Lua 语言的内部实现。另一个优点是，可以像操作其他表一样操作这个表。为了便于实现这种操作方式，Lua语言将全局环境自身保存在全局变量_G中。例如，如下代码输出了全局环境中所有全局变量的名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">_G</span>) <span class="keyword">do</span> <span class="built_in">print</span>(n) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="具有动态名称的全局变量"><a href="#具有动态名称的全局变量" class="headerlink" title="具有动态名称的全局变量"></a>具有动态名称的全局变量</h2><p>通常，赋值操作对于访问和设置全局变量已经足够了。<br>通常，赋值操作对于访问和设置全局变量已经足够了。然而，有时我们也需要某些形式的元变成。例如，我们需要操作一个全局变量，而这个全局变量的名称却存储在另一个变量中或者经由运行时计算得到。为了获取这个变量的值，许多程序员会写出下面的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="built_in">load</span>(<span class="string">&quot;return &quot;</span> .. varname)()</span><br></pre></td></tr></table></figure>
<p>例如，如果varname是x，那么字符串连接的结果就是”return x”，当执行时就能得到期望的结果。然而，在这段代码中涉及一个新代码段的创建和编译，在一定程度上开销昂贵。我们可以使用下面的代码来实现相同的效果，但效率却比之前的高出一个数量级：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value  = <span class="built_in">_G</span>[varname]</span><br></pre></td></tr></table></figure>
<p>由于全局环境是一个普通的表，因此可以简单地使用个对应的键直接进行索引。<br>类似地，我们可以通过编写_G[varname] &#x3D; value给一个名称为动态计算出的全局变量赋值。不过，请注意，有些程序员对于这种机制的使用可能有些过度而写出诸如_G[“a”] &#x3D; _G[“b”]这样的代码，而这仅仅是a &#x3D; b 的一种复杂写法。<br>上述问题的一般化形式是，允许字段使用诸如”io.read”或”a.b.c.d”这样的动态名称。如果直接使用_G[“io.read”]，显然是不能从表io中得到字段read的。但我们可以编写一个函数getfield让getfield(“io.read”)返回想要的结果。这个函数主要是一个循环，从_G开始逐个字段地进行求值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getfield</span><span class="params">(f)</span></span></span><br><span class="line">	<span class="keyword">local</span> v = <span class="built_in">_G</span></span><br><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(f,<span class="string">&quot;[%a_][%w_]*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		v = v[w]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们使用函数gmatch来遍历f中的所有标识符。<br>与之对应的设置字段的函数稍显复杂。像a.b.c.d &#x3D; v这样的赋值等价于一下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> temp = a.b.c</span><br><span class="line">temp.d = v</span><br></pre></td></tr></table></figure>
<p>也就是说，我们必须一直取到最后一个名称，然后再单独处理最后的这个名称。</p>
<blockquote>
<p>示例 函数setfield</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setfield</span><span class="params">(f,v)</span></span></span><br><span class="line">	<span class="keyword">local</span> t = <span class="built_in">_G</span></span><br><span class="line">	<span class="keyword">for</span> w, d <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(f, <span class="string">&quot;([%a_][%w_]*)(%.?)&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> d == <span class="string">&quot;.&quot;</span> <span class="keyword">then</span></span><br><span class="line">			t[w] = t[w] <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">			t = t[w]</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t[w] = v</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上例中使用的模式将捕获字段名称保存在变量w中，并将其后可选的点保存在变量d中。如果字段名后没有点，那么该字段就是最后一个名称。<br>下面的代码通过上例中的函数创建了全局表t和t.x，并将10赋值给了t.x.y:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setfield(<span class="string">&quot;t.x.y&quot;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(t.x.y)</span><br><span class="line"><span class="built_in">print</span>(getfield(<span class="string">&quot;t.x.y&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h2><p>Lua语言中的全局变量不需要声明就可以使用。虽然这种行为对于小型程序来说较为方便，但在大型程序中一个简单的手误可能造成难以发现的bug。不过，如果我们乐意的话，也可以改变这种行为。由于Lua语言将全局变量存放在一个普通的表中，所以可以通过元表来访问不存在全局变量的情况。<br>一种方法是简单地检测所有对全局表中不存在键的访问：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>,&#123;</span><br><span class="line">	<span class="built_in">__newindex</span> = funciton (_,n)</span><br><span class="line">	<span class="built_in">error</span>(<span class="string">&quot;attempt to write to undeclared variable&quot;</span> .. n, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_,n)</span></span></span><br><span class="line">	<span class="built_in">error</span>(<span class="string">&quot;attempt to read undeclared variable &quot;</span> .. n , <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码执行后，所有试图对不存在全局变量的访问都将引发一个错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>:attempt to <span class="built_in">read</span> undeclared variable a </span><br></pre></td></tr></table></figure>
<p>但是，我们应该如何声明一个新的变量呢？方法之一是使用函数rawset,它可以绕过元方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">declare</span> <span class="params">(name initval)</span></span></span><br><span class="line">	<span class="built_in">rawset</span>(<span class="built_in">_G</span>,name,initval <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中，or 和false保证新变量一定会得到一个不为nil的值。<br>另外一种更简单的方法是把对新全局变量的赋值限制在仅能在函数内进行，而代码段外层的代码则被允许自有赋值。<br>要检查赋值是否在主代码段中必须用到调试库。调用函数debug.getinfo(2,”S”)将返回一个表。其中的字段what表示调用元方法的函数是主代码段还是普通的Lua函数还是C函数。使用该函数，可以将__newindex元方法重写：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__newindex</span> = funciton (t,n,v)</span><br><span class="line">	<span class="keyword">local</span> w = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;S&quot;</span>).wath</span><br><span class="line">	<span class="keyword">if</span> w ~= <span class="string">&quot;main&quot;</span> <span class="keyword">and</span> w ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span> (<span class="string">&quot;attempt to write to undeclared variable&quot;</span> .. n , <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	rewset(t,n,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个新版本还可以接受来自C代码的赋值，因为一般C代码都知道自己究竟在做什么。<br>如果要测试一个变量是否存在，并不能简单地将它与nil比较。因为如果它为nil，那么访问就回引发一个错误。这是，应该使用rawget来绕过元方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">rawset</span>(<span class="built_in">_G</span>, var) == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>正如前面所提到的，我们不允许值为nil的全局变量，因为值为nil的全局变量都会被自动地认为未声明。但是，要允许值为nil的全局变量也不难，只需要引入一个辅助表来保存已声明变量的名称即可。一旦调用了元方法，元方法就会检查该表，看变量是否是未声明过的。</p>
<blockquote>
<p>示例 检查全局变量的声明</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> declareNames = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>,&#123;</span><br><span class="line">	<span class="built_in">__newindex</span> = funciton(t,n,v)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> declareNames[n] <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">local</span> w = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>,<span class="string">&quot;S&quot;</span>).wath </span><br><span class="line">		<span class="keyword">if</span> w ~= <span class="string">&quot;main&quot;</span> <span class="keyword">and</span> w ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">error</span>(<span class="string">&quot;attempt to write to undeclared variable &quot;</span> .. n, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		declareNames[n] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">rawset</span>(t,n,v)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(_,v)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> declareNames[n] <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;attempt to read undeclared variable &quot;</span> .. n , <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在，即使像 x &#x3D; nil这样的赋值也能够声明全局变量了。<br>上述两种方法所导致的开销都基本可以忽略不计。在第一种方法中，在普通操作期间元方法不会被调用。在第二种方法中，元方法只有当程序访问一个值为nil的变量时才会被调用。</p>
<h2 id="非全局环境"><a href="#非全局环境" class="headerlink" title="非全局环境"></a>非全局环境</h2><p>在Lua语言中，全局变量并一定非得是真正全局的。正如笔者此前所提到的，Lua语言甚至根本没有全局变量。Lua语言竭尽全力地让程序员有全局变量存在的幻觉。现在，让我们看看Lua语言是如何构建这种幻觉的。<br>首先，让我们忘掉全局变量而从自由名称的概念开始讨论。一个自由名称是指没有关联到显示声明上的名称，即它不出现在对应局部变量的范围内。例如，在下面的代码段中，x和y是自由名称，而z不是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">x = y + z</span><br></pre></td></tr></table></figure>
<p>接下来就到了关键的部分：Lua语言编译器将代码段中的所有自由名称x转换为_ENV.x。因此，此前的代码段完全等价于：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line"><span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br></pre></td></tr></table></figure>
<p>但是这里新出现的_ENV变量又究竟是什么呢？</p>
<p>我们刚才说过，Lua语言中没有全局变量。因此，_ENV不可能是全局变量。在这里，编译器实际上又进行了一次巧妙的工作。笔者已经提到过，Lua语言包所有代码段都当做匿名函数。所以，Lua语言编译器实际上将原来的代码段编译为如下形式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = some value</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">	<span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>也就是说，Lua语言是在一个名为_ENV的预定义上值（一个外部的局部变量，upvalue）存在的情况下编译所有的代码段的。因此，所有的变量要么是绑定到了一个名称的局部变量，要么是_ENV中的一个字段，而_ENV本身是一个局部变量。<br>_ENV的初始值可以是任意的表。任何一个这样的表都被称为一个环境。为了维持全局变量存在的幻觉，Lua语言在内部维护了一个表来用作全局变量。通过，当加载一个代码段时，函数load会使用预定义上的值来初始化全局环境。因此，原始的代码段等价于：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = the global environment</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">	<span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述赋值的结果是，全局环境中的字段x得到全局环境中字段y加10的结果。<br>乍一看，这可能像是操作全局变量的一种相当拐弯抹角的方式。笔者也不会去争辩说这是最简单的方式，但是，这种方式比那些更简单的实现方法具有更多的灵活性。<br>在继续学习前，让我们总结一下Lua语言中处理全局变量的方式：</p>
<ul>
<li>编译器在编译所有代码段前，在外层创建局部变量_ENV；</li>
<li>编译器将所有自由名称var变换为_ENV.var；</li>
<li>函数load使用全局环境初始化代码段的第一个上值，即Lua语言内部维护的一个普通的表。<br>实际上，这也不是太复杂。<br>有些人由于试图从这些规则中引申出额外的“魔法”而感到困惑；其实，这些规则并没有额外的含义。尤其是，前两条规则完全是由编译器进行的。除了是由编译器预定的，_ENV只是一个单纯的普通变量。抛开编译器，名称_ENV对于Lua语言来说根本没有特殊含义。类似地，从x到_ENV.x的转换时纯粹的语法转换，没有隐藏的含义。尤其是，在转换后，按照标准的可见性规则，_ENV引用的是所在位置所有可见的额_ENV变量。</li>
</ul>
<h2 id="使用-ENV"><a href="#使用-ENV" class="headerlink" title="使用_ENV"></a>使用_ENV</h2><p>由于_ENV只是一个普通的变量，因此可以对其赋值或像访问其他变量一样访问它。赋值语句_ENV &#x3D; nil会使得后续代码不能直接访问全局变量。这可以赢来控制代码使用哪种变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">print</span>, <span class="built_in">sin</span> = <span class="built_in">print</span>,<span class="built_in">math</span>.<span class="built_in">sin</span></span><br><span class="line"><span class="built_in">_ENV</span> = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">13</span>) 		<span class="comment">-- 13</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sin</span>(<span class="number">13</span>))  <span class="comment">-- 0.42016703682664</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">cos</span>(<span class="number">13</span>))  <span class="comment">-- error</span></span><br></pre></td></tr></table></figure>
<p>任何对自由名称的赋值都会引发类似的错误。<br>我们可以显式地使用_ENV来绕过局部声明：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">13</span>     <span class="comment">-- 全局的</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">12</span> </span><br><span class="line"><span class="built_in">print</span>(a)		<span class="comment">-- 12(局部的)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_ENV</span>.a)   <span class="comment">-- 13(全局的)</span></span><br></pre></td></tr></table></figure>
<p>用_G也可以：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">13</span>    <span class="comment">-- 全局的</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">12</span> </span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">-- 12 局部的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_G</span>.a) <span class="comment">-- 13 局部的</span></span><br></pre></td></tr></table></figure>
<p>通常，_G和_ENV指向的是同一个表。但是，尽管如此，它们是很不一样的实体。_ENV是一个局部变量，所有对“全局变量”的访问实际上访问的都是_ENV。_G则是一个在任何情况下都没有任何特殊状态的全局变量。按照定义，_ENV永远指向的是当前的环境；而假设在可见且无人改变过其值的前提下，_G通常指向的是全局变量。<br>_ENV的主要用途是用来改变代码段使用的环境。一旦改变了环境，所有的全局访问就都将使用新表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将当前的环境改为一个新的空表</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span>	<span class="comment">-- 在_ENV中创建字段</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">-- stdin:4:attempt to call global &#x27;print&#x27; (a nil value)</span></span><br></pre></td></tr></table></figure>
<p>如果新环境是空的，就会丢失所有的全局变量，包括函数print。因此，应该首先把一些有用的值放入新环境，比如全局环境：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">15</span>		<span class="comment">-- 创建一个全局变量</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;g = <span class="built_in">_G</span>&#125;		<span class="comment">-- 改变当前环境</span></span><br><span class="line">a = <span class="number">1</span>		<span class="comment">-- 在_ENV中创建字段</span></span><br><span class="line">g.<span class="built_in">print</span>(<span class="built_in">_ENV</span>.a,g.a)		<span class="comment">-- 1, 15</span></span><br></pre></td></tr></table></figure>
<p>这时，当访问“全局”的g（位于_ENV而不是全局环境中）时，我们使用的是全局环境，在其中能够找到函数print。<br>我们可以使用_G代替g，从而重写前面的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">15</span>					<span class="comment">-- 创建一个全局变量</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>&#125;		<span class="comment">-- 改变的当前环境</span></span><br><span class="line">a = <span class="number">1</span>					<span class="comment">-- 在_ENV中创建字段</span></span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">print</span>(<span class="built_in">_ENV</span>.a,_g.a)	<span class="comment">-- 1	15</span></span><br></pre></td></tr></table></figure>
<p>_G只有在Lua语言创建初始化的全局表并让字段_G指向它自己的时候，才会出现特殊状态。Lua语言并不关心该变量的当前值。不过尽管如此，就像我们在上面重写的示例中所看到的那样，将指向全局环境的变量命名为同一个名字(_G)是一个惯例。<br>另一种把旧环境装入新环境的方式是使用继承：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> newgt = &#123;&#125;		<span class="comment">-- 创建新环境</span></span><br><span class="line"><span class="built_in">setmetatable</span>(newgt,&#123;<span class="built_in">__index</span> = <span class="built_in">_G</span>&#125;)</span><br><span class="line"><span class="built_in">_ENV</span> = newgt			<span class="comment">-- 设置新环境</span></span><br><span class="line"><span class="built_in">print</span>(a)		<span class="comment">--1 </span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，新环境从全局环境中继承了函数print和a。不过，任何赋值都会发生在新表中，虽然我们仍然能通过_G来修改全局环境中的变量，但如果误改全局环境中的变量也不会有什么影响。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接此前的代码</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a,<span class="built_in">_G</span>.a)			<span class="comment">-- 10 	1</span></span><br><span class="line"><span class="built_in">_G</span>.a  = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_G</span>.a)				<span class="comment">-- 20</span></span><br></pre></td></tr></table></figure>
<p>作为一个普通的变量，_ENV遵循通常的定界规则。特别地，在一段代码中定义的函数可以按照访问其他外部变量一样的规则访问_ENV:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">_ENV</span> = &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>&#125;</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">_G</span>.<span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">foo()			<span class="comment">-- 10</span></span><br><span class="line"><span class="built_in">_ENV</span> = &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>, a = <span class="number">20</span>&#125;</span><br><span class="line">foo()		<span class="comment">-- 20</span></span><br></pre></td></tr></table></figure>
<p>如果定义一个名为_ENV的局部变量，那么对自由名称的引用将会绑定绑定到这个新变量上：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">_ENV</span> - &#123;<span class="built_in">print</span> = <span class="built_in">print</span>,a = <span class="number">14</span>&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)			<span class="comment">-- 14</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(a)			<span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
<p>因此，，可以跟很容易地使用私有环境定义一个函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factory</span><span class="params">(_ENV)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="keyword">return</span> a <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f1 = factory&#123;a = <span class="number">6</span>&#125;</span><br><span class="line">f2 = factory&#123;a = <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(f1())			<span class="comment">-- 6</span></span><br><span class="line"><span class="built_in">print</span>(f2())			<span class="comment">-- 7</span></span><br></pre></td></tr></table></figure>
<p>factory函数创建了一个简单的闭包，这个闭包返回了其中“全局”的a。每当闭包被创建时，闭包可见的变量_ENV就成了外部factory函数的参数_ENV。因此，每个闭包都会使用自己的外部变量来访问其自由名称。<br>使用普遍的定界规则，我们可以有几种方式操作环境。例如，可以让多个函数共享一个公共环境，或者让一个函数改变它与其他函数共享的环境。</p>
<h2 id="环境和模块"><a href="#环境和模块" class="headerlink" title="环境和模块"></a>环境和模块</h2><p>模块的缺点之一在于很容易污染全局空间，例如在私有声明中忘记local关键字。环境为解决这个问题提供了一种有趣的方式。一旦模块的主程序有一个独占的环境，则不仅该模块所有的函数共享了这个环境，该模块的全局变量也进入到了这个环境中。我们可以将所有的公有函数声明为全局变量，这样它们就会自动地进入分开的环境中。模块索要做的就是将这个环境赋值给变量_ENV。之后，当我们声明函数add时，它会变成M.add:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="built_in">_ENV</span> = M</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r + c2.r, c1.i + c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>此外，我们在调用同一模块中的其他函数时不需要任何前缀。在此前的代码中，add会从其环境中得到new，也就是M.new。<br>这种方法为模块提供了一种良好的支持，只需要程序员多做一点额外的工作。使用这种方法，完全不需要前缀，并且调用一个导出的函数与调用一个私有函数没有什么区别。即使程序员忘记了local关键词，也不会污染全局命名空间。相反，他只是让一个私有函数编程了公有函数而已。<br>不过尽管如此，笔者目前还是倾向于使用原始的基本方法，也许原始的基本方法需要更多的工作，但代码会更加清晰。为了避免错误地创建全局变量，笔者使用把nil赋给_ENV的方式。在把_ENV设为nil后，任何对全局变量的复制都会抛出异常。这种方式的另一个好处是无须修改代码也可以在老版本的Lua语言中运行。<br>为了访问其他模块，我们可以声明一个保存全局环境的局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">_G</span> = <span class="built_in">_G</span></span><br><span class="line"><span class="built_in">_ENV</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>然后在全局名称前加上_G和模块名M即可。<br>另一种更规范的访问其他模块的做法是只把需要的函数或模块声明为局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 模块初始化</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入部分：</span></span><br><span class="line"><span class="comment">-- 声明该模块需要的外部函数或模块等</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">sqrt</span> = <span class="built_in">math</span>.<span class="built_in">sqrt</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">io</span> = <span class="built_in">io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从此以后不能再进行外部访问</span></span><br><span class="line"><span class="built_in">_ENV</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>这种方式需要做更多的工作，但是它能清晰地列出模块的依赖。</p>
<h2 id="ENV-和load"><a href="#ENV-和load" class="headerlink" title="_ENV 和load"></a>_ENV 和load</h2><p>正如笔者此前提到的，函数load通常把被加载代码段上的值_ENV初始化为全局环境。不过，函数load还有一个可选的第四个参数来让我们为_ENV指定一个不同的初始值。<br>例如，假设我们有一个典型的配置文件，该配置文件定义了程序要使用的几个常量和函数，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件&#x27;config.lua&#x27;</span></span><br><span class="line">width = <span class="number">200</span></span><br><span class="line">height = <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>可以使用如下的代码加载该文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env = &#123;&#125;</span><br><span class="line"><span class="built_in">loadfile</span>(<span class="string">&quot;config.lua&quot;</span>,<span class="string">&quot;t&quot;</span>,env)()</span><br></pre></td></tr></table></figure>
<p>配置文件中的所有代码会运行在空的环境env中，类似于某种沙盒。特别地，所有的定义都会进入这个环境中。即使出错，配置文件也无法影响任何别的东西，甚至是恶意的代码也不能对其他东西造成任何破坏。除了通过消耗CPU时间和内存来制造拒绝服务攻击，恶意代码也做不了什么其他的事。<br>有时，我们可能想重复运行一段代码数次，每一次使用一个不同的环境。在这种情况下，函数load可选的参数就没用了。此时，我们有另外两种选择。<br>第一种选择是使用调试库中的函数debug.setupvalue。顾名思义，函数setupvalue允许改变任何指定函数的上值，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">load</span>(<span class="string">&quot;b = 10; return a&quot;</span>)</span><br><span class="line">env = &#123;a = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">debug</span>.<span class="built_in">setupvalue</span>(f,<span class="number">1</span>,env)</span><br><span class="line"><span class="built_in">print</span>(f())			<span class="comment">-- 20</span></span><br><span class="line"><span class="built_in">print</span>(env.b)		<span class="comment">-- 10</span></span><br></pre></td></tr></table></figure>
<p>setupvalue的第一个参数是指定的函数，第二个参数是上值的索引，第三个参数是新的上值。对于这种用法，第二个参数永远是1：当函数表示的是一段代码时，Lua语言可以保证它只有一个上值且上值就是_ENV。<br>这种方式的一个小缺点在于依赖调试库。调试库打破了有关程序的一些常见假设。例如，debug.setupvalue打破了Lua语言的可见性规则，而可见性规则可以保证我们不能从词法定界的范围外访问局部变量。<br>另一种在几个不同环境中运行代码段的方式是每次加载代码时稍微对其进行一下修改。假设我们在要加载的代码段钱加入一行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">_ENV</span> = ...;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意，由于Lua语言把所有的代码段都当做可变长参数函数进行编译，因此，多出的这一行代码会把传给代码段的第一个参数赋值_ENV，从而把参数设为环境。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prefix = <span class="string">&quot;_ENV = ...;&quot;</span></span><br><span class="line">f = loadwithprefix(prefix,<span class="built_in">io</span>.<span class="built_in">lines</span>(filename,<span class="string">&quot;*L&quot;</span>))</span><br><span class="line">...</span><br><span class="line">env1 = &#123;&#125;</span><br><span class="line">f(env1)</span><br><span class="line">env2 = &#123;&#125;</span><br><span class="line">f(env2)</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/27/Lua%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/Lua%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">Lua教程之Lua打乱数组排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-27 14:59:49" itemprop="dateCreated datePublished" datetime="2020-04-27T14:59:49+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>打乱有序数组，生成随机数组,在很多场景中都会用到这个函数，非常好用</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/27/Lua%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/24/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Lua连续教程之Lua面向对象编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-24 22:49:17" itemprop="dateCreated datePublished" datetime="2020-04-24T22:49:17+08:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从很多意义上讲，Lua语言中的一张表就是一个对象。首先，表与对象一样，可以拥有状态。其次，表与对象一样，拥有一个与其无关的标识(self)；</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>特别地，两个具有相同值的对象（表）是两个不同的对象，而一个对象可以具有多个不同的值；最后，表与对象一样，具有创建者和被创建位置无关的声明周期。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/24/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/24/Lua%E7%9A%84%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/Lua%E7%9A%84%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Lua的元表和元方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-24 14:23:09" itemprop="dateCreated datePublished" datetime="2020-04-24T14:23:09+08:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通常，Lua语言中的每种类型的值都有一套可预见的操作集合。例如，我们可以将数字相加，可以连接字符，还可以在表中插入键值对等。但是，我们无法将两个表相加，无法对函数做比较，也琺调用一个字符串，除非使用元表。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>元表可以修改一个值在面对一个未知操作时的行为。例如，假设a和b都是表，那么可以通过元表定义Lua语言如何计算表达式a+b。当Lua语言试图将两个表相加时，它会先检查两者之一是否有元表且该元表中是否有<code>__add</code>字段。如果Lua语言找到了该字段，就调用该字段对应的值，即所谓的元方法，在本例中就是用于计算表的和的函数。<br>可以认为，元表是面向对象领域中的受限制类。像类一样，元表定义的是实例的行为。不过，由于元表只能给出预先定义的操作集合的行为，所以元表被类更受限；同时，元表也不支持继承。<br>Lua语言中的每一个值都可以有元表。每一个表和用户数据类型都具有各自独立的元表，而其他类型的值则共享对应类型所属的同一个元表。Lua语言在创建新表时不带元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t))   <span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>可以使用函数setmetatable来设置或修改任意表的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t) == t1)		<span class="comment">--true</span></span><br></pre></td></tr></table></figure>
<p>在Lua语言中，我们只能为表设置元表；如果要为其他类型的值设置元表，则必须通过C代码或调试库完成（该限制存在的主要原因是为了防止过度使用对某种类型的所有值生效的元表。Lua语言老版本中的经验表明，这样的全局设置经常导致不可重用的代码）。字符串标准库为所有的字符串都设置了同一个元表，而其他类型在默认情况中都没有元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">&quot;hi&quot;</span>))		<span class="comment">-- table:0x80772e0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">&quot;xuxu&quot;</span>))     <span class="comment">-- table:0x80772e0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="number">10</span>))			<span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="built_in">print</span>))		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>一个表可以成为任意值的元表；一组相关的表也可以共享一个描述了它们共同行为的通用元表；一个表还可以成为它自己的元表，用于描述其自身特有的行为。总之，任何配置都是合法的。</p>
<h2 id="算术运算相关的元方法"><a href="#算术运算相关的元方法" class="headerlink" title="算术运算相关的元方法"></a>算术运算相关的元方法</h2><p>假设有一个用表来表示集合的模块，该模块还有一些用来计算集合并集和交集等的函数。</p>
<blockquote>
<p>示例：一个用于集合的简单模块</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Set = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用指定的列表创建一个新的集合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.new</span><span class="params">(l)</span></span></span><br><span class="line">	<span class="keyword">for</span> _, v inpairs(l) <span class="keyword">do</span> set[v] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.union</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = Set.new&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> res[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(b) <span class="keyword">do</span> res[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.intersection</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = Set.new&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">		res[k] = b[k]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将集合表示为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.tostring</span><span class="params">(set)</span></span></span><br><span class="line">	<span class="keyword">local</span> l = &#123;&#125;		<span class="comment">-- 保存集合中所有元素的列表</span></span><br><span class="line">	<span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span></span><br><span class="line">		l[#l + <span class="number">1</span>] = <span class="built_in">tostring</span>(e)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(l.<span class="string">&quot;,&quot;</span>)..<span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Set </span><br></pre></td></tr></table></figure>
<p>现在，假设想使用加法操作符来计算两个集合的并集，那么可以让所有表示集合的表共享一个元表。这个元表中定义了这些表应该如何执行加法操作。首先，我们创建一个普通的表，这个表被用作集合的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后，修改用于创建集合的函数<code>Set.new</code>。在新版本中只多了一行，即将mt设置为函数Set.new所创建的表的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.new</span><span class="params">(l)</span></span>		<span class="comment">-- 第二个版本</span></span><br><span class="line">	<span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(set,mt)</span><br><span class="line">	<span class="keyword">for</span> _, v <span class="keyword">in</span> inpairs(l) <span class="keyword">do</span> set[v] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在此之后，所有由Set.new创建的集合都具有了一个相同的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = Set.new&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2 = Set.new&#123;<span class="number">30</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s1))			<span class="comment">-- table:0x00672B60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s2))			<span class="comment">-- table:0x00672B60</span></span><br></pre></td></tr></table></figure>
<p>最后，向元表中加入元方法<code>__add</code>，也就是用于描述如何完成加法的字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__add</span> = Set.union</span><br></pre></td></tr></table></figure>
<p>此后，只要Lua语言试图将两个集合相加，它就会调用函数Set.union，并将两个操作数作为参数传入。<br>通过元方法，我们就可以使用加法运算符来计算集合的并集了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3 = s1 + s2</span><br><span class="line"><span class="built_in">print</span>(Set.<span class="built_in">tostring</span>(s3))				<span class="comment">--&#123;1,10,20,30,50&#125;</span></span><br></pre></td></tr></table></figure>
<p>类似地，还可以使用乘法运算符来计算集合的交集：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__mul</span> = Set.intersection</span><br><span class="line"><span class="built_in">print</span>(Set.<span class="built_in">tostring</span>(s1 + s2)*s1)		<span class="comment">-- &#123;10,20,30,50&#125;</span></span><br></pre></td></tr></table></figure>
<p>每种算术运算符都有一个对应的元方法。除了加法和乘法外，还有减法(__sub)、除法(__div)、floor除法(__idiv)、负数(__unm)、取模(__mod)和幂运算(__pow)。类似地，位操作也有元方法：按位与(__band)、按位或(__bor)、按位异或(__bxor)、按位取反(__bnot)、向左移位(__shl)和向右位移(__shr)。我们还可以使用字段<code>__concat</code>来定义连接运算符的行为。<br>当我们把两个集合相加时，使用哪个元素是确定的。然而，当一个表达式中混合了两种具有不同元素的值时，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Set.new&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s = s + <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>Lua语言会按照如下步骤来查找元方法：如果第一个值有元表且元表中存在所需的元方法，那么Lua语言就使用这个元方法，与第二个值无关；如果第二个值有元表且元表中存在所需的元方法，Lua语言就使用这个元方法；否则，Lua语言就抛出异常。因此，上例会调用Set.union，而表达式10+s和”hello”+s同理（由于数值和字符串都没有元方法__add）。<br>Lua语言不关心这些混淆类型，但我们在实现中需要关心混合类型。如果我们执行了s &#x3D; s + 8，那么在Set.union内部就会发生错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad argument #<span class="number">1</span> to <span class="string">&#x27;pairs&#x27;</span> (<span class="built_in">table</span> expected , got number)</span><br></pre></td></tr></table></figure>
<p>如果想要得到更明确的错误信息，则必须在试图进行操作前显式地检查操作数的类型，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.union</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">getmetatable</span>(a) ~= mt <span class="keyword">or</span> <span class="built_in">getmetatable</span>(b) ~= mt <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;attempt to &#x27;add&#x27; a set with a non-set value&quot;</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	同前</span><br></pre></td></tr></table></figure>
<p>请注意，函数error的第二个参数说明了出错的原因位于调用该函数的代码中。</p>
<h2 id="关系运算相关的元方法"><a href="#关系运算相关的元方法" class="headerlink" title="关系运算相关的元方法"></a>关系运算相关的元方法</h2><p>元表还允许我们制定关系运算符的含义，其中的元方法包括等于(__eq)、小于(__lt)和小于等于(__le)。其他三个关系运算符没有单独的元方法，Lua语言会将<code>a~=b</code>转换为<code>not(a == b),a&gt;b</code>转换为<code>b&lt;a,a&gt;=b</code>转换为<code>b&lt;=a</code>。<br>在Lua语言的老版本中，Lua语言会通过将<code>a&lt;=b</code>转换为<code>not (b&lt;a)</code>来把所有的关系运算符转化为一个关系运算符。不过，这种转化在遇到部分有序时就会不正确。所谓部分有序是指，并非所有类型的元素都能够被正确地排序。例如，由于<em>Not a Number(NaN)<em>的存在，大多数计算机中的浮点数就不是完全可以排序的。根据IEEE 754标准，NaN代表未定义的值，例如</em>O&#x2F;O</em>的结果就是NaN。标准规定任何涉及NaN的比较都应返回假，这就意味着NaN&lt;&#x3D;x永远为假，x&lt;NaN也为假。因此，在这种情况下，<code>a&lt;=b</code>到<code>not(b&lt;a)</code>的转化也就不合法了。<br>在集合的示例中，我们也面临类似的问题。&lt;&#x3D;显而易见且有用的含义集合包含：<code>a&lt;=b</code>通常意味着a是b的一个子集。然而，根据部分有序的定义，<code>a&lt;=b</code>和<code>b&lt;a</code>可能同时为假。因此，我们就必须实现<code>__le</code>（小于等于，子集关系）和<code>__lt</code>（小于，真子集关系）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__le</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span> 		<span class="comment">-- 子集</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> b[k] <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mt.<span class="built_in">__lt</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span>		<span class="comment">-- 真子集</span></span><br><span class="line">	<span class="keyword">return</span> a&lt;= b <span class="keyword">and</span> <span class="keyword">not</span> (b &lt;= a)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>最后，我们还可以通过集合包含来定义集合相等:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__eq</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">return</span> a &lt;= b <span class="keyword">and</span> b &lt;= a</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有力这些定义后，我们就可以比较集合了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = Set.new&#123;<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">s2 = Set.new&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 &lt;= s2)			<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(s1 &lt; s2)			<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt;= s1)			<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt; s1)			<span class="comment">-- false</span></span><br><span class="line"><span class="built_in">print</span>(s1 == s2 * s1)	<span class="comment">-- true</span></span><br></pre></td></tr></table></figure>
<p>相等比较有一些限制。如果两个对象的类型不同，那么相等比较操作不会调用任何元方法而直接返回false。因此，不管元方法如何，集合永远不等于数字。</p>
<h2 id="库定义相关的元方法"><a href="#库定义相关的元方法" class="headerlink" title="库定义相关的元方法"></a>库定义相关的元方法</h2><p>到目前为止，我们见过的所有元方法针对的都是核心Lua语言。Lua语言虚拟机会检测一个操作中设计的值是否有存在对应元方法的元表。不过，由于元表是一个普通的表，所以任何人都可以使用它们。因此，程序库在元表中定义和使用它们自己的字段也是一种常见的时间。<br>函数tostring就是一个典型的例子。正如我们此前所看到的，函数tostring能将表表示一种简单的文本格式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;&#125;)			<span class="comment">--table:0x8062ac0</span></span><br></pre></td></tr></table></figure>
<p>函数print总是调用tostring来进行格式化输出。不过，当对值进行格式化时，函数tostring会首先检查值是否有一个元方法<code>__tostring</code>。如果有，函数tostring就调用这个元方法来完成工作，将对象作为参数传给该函数，然后把元方法的返回值作为函数tostring的返回值。<br>在之前集合的示例中，我们已经定义了一个将集合表示为字符串的函数。因此，只需要在元表中设置__tostring字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__tostring</span> = Set.<span class="built_in">tostring</span></span><br></pre></td></tr></table></figure>
<p>之后，当以一个集合作为参数调用函数print时，print就会调用函数tostring，tostring又会调用Set.tostring:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = Set.new&#123;<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1)			<span class="comment">-- &#123;4,5,10&#125;</span></span><br></pre></td></tr></table></figure>
<p>函数setmetatable和getmetatable也用到了元方法，用于保护元表。假设想要保护我们的集合，就要使用户既不能看到也不能修改集合的元表。如果在元表中设置__metatable字段，那么getmetatable会返回这个字段的值，而setmetatable则会引发一个错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__metatable</span> = <span class="string">&quot;not yopur business&quot;</span></span><br><span class="line"></span><br><span class="line">s1 = Set.new&#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s1))				<span class="comment">-- not your business</span></span><br><span class="line"><span class="built_in">setmetatable</span>(s1,&#123;&#125;)</span><br><span class="line">	<span class="built_in">stdin</span>:<span class="number">1</span>:cannot change protected metatable</span><br></pre></td></tr></table></figure>
<p>从Lua5.2开始，函数pairs也有了对应的元方法。因此我们可以修改表被遍历的方式和为非表的对象增加遍历行为。当一个对象拥有__pairs元方法时，pairs会调用这个元方法来完成遍历。</p>
<h2 id="表相关的元方法"><a href="#表相关的元方法" class="headerlink" title="表相关的元方法"></a>表相关的元方法</h2><p>算术运算符、位运算符和关系运算符的元方法都定义了各种错误情况的行为，但它们都没有改变语言的正常行为。Lua语言还提供了一种改变表在两种正常情况下的行为的方式，即访问和修改表中不存在的字段。</p>
<h3 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h3><p>正如我们此前所看到的，当访问一个表中不存在的字段时会得到nil。这是正确的，但不是完整的真相。实际上，这些访问会引发解释器查找一个名为<code>__index</code>的元方法。如果没有这个元方法，那么像一般情况下一样，结果就是nil；否则，则由这个元方法来提供最终结果。<br>下面介绍一个关于继承的原型示例。假设我们要创建几个表来描述窗口，每个表中必须描述窗口的一些参数，例如位置、大小及主题颜色等。所有的这些参数都有默认值，因此我们希望在创建窗口对象时只需要给出那些不同于默认值的参数即可。第一种方法是使用一个构造器来填充不存在的字段，第二种方法是让新窗口从一个原型窗口继承所有不存在的字段。首先，我们声明一个原型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建具有默认值的原型</span></span><br><span class="line">prototype = &#123;x = <span class="number">0</span>, y = <span class="number">0</span> ,width = <span class="number">100</span>,height = <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后，声明一个构造函数，让构造函数创建共享同一个元表的新窗口：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="built_in">setmetatable</span>(o,mt)</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>现在，我们来定义元方法__index:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_,key)</span></span></span><br><span class="line">	<span class="keyword">return</span> prototype[key]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这段代码后，创建一个新窗口，并查询一个创建时没有指定的字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = new&#123;x = <span class="number">10</span>,y = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(w.width) 		<span class="comment">-- 100</span></span><br></pre></td></tr></table></figure>
<p>Lua语言会发现w中没有对应的字段”width”，但却有一个带有<code>__index</code>元方法的元表。因此，Lua语言会以w（表）和”width”（不存在的键）为参数来调用这个元方法。元方法随后会用这个键来检索原型并返回结果。<br>在Lua语言中，使用元方法<code>__index</code>来实现继承是很普通的方法。虽然被叫作方法，但元方法<code>__index</code>不一定必须是一个函数，它还可以是一个表。当元方法是一个函数时，Lua语言会以表和不存在的键为参数调用该函数，正如我们刚刚所看到的。当元方法是一个表时，Lua语言就访问这个表。因此，在我们此前的示例中，可以把<code>__index</code>简单地声明为如下样式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__index</span> = prototype</span><br></pre></td></tr></table></figure>
<p>这样，当Lua语言查找元表的__index字段时，会发现字段的值是表prototype。因此，Lua语言就会在这个表中继续查找，即等价地执行prototype[“width”]，并得到预期的结果。<br>将一个表用作__index元方法为实现单继承提供了一种简单快捷的方法。虽然将函数用作元方法开销更昂贵，但函数却更加灵活：我们可以通过函数来实现多继承、缓存及其他一些变体。<br>如果我们希望在访问一个表时不调用__index元方法，那么可以使用函数rawget。调用rawget(t,i)会对表t进行原始的访问，即在不考虑元表的情况下对表进行简单的访问。进行一次原始访问并不会加快代码的执行（一次函数调用的开销就会抹杀用户所作的这些努力），但是，我们后续会看到，有时确实会用到原始访问。</p>
<h3 id="newindex元方法"><a href="#newindex元方法" class="headerlink" title="__newindex元方法"></a>__newindex元方法</h3><p>元方法<code>__newindex</code>与<code>__index</code>类似，不同之处在于前者用于表的更新而后者用于表的查询。当对一个表中不存在的索引赋值时，解释器就会查找<code>__newindex</code>元方法：如果这个元方法存在，那么解释器就调用它而不执行赋值。像元方法__index一样，如果这个元方法时一个表，解释器就在此表中执行赋值，而不是在原始的表中进行复制。此外，还有一个原始函数允许我们绕过元方法：调用rawset(t,k,v)来等价于<code>t[k] =v</code>，但不涉及任何元方法。<br>组合使用元方法__index和__newindex可以实现Lua语言中的一些强大的结构，例如只读的表、具有默认值的表和面向对象编程中的继承。</p>
<h3 id="具有默认值的表"><a href="#具有默认值的表" class="headerlink" title="具有默认值的表"></a>具有默认值的表</h3><p>一个普通表中所有字段的默认值都是nil。通过元表，可以很容易地修改这个默认值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefualut</span><span class="params">(t,d)</span></span></span><br><span class="line">	<span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="keyword">return</span> d <span class="keyword">end</span>&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab = &#123;x = <span class="number">10</span>, y = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tab.x,tab.z)			<span class="comment">-- 10  nil</span></span><br><span class="line">setDefualut(tab,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(tab.x,tab.z)		<span class="comment">-- 10  0 </span></span><br></pre></td></tr></table></figure>
<p>在调用setDefault后，任何对表tab中不存在字段的访问都将调用它的__index元方法，而这个元方法会返回零（这个元方法中的值是d）。<br>函数setDefault为所有需要默认值的表创阿金一个新的闭包和一个新的元表。如果我们有很多需要默认值的表，那么开销会比较大。然而，由于具有默认值d的元表是于元方法关联在一起的，所有我们不能把同意个元表用于具有不同默认的表。为了能够使所有的表都使用同一个元表，可以使用一个额外的字段将每个表的默认值存放到表自身中。如果不担心命名冲突的话，我们可以使用形如<code>___</code>这样的键作为额外的字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span> <span class="keyword">return</span> t.___ <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefualut</span><span class="params">(t,d)</span></span></span><br><span class="line">	t,___ = d</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>请注意，这里我们只在setDefault外创建了一次元表mt及对应的元方法。<br>如果担心命名冲突，要确保这个特殊键的唯一性也很容易，只需要创建一个新的排除表，然后将它作为键即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t)</span></span> <span class="keyword">return</span> t[key] <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefualut</span><span class="params">(t,d)</span></span></span><br><span class="line">	t[key] = d</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>还有一种方法可以将每个表与其默认值关联起来，称为对偶表示，即使使用一个独立的表，该表的键为各种表，值为这些表的默认值。不过，为了正确地实现这种做法，我们还需要一种特殊的表，称为弱引用表。在这里，我们暂时不会使用弱引用表。<br>另一种为具有相同默认值的表复用同一个元表的方式是记忆元表。不过，这也需要用到弱引用表。</p>
<h3 id="跟踪对表的访问"><a href="#跟踪对表的访问" class="headerlink" title="跟踪对表的访问"></a>跟踪对表的访问</h3><p>假设我们要跟踪对某个表的所有访问。由于__index和__newindex元方法都是在表中的索引不存在时才有用，因此，捕获对一个表访问的唯一方式是保持表是空的。如果要监控对一个表的所有访问，那么需要为真正的表创建一个代理。这个代理是一个空的表，具有用于跟踪所有访问并将访问重定向到原来的表格的合理元方法。</p>
<blockquote>
<p>示例： 跟踪对标的访问</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> proxy = &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 为代理创建元表</span></span><br><span class="line">	<span class="keyword">local</span> mt = &#123;</span><br><span class="line">		<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_,k)</span></span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;*access to element&quot;</span> .. <span class="built_in">tostring</span>(k))</span><br><span class="line">		<span class="keyword">return</span> t[k]			<span class="comment">-- 访问原来的表</span></span><br><span class="line">	<span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">	<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(_,k,v)</span></span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;*update to element &quot;</span> .. <span class="built_in">tostring</span>(k) .. <span class="string">&quot; to &quot;</span> ..<span class="built_in">tostring</span>(v))</span><br><span class="line">		t[k] = v      <span class="comment">-- 更新原来的表</span></span><br><span class="line">	<span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">	__pairs = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(_,k)</span></span>			<span class="comment">--迭代函数</span></span><br><span class="line">			<span class="keyword">local</span> nextkey,nextvalue = <span class="built_in">next</span>(t,k)</span><br><span class="line">			<span class="keyword">if</span> nextkey ~= <span class="literal">nil</span> <span class="keyword">then</span> 		<span class="comment">-- 避免最后一个值</span></span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;*traversing element &quot;</span> .. <span class="built_in">tostring</span>(nextkey))</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">return</span> nextkey,nextvalue</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">	<span class="built_in">__len</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> #t <span class="keyword">end</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setmetatable</span>(proxy,mt)</span><br><span class="line">	<span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>以下展示了上述代码的用法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;				<span class="comment">-- 任意一个表</span></span><br><span class="line">t = track(t)</span><br><span class="line">t[<span class="number">2</span>] = <span class="string">&quot;hello&quot;</span>		<span class="comment">-- *update of element 2 to hello</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">2</span>])		</span><br><span class="line"><span class="comment">-- *access to elemetn 2</span></span><br><span class="line"><span class="comment">-- hello</span></span><br></pre></td></tr></table></figure>
<p>元方法__index和__newindex按照我们设计的规则跟踪每一个访问并将其重定向到原来的表中。元方法__pairs使得我们能够像遍历原来的表一样遍历代理，从而跟踪所有的访问。最后，远方__len通过代理实现了长度操作符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = track(&#123;<span class="number">10</span>,<span class="number">20</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(#t)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">pairs</span>(k,v) <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- *traversing element 1</span></span><br><span class="line"><span class="comment">-- 1	10</span></span><br><span class="line"><span class="comment">-- *traversing element 2</span></span><br><span class="line"><span class="comment">-- 2	10</span></span><br></pre></td></tr></table></figure>
<p>如果想要同时监控几个表，并不需要为每个表创建不同的元表。相反，只要以某种形式将每个代理与其原始表映射起来，并且让所有的代理共享一个公共的元表即可。</p>
<h3 id="只读的表"><a href="#只读的表" class="headerlink" title="只读的表"></a>只读的表</h3><p>使用代理的概念可以很容易地实现只读的表，需要做的只是跟踪对表的更新操作并抛出异常即可。对于元方法__index，由于我们不需要跟踪查询，所以可以直接使用原来的表来代替函数。这样做比把所有的查询重定向到原来的表上更简单也更有效率。不过，这种做法要求为每个只读代理创建一个新的元表，其中__index元方法指向原来的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readOnly</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> proxy = &#123;&#125;</span><br><span class="line">	<span class="keyword">local</span> mt = &#123;</span><br><span class="line">		<span class="built_in">__index</span> = t,</span><br><span class="line">		<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,k,v)</span></span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;attempt to update a read-only table&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(proxy,mt)</span><br><span class="line">	<span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>作为示例，我们可以创建一个表示星期的只读表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">days = readOnly&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thrsday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(days[<span class="number">1</span>])			<span class="comment">-- Sunday</span></span><br><span class="line">days[<span class="number">2</span>] = <span class="string">&quot;Nodya&quot;</span></span><br><span class="line"><span class="comment">-- stdin:1:attempt to update a read-only table</span></span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/23/Lua%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5import%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/Lua%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5import%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Lua模块引入import和require的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-23 20:23:11" itemprop="dateCreated datePublished" datetime="2020-04-23T20:23:11+08:00">2020-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua 中引入一个模块，可以采用两种方式：<code>import </code>和<code>require</code>方式，具体的区别在于：</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h3 id="载入一个模块"><a href="#载入一个模块" class="headerlink" title="载入一个模块"></a>载入一个模块</h3><p><code>import() </code>与 <code>require() </code>功能相同，但具有一定程度的自动化特性。</p>
<p>假设我们有如下的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">app/classes/</span><br><span class="line">app/classes/MyClass.lua</span><br><span class="line">app/classes/MyClassBase.lua</span><br><span class="line">app/classes/data/Data1.lua</span><br><span class="line">app/classes/data/Data2.lua</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MyClass 中需要载入 MyClassBase 和 MyClassData。如果用 require()，MyClass 内的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> MyClassBase = <span class="built_in">require</span>(<span class="string">&quot;app.classes.MyClassBase&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> MyClass = class(<span class="string">&quot;MyClass&quot;</span>, MyClassBase)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> Data1 = <span class="built_in">require</span>(<span class="string">&quot;app.classes.data.Data1&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> Data2 = <span class="built_in">require</span>(<span class="string">&quot;app.classes.data.Data2&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如我们将 MyClass 及其相关文件换一个目录存放，那么就必须修改 MyClass 中的 require() 命令，否则将找不到模块文件。</p>
<p>而使用 import()，我们只需要如下写：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> MyClassBase = import(<span class="string">&quot;.MyClassBase&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> MyClass = class(<span class="string">&quot;MyClass&quot;</span>, MyClassBase)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> Data1 = import(<span class="string">&quot;.data.Data1&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> Data2 = import(<span class="string">&quot;.data.Data2&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当在模块名前面有一个”.” 时，import() 会从当前模块所在目录中查找其他模块。因此 MyClass 及其相关文件不管存放到什么目录里，我们都不再需要修改 MyClass 中的 import() 命令。这在开发一些重复使用的功能组件时，会非常方便。</p>
<p>我们可以在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。</p>
<p>不过 import() 只有在模块级别调用（也就是没有将 import() 写在任何函数中）时，才能够自动得到当前模块名。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/23/python%E7%94%BB%E7%B4%A0%E6%8F%8F%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/python%E7%94%BB%E7%B4%A0%E6%8F%8F%E7%94%BB/" class="post-title-link" itemprop="url">python画素描画</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-23 16:05:55" itemprop="dateCreated datePublished" datetime="2020-04-23T16:05:55+08:00">2020-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 18:35:00" itemprop="dateModified" datetime="2024-05-14T18:35:00+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用python将一副彩色图转换为黑白素描图，废话不多说，直接上代码</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/23/python%E7%94%BB%E7%B4%A0%E6%8F%8F%E7%94%BB/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/22/Lua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8Bfor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/22/Lua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8Bfor/" class="post-title-link" itemprop="url">Lua迭代器和泛型for</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-22 22:00:46" itemprop="dateCreated datePublished" datetime="2020-04-22T22:00:46+08:00">2020-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>迭代器是一种可以让我们遍历一个集合中所有元素的代码结构。在Lua语言中，通常使用函数表示迭代器：每一次调用函数时，函数会返回集合中的”下一个“元素。一个典型的例子是io.read，每次调用该函数时它都会返回标准输入中的下一行，在没有读取的行时返回nil。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。对于函数io.read而言，C语言会将状态保存在流的结构体中。对于我们自己的迭代器而言，闭包则为保存状态提供了一种良好的机制。庆祝，一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。当然，要创建一个新的闭包，我们还必须创建非局部变量。因此，一个闭包结构通常涉及两个函数；闭包本身和一个用于创建该闭包及其封装变量的工程。<br>作为示例，让我们来为列表编写一个简单的迭代器。与ipairs不同的是，该迭代器并不是返回每个元素的索引而是返回元素的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">values</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> i = i +<span class="number">1</span> ；<span class="keyword">return</span> t[i] <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，values就是工厂。每当调用这个工厂时，它就会创建一个新的闭包（既迭代器本身）。这个闭包将它的状态保存在其外部的变量t和i中，这两个变量也是由values创建的。每次调用这个迭代器时，它就从列表t中返回下一个值。在遍历完最后一个元素后，迭代器返回nil，表示迭代结束。<br>我们可以在一个while循环中使用这个迭代器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">iter = values(t)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> element = iter()</span><br><span class="line">	<span class="keyword">if</span> element == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，使用泛型for更简单。毕竟，泛型for正是为了这种迭代而设计的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> values(t) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>泛型for为一次迭代循环做了所有的记录工作：它的内部保存了迭代函数，因此不需要变量iter；它在每次做新的迭代时都会再次调用迭代器，并在迭代器返回nil时结束循环。<br>下面是一个更高级的示例，它可以遍历来自标准输入的所有单词。</p>
<blockquote>
<p>示例 遍历来自标准输入的所有单词的迭代器</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allwords</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> line = <span class="built_in">io</span>.<span class="built_in">read</span>()		<span class="comment">-- 当前行</span></span><br><span class="line">	<span class="keyword">local</span> pos  = <span class="number">1</span>				<span class="comment">-- 当前行的当前位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>			<span class="comment">-- 迭代函数</span></span><br><span class="line">	<span class="keyword">while</span> line <span class="keyword">do</span> 				<span class="comment">-- 当还有行时循环</span></span><br><span class="line">		<span class="keyword">local</span> w , <span class="number">3</span> = <span class="built_in">string</span>.<span class="built_in">match</span>(line,<span class="string">&quot;(%w+)()&quot;</span>,pos)</span><br><span class="line">			<span class="keyword">if</span> w <span class="keyword">then</span>				<span class="comment">-- 发现一个单词？</span></span><br><span class="line">				pos = e 			<span class="comment">-- 下一个位置位于该单词后</span></span><br><span class="line">				<span class="keyword">return</span> w 			<span class="comment">-- 返回该单词</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				line = <span class="built_in">io</span>.<span class="built_in">read</span>()	<span class="comment">-- 没找到单词；尝试下一行</span></span><br><span class="line">				pos  = <span class="number">1</span>			<span class="comment">-- 从第一个位置重新开始</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>					<span class="comment">-- 没有行了：迭代结束</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>为了完成这样的便利，我们需要保存两个值：当前行的内容及当前行的当前位置。有了这些数据，我们就可以不断产生下一个单词。这个迭代函数的主要部分是调用函数string.match，以当前位置作为起始在当前行中搜索一个单词。函数string.match使用模式’%w+’来匹配一个“单词”，也就是匹配一个或多个字母&#x2F;数字字符。如果函数string.match找到了一个单词，它就捕获并返回这个单词及该单词之后的第一个字符位置，迭代函数则更新当前位置并返回该单词；否则，迭代函数读取新的一行，然后重复上述搜索过程。在所有的行都被读取完后，迭代函数返回nil以表示迭代结束。<br>尽管迭代器本身有点复杂，但allwords的使用还是很简明易懂的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> allowrds () <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>对于迭代器而言，一种常见的情况就是，编写迭代器可能不太容易，但使用迭代器却十分简单。这也不是一个大问题，因为使用Lua语言编程的最终用户一般不会去定义迭代器，而只会使用那些宿主应用已经提供的迭代器。</p>
<h2 id="泛型for的语法"><a href="#泛型for的语法" class="headerlink" title="泛型for的语法"></a>泛型for的语法</h2><p>上述那些迭代器都有一个缺点，即需要为每个新的循环创建一个新的闭包。对于大多数情况而言，这或许不会有什么问题。例如，在之前的allwords迭代器中，创建一个闭包的开销相对于读取整个文件的开销而言几乎可以忽略不计。但是，在另外一些情况下，这样的开销可能会很可观。在这类情况中，我们可以通过使用泛型for自己保存迭代状态。<br>泛型for在循环过程中在其内部保存了迭代函数。实际上，泛型for保存了三个值：一个迭代函数、一个不可变状态和一个控制变量。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var-list <span class="keyword">in</span> <span class="built_in">exp</span>-list <span class="keyword">do</span></span><br><span class="line">	body</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中，var-list是由一个或多个变量名组成的列表，以逗号分隔；exp-list是一个或多个表达式组成的列表，同样以逗号分隔。通常，表达式列表只有一个元素，即一句对迭代器工厂的调用。例如，在如下代码中，变量列表是k,v,表达式列表只要一个元素pairs(t):</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">print</span>(k,v) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们把变量列表的第一个（或唯一的）变量称为控制变量，其值在循环过程中永远不会是nil，因为当其值为nil时循环就结束了。<br>for做的第一件事情就是对in后面的表达式求值。这些表达式应该返回三个值供for保存：迭代函数、不可变状态和控制变量的初始值。类似于多重赋值，只有最后一个表达式能够产生不止一个值；表达式列表的结果值会保留三个，多余的值会被丢弃，不足三个则以nil补齐。例如，在使用简单迭器时，工厂只会返回迭代函数，因此不可变状态和控制变量都是nil。<br>在上述的初始化步骤完成后，for使用不可变状态和控制变量为参数来调用迭代函数。从for代码结构的立足点来看，不可变状态根本没有意义。for只是把从初始化步骤得到的状态值传递给所有迭代函数。然后，for将迭代函数的返回值赋给变量列表中声名的变量。如果第一个返回值为nil，那么循环终止；否则，for执行它的循环体并再次调用迭代函数，再不断地重复这个过程。<br>更确切地说，形如</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var_1,... ,var_n <span class="keyword">in</span> explist <span class="keyword">do</span> block <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样代码结构与下列代码等价：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> _f, _s , _var = explist</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> var_1, ... , var_n = _f(_s,_var)</span><br><span class="line">		_var = _var_1</span><br><span class="line">		<span class="keyword">if</span> _var  == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		block</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>因此，假设迭代函数为f，不可变状态为s，控制变量的初始值为a0，那么在循环中控制变量的值一次为a1 &#x3D; f(s,a0),a2 &#x3D; f(s,a1),一次类推，直至ai为nil。如果for还有其他变量，那么这些变量只是简单地在每次调用f后得到额外的返回值。</p>
<h2 id="无状态迭代器"><a href="#无状态迭代器" class="headerlink" title="无状态迭代器"></a>无状态迭代器</h2><p>顾名思义，无状态迭代器就是一种自身不保存任何状态的迭代器。因此，可以在多个循环中使用同一个无状态迭代器，从而避免创建新闭包的开销。<br>正如刚刚所看到的，for循环会以不可变状态和控制变量为参数低啊用迭代函数。一个无状态迭代器只根据这两个值来迭代生成下一个元素。这类迭代器的一个典型例子就是ipairs，它可以迭代一个序列中的所有元素：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(i,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>迭代的状态由正在被遍历的表（一个不可变状态，它不会在循环中改变）及当前的索引值（控制变量）组成。ipairs和迭代器都非常简单，我们可以在Lua语言中将其编写出来：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter</span><span class="params">(t,i)</span></span></span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line">	<span class="keyword">local</span> v = t[i]</span><br><span class="line">	<span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> i, v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">return</span> iter, t, <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当调用for循环中的ipairs(t)时，ipairs(t)会返回三个值，即迭代函数iter、不可变状态表t和控制变量的初始值0。然后，Lua语言调用iter(t,0)，得到1,t[1]（除非t[1]已经变成nil）。在第二次迭代中，Lua语言调用iter(t,1)，得到2,t[2]，依次类推，直至得到第一个为nil的元素。<br>函数pairs与函数ipairs类似，也用于遍历一个表中的所有元素。不同的是，函数pairs的迭代函数是Lua语言中的一个基本函数next：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairs</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">next</span>,t,<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在低啊用next(t,k)时，k是表t的一个键，该函数会以随机次序返回表中的下一个键及k对应的值（作为第二个返回值）。调用next(t,nil)时，返回表中的第一个键值对。当所有元素被遍历完时，函数next返回nil。<br>我们可以不调用pairs而直接使用next：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">next</span> , t <span class="keyword">do</span></span><br><span class="line">	loop body</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>请注意，for循环会把表达式列表的结果调整为三个值，因此上例得到的是next、t和nil，这也正与pairs(t)的返回值完全一致。<br>关于无状态迭代器的另一个有趣的示例是遍历链表的迭代器（链表在Lua语言中并不常见，但有时也需要用到）。我们的第一反应可能是只把当前节点当做控制变量，以便于迭代函数能够返回下一个节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getnext</span><span class="params">(node)</span></span></span><br><span class="line">	<span class="keyword">return</span> node.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">return</span> getnext, <span class="literal">nil</span>, list</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>但是，这种实现会跳过第一个节点。所以，我们需要使用如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getnext</span><span class="params">(list,node)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> list</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node.<span class="built_in">next</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">return</span> getnext, list,<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里的技巧是，除了将当前节点作为控制变量，还要将头节点作为不可变状态。第一次调用迭代函数getnext时，node为nil，因此函数返回list作为第一个节点。在后续的调用中，node不再是nil，所以迭代函数会像我们所期望的那样返回node.next。</p>
<h2 id="按顺序遍历表"><a href="#按顺序遍历表" class="headerlink" title="按顺序遍历表"></a>按顺序遍历表</h2><p>一个常见的困惑发生在开发人员想要对表中的元素进行排序时。由于一个表中的元素没有顺序，所以如果想对这些元素排序，就不得不把键值对拷贝到一个数组中，然后再对数组进行排序。<br>假设我们要读取一个源文件，然后构造一个表来保存每个函数的名称及其声明所在的行数，形式如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lines</span> = &#123;</span><br><span class="line">	[<span class="string">&quot;luaH_set&quot;</span>]     = <span class="number">10</span>,</span><br><span class="line">	[<span class="string">&quot;luaH_get&quot;</span>]	 = <span class="number">24</span>,</span><br><span class="line">	[<span class="string">&quot;luaH_present&quot;</span>] = <span class="number">48</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们想按照字母顺序输出这些函数名。如果使用pairs遍历表，那么函数名会按照随机的顺序出现。由于这些函数名是表的键，所以我们无法直接对其进行排序。不过，我们把他们放到数组中，那么就可以对它们进行排序了。首先，我们必须创建一个包含函数名的数组，然后对其排序，再最终输出结果。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">lines</span>) <span class="keyword">do</span> a[#a + <span class="number">1</span>] = n <span class="keyword">end</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(a)</span><br><span class="line"><span class="keyword">for</span> _, n <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span> <span class="built_in">print</span>(n) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有些人可能会困惑。毕竟，对于Lua语言来说，数组也没有顺序。但是我们知道如何数数！因此，当我们使用有序的索引访问数组时，就实现了有序。这正是应该总是使用ipairs而不是pairs来遍历数组的原因。第一个函数通过有序的键1、2等来实现有序，然而后者使用则是天然的随机顺序（虽然大多数情况下顺序随机也无碍，但有时可能并非我们想要的）。<br>现在，我们已经准备好写一个按照键的顺序来遍历表的迭代器了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairsByKeys</span><span class="params">(t,f)</span></span></span><br><span class="line">	<span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="comment">--  创建一个包含所有键的表</span></span><br><span class="line">		a[#a + <span class="number">1</span>] = n</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">sort</span>( a, f )  <span class="comment">-- 对列表排序</span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">0</span>         <span class="comment">-- 迭代变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>   <span class="comment">-- 迭代函数</span></span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">		returna[i],t[a[i]]		<span class="comment">--返回键和值</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>工厂函数pairsByKeys首先把键放到一个数组中，然后对数组进行排序，最后返回迭代函数。在每一步中，迭代器都会按照数组a中的顺序返回原始表中的下一个键值对。可选的参数f允许指定一种其他的排序方法。<br>使用这个函数，可以很容易地解决开始时提出的按顺序遍历表的问题：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,line <span class="keyword">in</span> pairsByKeys(<span class="built_in">lines</span>) <span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">print</span>(name,line)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>像通常的情况一样，所有的复杂性都被隐藏到了迭代器中。</p>
<h2 id="迭代器的真实含义"><a href="#迭代器的真实含义" class="headerlink" title="迭代器的真实含义"></a>迭代器的真实含义</h2><p>“迭代器”这个名称多少有点误导性，这是因为迭代器并没有进行实际的迭代：真正的迭代时for循环完成的，迭代器只不过为每次的迭代提供连续的值。或许，称其为“生成器”更好，表示迭代生产元素；不过，“迭代器”这个名字已在出入Java等其他语言中被广泛是用了。<br>然而，还有一种创建迭代器的方式可以让迭代器进行实际的迭代操作。当使用这种迭代器时，就不再需要编写循环了。相反，只需要调用这个迭代器，并传入一个描述了在每次迭代时需要做什么的参数即可。更确切地说，迭代器接收了一个函数作为参数，这个函数在循环的内部被调用，这种迭代器就被称为真正的迭代器。<br>&ensp;&ensp;举一个具体的例子，让我们使用这种风格再次重写allowrds迭代器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allwords</span><span class="params">(f)</span></span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.line() <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(line,<span class="string">&quot;%w+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">			f(word)			<span class="comment">--调用函数</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>使用这个迭代器时，我们必须传入一个函数作为循环体。如果我们只想输出每个单词，那么简单地使用函数print即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allwords(<span class="built_in">print</span>)</span><br></pre></td></tr></table></figure>
<p>通常，我们可以使用一个匿名函数作为循环体。例如，以下的代码用于计算单词”hello”在输入文件中出现的次数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">allwords(<span class="function"><span class="keyword">function</span><span class="params">(w)</span></span></span><br><span class="line">	<span class="keyword">if</span> w == <span class="string">&quot;hello&quot;</span> <span class="keyword">then</span> count = count + <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>
<p>同样的需求，如果采用之前的迭代器风格，差异也不是特别大：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> allwords() <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> w == <span class="string">&quot;hello&quot;</span> <span class="keyword">then</span> count = count + <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;真正的迭代器在老版本的Lua语言中曾非常流行，那是还没有for语句。真正的迭代器与生成器风格的迭代器相比怎么样呢？这两种风格都有大致相同的开销，即每次迭代都有一次函数调用。一方面，编写真正的迭代器比较容易。另一方面，生成器风格的迭代器则更灵活。首先，生成器风格的迭代器允许两个或更多个并行的迭代。其次，生成器风格的迭代器允许在循环体中使用break和return语句。使用真正的迭代器，return语句从匿名函数中返回而非从进行迭代的函数中返回。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/21/Lua%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/Lua%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/" class="post-title-link" itemprop="url">Lua中模块和包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 20:41:58" itemprop="dateCreated datePublished" datetime="2020-04-21T20:41:58+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通常，Lua语言不会设置规则。相反，Lua语言提供的是足够强大的机制供不同的开发者实现最适合自己的规则。然而，这种方法对于模块而言并不是特别适用。模块系统的主要目标之一就是允许不同的人共享代码，缺乏公共规则就无法实现这样的分享。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>Lua语言从5.1版本开始为模块和包定义了一系列的规则。这些规则不需要从语言中引入额外的功能，程序猿可以使用目前为止我们学习到的机制实现这些规则。程序员也可以自由地使用不同的策略。当然，不同的实现可能会导致程序不能使用外部模块，或者模块不能被外部程序使用。<br>从用户观点来看，一个模块就是一些代码，这些代码可以通过函数require加载，然后创建和返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。<br>例如，所有的标准库都是模块。我们可以按照如下的方式使用数学库：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">sin</span>(<span class="number">3.14</span>))				<span class="comment">-- 0.0015926529164868</span></span><br></pre></td></tr></table></figure>
<p>独立解释器会使用跟如下代码等价的方式提前加载所有标准库：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">math</span> = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="built_in">string</span> = <span class="built_in">require</span> <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure>
<p>这种提前加载使得我们可以不用费劲地编写代码来加载模块math就可以直接使用函数math.sin。<br>使用表来实现模块的显著优点之一是，让我们可以像操作普通表那样操作模块，并且能利用Lua语言的所有功能实现额外的功能。在大多数语言中，模块不是第一类值（即它们不能被保存在变量中，也不能被当作参数传递给函数等），所以那些语言需要为模块实现一套专门的机制。而在Lua语言中，我们则可以轻易地实现这些功能。<br>例如，用户调用模块中的函数就有几种方法。其中常见的方法是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line"><span class="built_in">mod</span>.foo()</span><br></pre></td></tr></table></figure>
<p>用户可以为模块设置一个局部名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line">m.foo()</span><br></pre></td></tr></table></figure>
<p>也可以为个别函数提供不同的名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line"><span class="keyword">local</span> f = m.foo</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>还可以只引入特定的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span>.foo 			<span class="comment">-- (require(&quot;mod&quot;)).foo</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>上述这些方法的好处是无须语言的特别支持，它们使用的都是语言已经提供的功能。</p>
<h2 id="函数-require"><a href="#函数-require" class="headerlink" title="函数 require"></a>函数 require</h2><p>尽管函数require也只是一个没什么特殊之处的普通函数，但在Lua语言的模块实现中扮演者核心角色。要加载模块时，只需要简单地调用这个函数，然后传入模块作为参数。请记住，当函数的参数只有一个字符串常量时括号是可以省略的，而且一般在使用require时按照惯例也会省括号。不过尽管如此，下面这些用法也是正确的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> modname = <span class="string">&#x27;math&#x27;</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(modname)</span><br></pre></td></tr></table></figure>
<p>函数require尝试对模块的定义做最小的假设。对于函数来说，一个模块可以是定义了一些变量的代码。典型地，这些代码返回一个由模块中函数组成的表。不过，由于这个动作是由模块代码而不是由函数require完成的，所以某些模块可能会选择返回其他的值或者甚至引发副作用。<br>首先，函数require在表package.loaded中检查模块是否已被加载。如果模块已经被加载，函数require就返回相应的值。因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。<br>如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径有变量package.path指定）。如果函数require找到了相应的文件，那么就用函数loadfile将其进行加载，结果是一个我们称之为加载器的函数。<br>如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。如果找到了一个C标准库，则使用底层函数package.loadlib进行加载，这个底层函数会查找名为luaopen_modname的函数。在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数luaopen_modname。<br>不管模块是Lua文件还是C标准库中找到的，函数require此时都具有了用于加载它的加载函数。为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在文件名称。如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载同一个模块时返回相同的值。如果加载函数么有返回值且表中的package.loaded【@rep{modname}]为空，函数require就假设模块的返回值是true。如果没有这种补偿，那么后续调用函数require时将会重复加载模块。<br>要强制函数require加载同一模块两次，可以先将模块从package.loaded中删除：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>.modname = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>下一次在加载这个模块时，函数require就会重新加载模块。<br>对于函数require来说，一个常见的抱怨是它不能给待加载的模块传递参数。例如，数学模块可以对角度和弧度的选择增加一个选项：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误的代码</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">math</span> = <span class="built_in">require</span>(<span class="string">&quot;math&quot;</span>,<span class="string">&quot;degree&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的问题在于，函数require的主要目的之一就是避免重复加载模块，一旦一个模块被加载，该模块就会在后续所有调用require的程序部分被复用。这样，不同参数的同名模块之间就会产生冲突。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line"><span class="built_in">mod</span>.init(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果加载函数返回的是模块本身，那么还可以写成：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span>.init(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>请记住，模块在任何情况下只加载一次；至于如何处理冲突的加载，取决于模块自己。</p>
<h3 id="模块重命名"><a href="#模块重命名" class="headerlink" title="模块重命名"></a>模块重命名</h3><p>通常，我们通过模块本来的名称来使用它们，但有时，我们也需要将一个模块改名以避免命名冲突。一点典型的情况就是，处于测试的目的而需要加载同一模块的不同版本。对于一个Lua语言模块来说，其内部的名称并不要求是固定的，因此通常修改.lua文件的文件名就够了。不过，我们却无法修改C标准库的二进制目标代码中<code>luaopen_*</code>函数的名称。为了进行这种重命名，函数require运用了一个连字符的技巧：如果一个模块名中包含连字符，那么函数require就会用连字符之前的内容创建<code>luaopen_*</code>函数的名称。例如，如果一个模块的名称为mod-v3.4，那么函数require会认为该模块的加载函数应该是<code>luaopen_mod</code>而不是luaopen_mod-v3.4（这也不是有效的C语言函数名）。因此，如果需要使用两个名称均为mod的模块（或相同模块的两个不同版本），那么可以对其中的一个进行重命名，如mod-v1.当调用m1&#x3D;require “mod-v1”时，函数require会找到改名后的文件mod-v1并将其中原名为luaopen_mod的函数作为加载函数。</p>
<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>在搜索一个Lua文件时，函数require使用的路径与典型的路径略有不同。典型的路径是很多目录组成的列表，并在其中搜索指定的文件。不过，IOS C（Lua语言依赖的抽象平台）并没有目录的概念。所以，函数require使用的路径是一组模块，其中的每项都指定了蒋模块名(函数require的参数)转换为文件名的方式。更准确地说，这种路径中的每一个模块都是一个包含可选问号的文件名。对于每个模板，函数require会用模块名来替换每一个问号，然后检查结果是否存在对应的文件；如果不存在，则尝试下一个模板。路径中模板以在大所述操作系统中很少被用于文件名的分号隔开。例如，考虑如下路径：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?;?.lua;c:\windows\?;/usr/<span class="keyword">local</span>/lua/?/?.lua</span><br></pre></td></tr></table></figure>
<p>在使用这个路径时，调用require “sql”将尝试打开如下的Lua文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">sql.lua</span><br><span class="line">c:\windows\sql</span><br><span class="line">/usr/<span class="keyword">local</span>/lua/sql/sql.lua</span><br></pre></td></tr></table></figure>
<p>函数require只处理分号（作为分隔号）和问号，所有其他的部分（包括目录分隔符合文件扩展名）则由路径自有定义。<br>函数require用于搜索Lua文件的路径是变量package.path的当前值。当package模块被初始化后，它就把变量package.path设置成环境变量LUA_PATH_5_3的值。如果这个环境变量没有被定义，那么Lua语言则尝试另一个环境变量LUA_PATH。如果这两个环境变量都没有被定义，那么Lua语言则使用一个编译是定义的默认路径。在使用一个环境变量的值时，Lua语言会将其中所有的”;;”替换成默认路径。例如，如果LUA_PATH_5_3设为”mydir&#x2F;r.lua;;”,那么最终路径就会是模板”mydir&#x2F;?.lua”后跟默认路径。<br>搜索C标准库的路径的逻辑与此相同，只不过C标准库的路径来自变量package.cpath而不是package.path。类似地，这个变量的初始值也来自环境变量LUA_CPATH_5_3或LUA_CPATH。在POSIX系统中这个路径的典型值形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./?.so;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.2</span>/?.so</span><br></pre></td></tr></table></figure>
<p>请注意定义文件扩展名的路径。在上例中，所有模块使用的都是.so，而在Windows操作系统中此典型路径通常形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\&gt;.dll;C:\Program Files\Lua502\dll\?.dll</span><br></pre></td></tr></table></figure>
<p>函数package.searchpath中实现了搜索库的所有规则，该函数的参数包括模块名和路径，然后遵循上述规则来搜索文件。函数package.searchpath要么返回第一个存在的文件的文件名，要么返回nil外加描述所有文件都无法成功打开的错误信息，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">&quot;.\\?.dll;C:\\Programe Files\\Lua502\\dll\\?.dll&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.searchpath(<span class="string">&quot;X&quot;</span>,<span class="built_in">path</span>))</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">			no file <span class="string">&#x27;.\X.dll&#x27;</span></span><br><span class="line">			no file <span class="string">&#x27;C:\Program Files\Lua502\dll\X.dll&#x27;</span></span><br></pre></td></tr></table></figure>
<p>作为一个有趣的练习，我们在示例中实现了与函数package.searchpath类似的函数。</p>
<blockquote>
<p>示例，实验班的package.searchpath</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">(modname,path)</span></span></span><br><span class="line">	modname = <span class="built_in">string</span>.<span class="built_in">gsub</span>(modname,<span class="string">&quot;%.&quot;</span>,<span class="string">&quot;/&quot;</span>)</span><br><span class="line">	<span class="keyword">local</span> msg = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(<span class="built_in">path</span>, <span class="string">&quot;[^;]+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> fname = <span class="built_in">string</span>.<span class="built_in">gsub</span>(c,<span class="string">&quot;?&quot;</span>,modname)</span><br><span class="line">		<span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">open</span>(fname)</span><br><span class="line">		<span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">			f:<span class="built_in">close</span>()</span><br><span class="line">			<span class="keyword">return</span> fname</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			msg[#msg + <span class="number">1</span>] = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;\n\tno file &#x27;%s&#x27;&quot;</span>,fname);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> , <span class="built_in">table</span>.<span class="built_in">concat</span>(msg)			<span class="comment">-- 没找到</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述函数首先替换目录分隔符，在本例中即把所有的点换成斜杠。之后，该函数遍历路径中的所有组成部分，也就是每一个不含分号的最长匹配。对于每一个组成部分，该函数使用模块名来替换问号得到最终的文件名，然后检查相应的文件是否存在。如果存在，该函数关闭这个文件，然后返回文件的名称；否则，该函数保存失败的文件名用于可能的错误提示（请注意字符串缓冲区在避免创建无用的长字符串时的作用）。如果一个文件都找不到，该函数则返回nil及最终的错误信息。</p>
<h3 id="搜索器"><a href="#搜索器" class="headerlink" title="搜索器"></a>搜索器</h3><p>在现实中，函数require比此前描述过的稍微复杂一点。搜索Lua文件和C标准库的方式只是更加通用的搜索器的两个实例。一个搜索器是一个以模块名为参数，以对应模块的加载器或nil为返回值的简单函数。<br>数组package.searchers列出了函数require使用的所有搜索器。在寻找模块时，函数require传入模块名并调用列表中的每一个搜索器知道它们其中的一个找到了指定模块的加载器。如果所有所搜器都被调用完后还找不到，那么函数require就抛出一个异常。<br>用一个列表来驱动对一个模块的搜索给函数require提供了极大的灵活性。例如，如果想保存被压缩在zip文件中的模块，只需要提供一个合适的搜索器，然后把它增加到该列表中。在默认配置中，我们此前学习过的用于搜索Lua文件和C标准库的搜索器排在列表的第二、三位，在它们之前是预加载搜索器。<br>预加载搜索器使得我们能够为要记载的模块定义任意的加载函数。预加载搜索器使用一个名为package.preload的表来映射模块名称和加载函数。当搜索指定的模块名时，该搜索器只是简单地在表中搜索指定的名称。如果它找到了对应的函数，那么就将该函数作为相应模块的加载函数返回；否则，则返回nil。预加载搜索器为处理非标场景提供了一种通用的方式。例如，一个静态链接到Lua中的C标准库可以将其luaopen_函数注册到表preload中，这样luaopen_函数只有当用户加载这个模块时才会被调用。用这种方式，程序不会为没有用到的模块浪费资源。</p>
<h2 id="Lua语言中编写模块的基本方法"><a href="#Lua语言中编写模块的基本方法" class="headerlink" title="Lua语言中编写模块的基本方法"></a>Lua语言中编写模块的基本方法</h2><p>在lua语言中创建模块的最简单方法是，创建一个表并将所有需要导出的函数放入其中，最后返回个表。示例就是这个方法：</p>
<blockquote>
<p>一个用于复数的简单模块</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;   <span class="comment">-- 模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个新的复数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,i)</span></span></span><br><span class="line">	<span class="keyword">return</span>&#123;r = r , i = i&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">M.new = new 		<span class="comment">-- 把&#x27;new&#x27;加到模块中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- constant &#x27;i&#x27;</span></span><br><span class="line">M.i = new(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.add</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r + c2.r,c1.i + c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.sub</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r - c2.r,c1.i - c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.mul</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r*c2.r - c1.i*c2.i,c1.r*c2.i + c1.i*c2.r)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">inv</span><span class="params">(c)</span></span></span><br><span class="line">	<span class="keyword">local</span> n = c.r^<span class="number">2</span> + c.i^<span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> new(c.r/n,-c.i/n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.div</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> M.mul(c1,inv(c2))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.tostring</span><span class="params">(c)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;(%g,%g)&quot;</span>,c.r,c.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure>
<p>请注意我们是如何通过简单地把new和inv声明为局部变量而使它们称为代码段的私有函数的。<br>有些人不喜欢最后的返回语句。一种将其省略的方式是直接把模块对应的表放在package.loaded中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[...] = M</span><br></pre></td></tr></table></figure>
<p>请注意，函数require会把模块的名称作为第一个参数传给加载函数。因此，表索引中的可变长参数表达式…其实就是模块名。在这一赋值语句后，我们就不再需要在模块的最后返回M了：如果一个模块没有返回值，那么函数require会返回package.loaded[modname]的当前值。不过，笔者认为在模块的最后加上return语句更清晰。如果我们忘了return语句，那么在测试模块的时候就很容易就会发现问题。<br>另一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表，参考示例</p>
<blockquote>
<p>示例：使用导出表的模块</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,i)</span></span> <span class="keyword">return</span> &#123;r = r, i = i&#125; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> i = complex.new(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">	new  = new,</span><br><span class="line">	i    = i,</span><br><span class="line">	add  = add,</span><br><span class="line">	<span class="built_in">sub</span>  = <span class="built_in">sub</span>,</span><br><span class="line">	mul  = mul,</span><br><span class="line">	div  = div,</span><br><span class="line">	<span class="built_in">tostring</span> = <span class="built_in">tostring</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的有点在于，无须在每一个标识符前增加前缀M.或类似的东西。通过显式的导出表，我们能够以与在模块中相同的方式定义和使用导出和内部函数。这种方式的缺点在于，导出表位于最后不是最前面（把前面的话当作简略文档的话更有用），而且由于必须把每个名字都写两遍，所以导出表有点冗余（这一点其实可能会变成优点，因为这允许函数在模块内和模块外具有不同的名称，不过程序很少会用到）。<br>不管怎样，无论怎样定义模块，用户都能用标准的方法使用模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cpx = <span class="built_in">require</span> <span class="string">&quot;complex&quot;</span></span><br><span class="line"><span class="built_in">print</span>(cpx.<span class="built_in">tostring</span>(cpx.add(cpx.new(<span class="number">3</span>,<span class="number">4</span>),cpx.i)))				<span class="comment">-- (3,5)</span></span><br></pre></td></tr></table></figure>
<p>后续，我们会看到如何使用诸如元表和环境之类的高级Lua语言功能来编写模块。 不过，除了发现由于失误而定义的全局变量时又一个技巧外，笔者编写模块时都是用基本功能。</p>
<h2 id="子模块和包"><a href="#子模块和包" class="headerlink" title="子模块和包"></a>子模块和包</h2><p>Lua支持具有层次结构的模块名，通过点来分隔名称中的层次。例如，一个名为mod.sub的模块是模块魔的一个子模块。一个包是一棵由模块组成的完整的树，它是Lua语言中用于发行程序的单位。<br>当加载一个名为mod.sub的模块时，函数require一次使用原始的模块名”mod.sub”作为键来查询表package.loaded和表package.preload。这里，模块名中的点像模块名中的其他字符一样，没有特殊含义。<br>然而，当搜索一个定义子模块的文件时，函数require会将点转换为另一个字符，通常就是操作系统的目录分隔符（例如，POSIX操作系统的斜杠或Windows操作系统的反斜杠）。转换之后，函数require会像搜索其他名称一样搜索这个名称。例如，假设目录分隔符是斜杠并且有如下路径：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./?.lua;/usr/<span class="keyword">local</span>/lua/?.lua;/usr/<span class="keyword">local</span>/lua/?/init.lua</span><br></pre></td></tr></table></figure>
<p>调用require “a.b”会尝试打开以下文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./a/b.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/lua/a/b.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/lua/a/b/init.lua </span><br></pre></td></tr></table></figure>
<p>这种行为使得一个包中的所有模块能够放到一个目录中。例如，一个具有模块p、p.a和p.b的包对应的文件可以分贝是p&#x2F;init.lua、p&#x2F;a.lua和p&#x2F;b.lua，目录p又位于其他合适的目录中。<br>Lua语言使用的目录分隔符是编译时配置的，可以是任意的字符串（请记住，Lua并不知道目录的存在）。例如，没有目录层次的系统可以使用下画线作为”目录分隔符“，因此调用require “a,b”会搜索文件a_b.lua。<br>作为一种额外的机制，函数require在加载C语言编写的子模块时还有另外一个搜索器。当该函数找不到子模块对应的Lua文件或C文件时，它会再次搜索C文件所在的路径，不过这次将搜索包的名称。例如，如果一个程序要加载子模块a.b.c，搜索器会搜索文件a。如果找到了C标准库a，那么函数require就会在该库中搜索对应的加载函数luaopen_a_b_c。这种机制允许一个发行包将几个子模块组织为一个C标准库，每个子模块有各自的加载函数。<br>从Lua语言的视角看，同一个包中的子模块没有显式的关联。加载一个模块并不会自动加载它的任何子模块。同样，加载子模块也不会自动地加载其父模块。当然，只要包的实现者愿意，也可以创造这种关联。例如，一个特定的模块可能一开始就显式地加载它的一个或全部子模块。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">南锋</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">168</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南锋</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
