<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="南锋">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/24/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Lua连续教程之Lua面向对象编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-24 22:49:17" itemprop="dateCreated datePublished" datetime="2020-04-24T22:49:17+08:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从很多意义上讲，Lua语言中的一张表就是一个对象。首先，表与对象一样，可以拥有状态。其次，表与对象一样，拥有一个与其无关的标识(self)；</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>特别地，两个具有相同值的对象（表）是两个不同的对象，而一个对象可以具有多个不同的值；最后，表与对象一样，具有创建者和被创建位置无关的声明周期。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/24/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/24/Lua%E7%9A%84%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/Lua%E7%9A%84%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Lua的元表和元方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-24 14:23:09" itemprop="dateCreated datePublished" datetime="2020-04-24T14:23:09+08:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通常，Lua语言中的每种类型的值都有一套可预见的操作集合。例如，我们可以将数字相加，可以连接字符，还可以在表中插入键值对等。但是，我们无法将两个表相加，无法对函数做比较，也琺调用一个字符串，除非使用元表。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>元表可以修改一个值在面对一个未知操作时的行为。例如，假设a和b都是表，那么可以通过元表定义Lua语言如何计算表达式a+b。当Lua语言试图将两个表相加时，它会先检查两者之一是否有元表且该元表中是否有<code>__add</code>字段。如果Lua语言找到了该字段，就调用该字段对应的值，即所谓的元方法，在本例中就是用于计算表的和的函数。<br>可以认为，元表是面向对象领域中的受限制类。像类一样，元表定义的是实例的行为。不过，由于元表只能给出预先定义的操作集合的行为，所以元表被类更受限；同时，元表也不支持继承。<br>Lua语言中的每一个值都可以有元表。每一个表和用户数据类型都具有各自独立的元表，而其他类型的值则共享对应类型所属的同一个元表。Lua语言在创建新表时不带元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t))   <span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>可以使用函数setmetatable来设置或修改任意表的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t) == t1)		<span class="comment">--true</span></span><br></pre></td></tr></table></figure>
<p>在Lua语言中，我们只能为表设置元表；如果要为其他类型的值设置元表，则必须通过C代码或调试库完成（该限制存在的主要原因是为了防止过度使用对某种类型的所有值生效的元表。Lua语言老版本中的经验表明，这样的全局设置经常导致不可重用的代码）。字符串标准库为所有的字符串都设置了同一个元表，而其他类型在默认情况中都没有元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">&quot;hi&quot;</span>))		<span class="comment">-- table:0x80772e0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">&quot;xuxu&quot;</span>))     <span class="comment">-- table:0x80772e0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="number">10</span>))			<span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="built_in">print</span>))		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>一个表可以成为任意值的元表；一组相关的表也可以共享一个描述了它们共同行为的通用元表；一个表还可以成为它自己的元表，用于描述其自身特有的行为。总之，任何配置都是合法的。</p>
<h2 id="算术运算相关的元方法"><a href="#算术运算相关的元方法" class="headerlink" title="算术运算相关的元方法"></a>算术运算相关的元方法</h2><p>假设有一个用表来表示集合的模块，该模块还有一些用来计算集合并集和交集等的函数。</p>
<blockquote>
<p>示例：一个用于集合的简单模块</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Set = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用指定的列表创建一个新的集合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.new</span><span class="params">(l)</span></span></span><br><span class="line">	<span class="keyword">for</span> _, v inpairs(l) <span class="keyword">do</span> set[v] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.union</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = Set.new&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> res[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(b) <span class="keyword">do</span> res[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.intersection</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = Set.new&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">		res[k] = b[k]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将集合表示为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.tostring</span><span class="params">(set)</span></span></span><br><span class="line">	<span class="keyword">local</span> l = &#123;&#125;		<span class="comment">-- 保存集合中所有元素的列表</span></span><br><span class="line">	<span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span></span><br><span class="line">		l[#l + <span class="number">1</span>] = <span class="built_in">tostring</span>(e)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(l.<span class="string">&quot;,&quot;</span>)..<span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Set </span><br></pre></td></tr></table></figure>
<p>现在，假设想使用加法操作符来计算两个集合的并集，那么可以让所有表示集合的表共享一个元表。这个元表中定义了这些表应该如何执行加法操作。首先，我们创建一个普通的表，这个表被用作集合的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后，修改用于创建集合的函数<code>Set.new</code>。在新版本中只多了一行，即将mt设置为函数Set.new所创建的表的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.new</span><span class="params">(l)</span></span>		<span class="comment">-- 第二个版本</span></span><br><span class="line">	<span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(set,mt)</span><br><span class="line">	<span class="keyword">for</span> _, v <span class="keyword">in</span> inpairs(l) <span class="keyword">do</span> set[v] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在此之后，所有由Set.new创建的集合都具有了一个相同的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = Set.new&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2 = Set.new&#123;<span class="number">30</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s1))			<span class="comment">-- table:0x00672B60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s2))			<span class="comment">-- table:0x00672B60</span></span><br></pre></td></tr></table></figure>
<p>最后，向元表中加入元方法<code>__add</code>，也就是用于描述如何完成加法的字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__add</span> = Set.union</span><br></pre></td></tr></table></figure>
<p>此后，只要Lua语言试图将两个集合相加，它就会调用函数Set.union，并将两个操作数作为参数传入。<br>通过元方法，我们就可以使用加法运算符来计算集合的并集了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3 = s1 + s2</span><br><span class="line"><span class="built_in">print</span>(Set.<span class="built_in">tostring</span>(s3))				<span class="comment">--&#123;1,10,20,30,50&#125;</span></span><br></pre></td></tr></table></figure>
<p>类似地，还可以使用乘法运算符来计算集合的交集：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__mul</span> = Set.intersection</span><br><span class="line"><span class="built_in">print</span>(Set.<span class="built_in">tostring</span>(s1 + s2)*s1)		<span class="comment">-- &#123;10,20,30,50&#125;</span></span><br></pre></td></tr></table></figure>
<p>每种算术运算符都有一个对应的元方法。除了加法和乘法外，还有减法(__sub)、除法(__div)、floor除法(__idiv)、负数(__unm)、取模(__mod)和幂运算(__pow)。类似地，位操作也有元方法：按位与(__band)、按位或(__bor)、按位异或(__bxor)、按位取反(__bnot)、向左移位(__shl)和向右位移(__shr)。我们还可以使用字段<code>__concat</code>来定义连接运算符的行为。<br>当我们把两个集合相加时，使用哪个元素是确定的。然而，当一个表达式中混合了两种具有不同元素的值时，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Set.new&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s = s + <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>Lua语言会按照如下步骤来查找元方法：如果第一个值有元表且元表中存在所需的元方法，那么Lua语言就使用这个元方法，与第二个值无关；如果第二个值有元表且元表中存在所需的元方法，Lua语言就使用这个元方法；否则，Lua语言就抛出异常。因此，上例会调用Set.union，而表达式10+s和”hello”+s同理（由于数值和字符串都没有元方法__add）。<br>Lua语言不关心这些混淆类型，但我们在实现中需要关心混合类型。如果我们执行了s &#x3D; s + 8，那么在Set.union内部就会发生错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad argument #<span class="number">1</span> to <span class="string">&#x27;pairs&#x27;</span> (<span class="built_in">table</span> expected , got number)</span><br></pre></td></tr></table></figure>
<p>如果想要得到更明确的错误信息，则必须在试图进行操作前显式地检查操作数的类型，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.union</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">getmetatable</span>(a) ~= mt <span class="keyword">or</span> <span class="built_in">getmetatable</span>(b) ~= mt <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;attempt to &#x27;add&#x27; a set with a non-set value&quot;</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	同前</span><br></pre></td></tr></table></figure>
<p>请注意，函数error的第二个参数说明了出错的原因位于调用该函数的代码中。</p>
<h2 id="关系运算相关的元方法"><a href="#关系运算相关的元方法" class="headerlink" title="关系运算相关的元方法"></a>关系运算相关的元方法</h2><p>元表还允许我们制定关系运算符的含义，其中的元方法包括等于(__eq)、小于(__lt)和小于等于(__le)。其他三个关系运算符没有单独的元方法，Lua语言会将<code>a~=b</code>转换为<code>not(a == b),a&gt;b</code>转换为<code>b&lt;a,a&gt;=b</code>转换为<code>b&lt;=a</code>。<br>在Lua语言的老版本中，Lua语言会通过将<code>a&lt;=b</code>转换为<code>not (b&lt;a)</code>来把所有的关系运算符转化为一个关系运算符。不过，这种转化在遇到部分有序时就会不正确。所谓部分有序是指，并非所有类型的元素都能够被正确地排序。例如，由于<em>Not a Number(NaN)<em>的存在，大多数计算机中的浮点数就不是完全可以排序的。根据IEEE 754标准，NaN代表未定义的值，例如</em>O&#x2F;O</em>的结果就是NaN。标准规定任何涉及NaN的比较都应返回假，这就意味着NaN&lt;&#x3D;x永远为假，x&lt;NaN也为假。因此，在这种情况下，<code>a&lt;=b</code>到<code>not(b&lt;a)</code>的转化也就不合法了。<br>在集合的示例中，我们也面临类似的问题。&lt;&#x3D;显而易见且有用的含义集合包含：<code>a&lt;=b</code>通常意味着a是b的一个子集。然而，根据部分有序的定义，<code>a&lt;=b</code>和<code>b&lt;a</code>可能同时为假。因此，我们就必须实现<code>__le</code>（小于等于，子集关系）和<code>__lt</code>（小于，真子集关系）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__le</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span> 		<span class="comment">-- 子集</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> b[k] <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mt.<span class="built_in">__lt</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span>		<span class="comment">-- 真子集</span></span><br><span class="line">	<span class="keyword">return</span> a&lt;= b <span class="keyword">and</span> <span class="keyword">not</span> (b &lt;= a)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>最后，我们还可以通过集合包含来定义集合相等:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__eq</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">return</span> a &lt;= b <span class="keyword">and</span> b &lt;= a</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有力这些定义后，我们就可以比较集合了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = Set.new&#123;<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">s2 = Set.new&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 &lt;= s2)			<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(s1 &lt; s2)			<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt;= s1)			<span class="comment">-- true</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt; s1)			<span class="comment">-- false</span></span><br><span class="line"><span class="built_in">print</span>(s1 == s2 * s1)	<span class="comment">-- true</span></span><br></pre></td></tr></table></figure>
<p>相等比较有一些限制。如果两个对象的类型不同，那么相等比较操作不会调用任何元方法而直接返回false。因此，不管元方法如何，集合永远不等于数字。</p>
<h2 id="库定义相关的元方法"><a href="#库定义相关的元方法" class="headerlink" title="库定义相关的元方法"></a>库定义相关的元方法</h2><p>到目前为止，我们见过的所有元方法针对的都是核心Lua语言。Lua语言虚拟机会检测一个操作中设计的值是否有存在对应元方法的元表。不过，由于元表是一个普通的表，所以任何人都可以使用它们。因此，程序库在元表中定义和使用它们自己的字段也是一种常见的时间。<br>函数tostring就是一个典型的例子。正如我们此前所看到的，函数tostring能将表表示一种简单的文本格式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;&#125;)			<span class="comment">--table:0x8062ac0</span></span><br></pre></td></tr></table></figure>
<p>函数print总是调用tostring来进行格式化输出。不过，当对值进行格式化时，函数tostring会首先检查值是否有一个元方法<code>__tostring</code>。如果有，函数tostring就调用这个元方法来完成工作，将对象作为参数传给该函数，然后把元方法的返回值作为函数tostring的返回值。<br>在之前集合的示例中，我们已经定义了一个将集合表示为字符串的函数。因此，只需要在元表中设置__tostring字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__tostring</span> = Set.<span class="built_in">tostring</span></span><br></pre></td></tr></table></figure>
<p>之后，当以一个集合作为参数调用函数print时，print就会调用函数tostring，tostring又会调用Set.tostring:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = Set.new&#123;<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1)			<span class="comment">-- &#123;4,5,10&#125;</span></span><br></pre></td></tr></table></figure>
<p>函数setmetatable和getmetatable也用到了元方法，用于保护元表。假设想要保护我们的集合，就要使用户既不能看到也不能修改集合的元表。如果在元表中设置__metatable字段，那么getmetatable会返回这个字段的值，而setmetatable则会引发一个错误：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__metatable</span> = <span class="string">&quot;not yopur business&quot;</span></span><br><span class="line"></span><br><span class="line">s1 = Set.new&#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s1))				<span class="comment">-- not your business</span></span><br><span class="line"><span class="built_in">setmetatable</span>(s1,&#123;&#125;)</span><br><span class="line">	<span class="built_in">stdin</span>:<span class="number">1</span>:cannot change protected metatable</span><br></pre></td></tr></table></figure>
<p>从Lua5.2开始，函数pairs也有了对应的元方法。因此我们可以修改表被遍历的方式和为非表的对象增加遍历行为。当一个对象拥有__pairs元方法时，pairs会调用这个元方法来完成遍历。</p>
<h2 id="表相关的元方法"><a href="#表相关的元方法" class="headerlink" title="表相关的元方法"></a>表相关的元方法</h2><p>算术运算符、位运算符和关系运算符的元方法都定义了各种错误情况的行为，但它们都没有改变语言的正常行为。Lua语言还提供了一种改变表在两种正常情况下的行为的方式，即访问和修改表中不存在的字段。</p>
<h3 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h3><p>正如我们此前所看到的，当访问一个表中不存在的字段时会得到nil。这是正确的，但不是完整的真相。实际上，这些访问会引发解释器查找一个名为<code>__index</code>的元方法。如果没有这个元方法，那么像一般情况下一样，结果就是nil；否则，则由这个元方法来提供最终结果。<br>下面介绍一个关于继承的原型示例。假设我们要创建几个表来描述窗口，每个表中必须描述窗口的一些参数，例如位置、大小及主题颜色等。所有的这些参数都有默认值，因此我们希望在创建窗口对象时只需要给出那些不同于默认值的参数即可。第一种方法是使用一个构造器来填充不存在的字段，第二种方法是让新窗口从一个原型窗口继承所有不存在的字段。首先，我们声明一个原型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建具有默认值的原型</span></span><br><span class="line">prototype = &#123;x = <span class="number">0</span>, y = <span class="number">0</span> ,width = <span class="number">100</span>,height = <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后，声明一个构造函数，让构造函数创建共享同一个元表的新窗口：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="built_in">setmetatable</span>(o,mt)</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>现在，我们来定义元方法__index:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_,key)</span></span></span><br><span class="line">	<span class="keyword">return</span> prototype[key]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这段代码后，创建一个新窗口，并查询一个创建时没有指定的字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = new&#123;x = <span class="number">10</span>,y = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(w.width) 		<span class="comment">-- 100</span></span><br></pre></td></tr></table></figure>
<p>Lua语言会发现w中没有对应的字段”width”，但却有一个带有<code>__index</code>元方法的元表。因此，Lua语言会以w（表）和”width”（不存在的键）为参数来调用这个元方法。元方法随后会用这个键来检索原型并返回结果。<br>在Lua语言中，使用元方法<code>__index</code>来实现继承是很普通的方法。虽然被叫作方法，但元方法<code>__index</code>不一定必须是一个函数，它还可以是一个表。当元方法是一个函数时，Lua语言会以表和不存在的键为参数调用该函数，正如我们刚刚所看到的。当元方法是一个表时，Lua语言就访问这个表。因此，在我们此前的示例中，可以把<code>__index</code>简单地声明为如下样式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__index</span> = prototype</span><br></pre></td></tr></table></figure>
<p>这样，当Lua语言查找元表的__index字段时，会发现字段的值是表prototype。因此，Lua语言就会在这个表中继续查找，即等价地执行prototype[“width”]，并得到预期的结果。<br>将一个表用作__index元方法为实现单继承提供了一种简单快捷的方法。虽然将函数用作元方法开销更昂贵，但函数却更加灵活：我们可以通过函数来实现多继承、缓存及其他一些变体。<br>如果我们希望在访问一个表时不调用__index元方法，那么可以使用函数rawget。调用rawget(t,i)会对表t进行原始的访问，即在不考虑元表的情况下对表进行简单的访问。进行一次原始访问并不会加快代码的执行（一次函数调用的开销就会抹杀用户所作的这些努力），但是，我们后续会看到，有时确实会用到原始访问。</p>
<h3 id="newindex元方法"><a href="#newindex元方法" class="headerlink" title="__newindex元方法"></a>__newindex元方法</h3><p>元方法<code>__newindex</code>与<code>__index</code>类似，不同之处在于前者用于表的更新而后者用于表的查询。当对一个表中不存在的索引赋值时，解释器就会查找<code>__newindex</code>元方法：如果这个元方法存在，那么解释器就调用它而不执行赋值。像元方法__index一样，如果这个元方法时一个表，解释器就在此表中执行赋值，而不是在原始的表中进行复制。此外，还有一个原始函数允许我们绕过元方法：调用rawset(t,k,v)来等价于<code>t[k] =v</code>，但不涉及任何元方法。<br>组合使用元方法__index和__newindex可以实现Lua语言中的一些强大的结构，例如只读的表、具有默认值的表和面向对象编程中的继承。</p>
<h3 id="具有默认值的表"><a href="#具有默认值的表" class="headerlink" title="具有默认值的表"></a>具有默认值的表</h3><p>一个普通表中所有字段的默认值都是nil。通过元表，可以很容易地修改这个默认值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefualut</span><span class="params">(t,d)</span></span></span><br><span class="line">	<span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="keyword">return</span> d <span class="keyword">end</span>&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab = &#123;x = <span class="number">10</span>, y = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tab.x,tab.z)			<span class="comment">-- 10  nil</span></span><br><span class="line">setDefualut(tab,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(tab.x,tab.z)		<span class="comment">-- 10  0 </span></span><br></pre></td></tr></table></figure>
<p>在调用setDefault后，任何对表tab中不存在字段的访问都将调用它的__index元方法，而这个元方法会返回零（这个元方法中的值是d）。<br>函数setDefault为所有需要默认值的表创阿金一个新的闭包和一个新的元表。如果我们有很多需要默认值的表，那么开销会比较大。然而，由于具有默认值d的元表是于元方法关联在一起的，所有我们不能把同意个元表用于具有不同默认的表。为了能够使所有的表都使用同一个元表，可以使用一个额外的字段将每个表的默认值存放到表自身中。如果不担心命名冲突的话，我们可以使用形如<code>___</code>这样的键作为额外的字段：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span> <span class="keyword">return</span> t.___ <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefualut</span><span class="params">(t,d)</span></span></span><br><span class="line">	t,___ = d</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>请注意，这里我们只在setDefault外创建了一次元表mt及对应的元方法。<br>如果担心命名冲突，要确保这个特殊键的唯一性也很容易，只需要创建一个新的排除表，然后将它作为键即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t)</span></span> <span class="keyword">return</span> t[key] <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefualut</span><span class="params">(t,d)</span></span></span><br><span class="line">	t[key] = d</span><br><span class="line">	<span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>还有一种方法可以将每个表与其默认值关联起来，称为对偶表示，即使使用一个独立的表，该表的键为各种表，值为这些表的默认值。不过，为了正确地实现这种做法，我们还需要一种特殊的表，称为弱引用表。在这里，我们暂时不会使用弱引用表。<br>另一种为具有相同默认值的表复用同一个元表的方式是记忆元表。不过，这也需要用到弱引用表。</p>
<h3 id="跟踪对表的访问"><a href="#跟踪对表的访问" class="headerlink" title="跟踪对表的访问"></a>跟踪对表的访问</h3><p>假设我们要跟踪对某个表的所有访问。由于__index和__newindex元方法都是在表中的索引不存在时才有用，因此，捕获对一个表访问的唯一方式是保持表是空的。如果要监控对一个表的所有访问，那么需要为真正的表创建一个代理。这个代理是一个空的表，具有用于跟踪所有访问并将访问重定向到原来的表格的合理元方法。</p>
<blockquote>
<p>示例： 跟踪对标的访问</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> proxy = &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 为代理创建元表</span></span><br><span class="line">	<span class="keyword">local</span> mt = &#123;</span><br><span class="line">		<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_,k)</span></span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;*access to element&quot;</span> .. <span class="built_in">tostring</span>(k))</span><br><span class="line">		<span class="keyword">return</span> t[k]			<span class="comment">-- 访问原来的表</span></span><br><span class="line">	<span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">	<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(_,k,v)</span></span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;*update to element &quot;</span> .. <span class="built_in">tostring</span>(k) .. <span class="string">&quot; to &quot;</span> ..<span class="built_in">tostring</span>(v))</span><br><span class="line">		t[k] = v      <span class="comment">-- 更新原来的表</span></span><br><span class="line">	<span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">	__pairs = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(_,k)</span></span>			<span class="comment">--迭代函数</span></span><br><span class="line">			<span class="keyword">local</span> nextkey,nextvalue = <span class="built_in">next</span>(t,k)</span><br><span class="line">			<span class="keyword">if</span> nextkey ~= <span class="literal">nil</span> <span class="keyword">then</span> 		<span class="comment">-- 避免最后一个值</span></span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;*traversing element &quot;</span> .. <span class="built_in">tostring</span>(nextkey))</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">return</span> nextkey,nextvalue</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">	<span class="built_in">__len</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> #t <span class="keyword">end</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setmetatable</span>(proxy,mt)</span><br><span class="line">	<span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>以下展示了上述代码的用法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;				<span class="comment">-- 任意一个表</span></span><br><span class="line">t = track(t)</span><br><span class="line">t[<span class="number">2</span>] = <span class="string">&quot;hello&quot;</span>		<span class="comment">-- *update of element 2 to hello</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">2</span>])		</span><br><span class="line"><span class="comment">-- *access to elemetn 2</span></span><br><span class="line"><span class="comment">-- hello</span></span><br></pre></td></tr></table></figure>
<p>元方法__index和__newindex按照我们设计的规则跟踪每一个访问并将其重定向到原来的表中。元方法__pairs使得我们能够像遍历原来的表一样遍历代理，从而跟踪所有的访问。最后，远方__len通过代理实现了长度操作符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = track(&#123;<span class="number">10</span>,<span class="number">20</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(#t)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">pairs</span>(k,v) <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- *traversing element 1</span></span><br><span class="line"><span class="comment">-- 1	10</span></span><br><span class="line"><span class="comment">-- *traversing element 2</span></span><br><span class="line"><span class="comment">-- 2	10</span></span><br></pre></td></tr></table></figure>
<p>如果想要同时监控几个表，并不需要为每个表创建不同的元表。相反，只要以某种形式将每个代理与其原始表映射起来，并且让所有的代理共享一个公共的元表即可。</p>
<h3 id="只读的表"><a href="#只读的表" class="headerlink" title="只读的表"></a>只读的表</h3><p>使用代理的概念可以很容易地实现只读的表，需要做的只是跟踪对表的更新操作并抛出异常即可。对于元方法__index，由于我们不需要跟踪查询，所以可以直接使用原来的表来代替函数。这样做比把所有的查询重定向到原来的表上更简单也更有效率。不过，这种做法要求为每个只读代理创建一个新的元表，其中__index元方法指向原来的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readOnly</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> proxy = &#123;&#125;</span><br><span class="line">	<span class="keyword">local</span> mt = &#123;</span><br><span class="line">		<span class="built_in">__index</span> = t,</span><br><span class="line">		<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,k,v)</span></span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;attempt to update a read-only table&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(proxy,mt)</span><br><span class="line">	<span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>作为示例，我们可以创建一个表示星期的只读表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">days = readOnly&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thrsday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(days[<span class="number">1</span>])			<span class="comment">-- Sunday</span></span><br><span class="line">days[<span class="number">2</span>] = <span class="string">&quot;Nodya&quot;</span></span><br><span class="line"><span class="comment">-- stdin:1:attempt to update a read-only table</span></span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/23/Lua%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5import%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/Lua%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5import%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Lua模块引入import和require的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-23 20:23:11" itemprop="dateCreated datePublished" datetime="2020-04-23T20:23:11+08:00">2020-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua 中引入一个模块，可以采用两种方式：<code>import </code>和<code>require</code>方式，具体的区别在于：</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h3 id="载入一个模块"><a href="#载入一个模块" class="headerlink" title="载入一个模块"></a>载入一个模块</h3><p><code>import() </code>与 <code>require() </code>功能相同，但具有一定程度的自动化特性。</p>
<p>假设我们有如下的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">app/classes/</span><br><span class="line">app/classes/MyClass.lua</span><br><span class="line">app/classes/MyClassBase.lua</span><br><span class="line">app/classes/data/Data1.lua</span><br><span class="line">app/classes/data/Data2.lua</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MyClass 中需要载入 MyClassBase 和 MyClassData。如果用 require()，MyClass 内的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> MyClassBase = <span class="built_in">require</span>(<span class="string">&quot;app.classes.MyClassBase&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> MyClass = class(<span class="string">&quot;MyClass&quot;</span>, MyClassBase)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> Data1 = <span class="built_in">require</span>(<span class="string">&quot;app.classes.data.Data1&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> Data2 = <span class="built_in">require</span>(<span class="string">&quot;app.classes.data.Data2&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如我们将 MyClass 及其相关文件换一个目录存放，那么就必须修改 MyClass 中的 require() 命令，否则将找不到模块文件。</p>
<p>而使用 import()，我们只需要如下写：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> MyClassBase = import(<span class="string">&quot;.MyClassBase&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> MyClass = class(<span class="string">&quot;MyClass&quot;</span>, MyClassBase)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> Data1 = import(<span class="string">&quot;.data.Data1&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> Data2 = import(<span class="string">&quot;.data.Data2&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当在模块名前面有一个”.” 时，import() 会从当前模块所在目录中查找其他模块。因此 MyClass 及其相关文件不管存放到什么目录里，我们都不再需要修改 MyClass 中的 import() 命令。这在开发一些重复使用的功能组件时，会非常方便。</p>
<p>我们可以在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。</p>
<p>不过 import() 只有在模块级别调用（也就是没有将 import() 写在任何函数中）时，才能够自动得到当前模块名。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/23/python%E7%94%BB%E7%B4%A0%E6%8F%8F%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/python%E7%94%BB%E7%B4%A0%E6%8F%8F%E7%94%BB/" class="post-title-link" itemprop="url">python画素描画</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-23 16:05:55" itemprop="dateCreated datePublished" datetime="2020-04-23T16:05:55+08:00">2020-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 18:35:00" itemprop="dateModified" datetime="2024-05-14T18:35:00+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用python将一副彩色图转换为黑白素描图，废话不多说，直接上代码</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/23/python%E7%94%BB%E7%B4%A0%E6%8F%8F%E7%94%BB/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/22/Lua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8Bfor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/22/Lua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8Bfor/" class="post-title-link" itemprop="url">Lua迭代器和泛型for</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-22 22:00:46" itemprop="dateCreated datePublished" datetime="2020-04-22T22:00:46+08:00">2020-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>迭代器是一种可以让我们遍历一个集合中所有元素的代码结构。在Lua语言中，通常使用函数表示迭代器：每一次调用函数时，函数会返回集合中的”下一个“元素。一个典型的例子是io.read，每次调用该函数时它都会返回标准输入中的下一行，在没有读取的行时返回nil。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。对于函数io.read而言，C语言会将状态保存在流的结构体中。对于我们自己的迭代器而言，闭包则为保存状态提供了一种良好的机制。庆祝，一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。当然，要创建一个新的闭包，我们还必须创建非局部变量。因此，一个闭包结构通常涉及两个函数；闭包本身和一个用于创建该闭包及其封装变量的工程。<br>作为示例，让我们来为列表编写一个简单的迭代器。与ipairs不同的是，该迭代器并不是返回每个元素的索引而是返回元素的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">values</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> i = i +<span class="number">1</span> ；<span class="keyword">return</span> t[i] <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，values就是工厂。每当调用这个工厂时，它就会创建一个新的闭包（既迭代器本身）。这个闭包将它的状态保存在其外部的变量t和i中，这两个变量也是由values创建的。每次调用这个迭代器时，它就从列表t中返回下一个值。在遍历完最后一个元素后，迭代器返回nil，表示迭代结束。<br>我们可以在一个while循环中使用这个迭代器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">iter = values(t)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> element = iter()</span><br><span class="line">	<span class="keyword">if</span> element == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，使用泛型for更简单。毕竟，泛型for正是为了这种迭代而设计的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> values(t) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>泛型for为一次迭代循环做了所有的记录工作：它的内部保存了迭代函数，因此不需要变量iter；它在每次做新的迭代时都会再次调用迭代器，并在迭代器返回nil时结束循环。<br>下面是一个更高级的示例，它可以遍历来自标准输入的所有单词。</p>
<blockquote>
<p>示例 遍历来自标准输入的所有单词的迭代器</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allwords</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> line = <span class="built_in">io</span>.<span class="built_in">read</span>()		<span class="comment">-- 当前行</span></span><br><span class="line">	<span class="keyword">local</span> pos  = <span class="number">1</span>				<span class="comment">-- 当前行的当前位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>			<span class="comment">-- 迭代函数</span></span><br><span class="line">	<span class="keyword">while</span> line <span class="keyword">do</span> 				<span class="comment">-- 当还有行时循环</span></span><br><span class="line">		<span class="keyword">local</span> w , <span class="number">3</span> = <span class="built_in">string</span>.<span class="built_in">match</span>(line,<span class="string">&quot;(%w+)()&quot;</span>,pos)</span><br><span class="line">			<span class="keyword">if</span> w <span class="keyword">then</span>				<span class="comment">-- 发现一个单词？</span></span><br><span class="line">				pos = e 			<span class="comment">-- 下一个位置位于该单词后</span></span><br><span class="line">				<span class="keyword">return</span> w 			<span class="comment">-- 返回该单词</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				line = <span class="built_in">io</span>.<span class="built_in">read</span>()	<span class="comment">-- 没找到单词；尝试下一行</span></span><br><span class="line">				pos  = <span class="number">1</span>			<span class="comment">-- 从第一个位置重新开始</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>					<span class="comment">-- 没有行了：迭代结束</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>为了完成这样的便利，我们需要保存两个值：当前行的内容及当前行的当前位置。有了这些数据，我们就可以不断产生下一个单词。这个迭代函数的主要部分是调用函数string.match，以当前位置作为起始在当前行中搜索一个单词。函数string.match使用模式’%w+’来匹配一个“单词”，也就是匹配一个或多个字母&#x2F;数字字符。如果函数string.match找到了一个单词，它就捕获并返回这个单词及该单词之后的第一个字符位置，迭代函数则更新当前位置并返回该单词；否则，迭代函数读取新的一行，然后重复上述搜索过程。在所有的行都被读取完后，迭代函数返回nil以表示迭代结束。<br>尽管迭代器本身有点复杂，但allwords的使用还是很简明易懂的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> allowrds () <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>对于迭代器而言，一种常见的情况就是，编写迭代器可能不太容易，但使用迭代器却十分简单。这也不是一个大问题，因为使用Lua语言编程的最终用户一般不会去定义迭代器，而只会使用那些宿主应用已经提供的迭代器。</p>
<h2 id="泛型for的语法"><a href="#泛型for的语法" class="headerlink" title="泛型for的语法"></a>泛型for的语法</h2><p>上述那些迭代器都有一个缺点，即需要为每个新的循环创建一个新的闭包。对于大多数情况而言，这或许不会有什么问题。例如，在之前的allwords迭代器中，创建一个闭包的开销相对于读取整个文件的开销而言几乎可以忽略不计。但是，在另外一些情况下，这样的开销可能会很可观。在这类情况中，我们可以通过使用泛型for自己保存迭代状态。<br>泛型for在循环过程中在其内部保存了迭代函数。实际上，泛型for保存了三个值：一个迭代函数、一个不可变状态和一个控制变量。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var-list <span class="keyword">in</span> <span class="built_in">exp</span>-list <span class="keyword">do</span></span><br><span class="line">	body</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中，var-list是由一个或多个变量名组成的列表，以逗号分隔；exp-list是一个或多个表达式组成的列表，同样以逗号分隔。通常，表达式列表只有一个元素，即一句对迭代器工厂的调用。例如，在如下代码中，变量列表是k,v,表达式列表只要一个元素pairs(t):</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">print</span>(k,v) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们把变量列表的第一个（或唯一的）变量称为控制变量，其值在循环过程中永远不会是nil，因为当其值为nil时循环就结束了。<br>for做的第一件事情就是对in后面的表达式求值。这些表达式应该返回三个值供for保存：迭代函数、不可变状态和控制变量的初始值。类似于多重赋值，只有最后一个表达式能够产生不止一个值；表达式列表的结果值会保留三个，多余的值会被丢弃，不足三个则以nil补齐。例如，在使用简单迭器时，工厂只会返回迭代函数，因此不可变状态和控制变量都是nil。<br>在上述的初始化步骤完成后，for使用不可变状态和控制变量为参数来调用迭代函数。从for代码结构的立足点来看，不可变状态根本没有意义。for只是把从初始化步骤得到的状态值传递给所有迭代函数。然后，for将迭代函数的返回值赋给变量列表中声名的变量。如果第一个返回值为nil，那么循环终止；否则，for执行它的循环体并再次调用迭代函数，再不断地重复这个过程。<br>更确切地说，形如</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var_1,... ,var_n <span class="keyword">in</span> explist <span class="keyword">do</span> block <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样代码结构与下列代码等价：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> _f, _s , _var = explist</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> var_1, ... , var_n = _f(_s,_var)</span><br><span class="line">		_var = _var_1</span><br><span class="line">		<span class="keyword">if</span> _var  == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">		block</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>因此，假设迭代函数为f，不可变状态为s，控制变量的初始值为a0，那么在循环中控制变量的值一次为a1 &#x3D; f(s,a0),a2 &#x3D; f(s,a1),一次类推，直至ai为nil。如果for还有其他变量，那么这些变量只是简单地在每次调用f后得到额外的返回值。</p>
<h2 id="无状态迭代器"><a href="#无状态迭代器" class="headerlink" title="无状态迭代器"></a>无状态迭代器</h2><p>顾名思义，无状态迭代器就是一种自身不保存任何状态的迭代器。因此，可以在多个循环中使用同一个无状态迭代器，从而避免创建新闭包的开销。<br>正如刚刚所看到的，for循环会以不可变状态和控制变量为参数低啊用迭代函数。一个无状态迭代器只根据这两个值来迭代生成下一个元素。这类迭代器的一个典型例子就是ipairs，它可以迭代一个序列中的所有元素：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(i,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>迭代的状态由正在被遍历的表（一个不可变状态，它不会在循环中改变）及当前的索引值（控制变量）组成。ipairs和迭代器都非常简单，我们可以在Lua语言中将其编写出来：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter</span><span class="params">(t,i)</span></span></span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line">	<span class="keyword">local</span> v = t[i]</span><br><span class="line">	<span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> i, v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">return</span> iter, t, <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当调用for循环中的ipairs(t)时，ipairs(t)会返回三个值，即迭代函数iter、不可变状态表t和控制变量的初始值0。然后，Lua语言调用iter(t,0)，得到1,t[1]（除非t[1]已经变成nil）。在第二次迭代中，Lua语言调用iter(t,1)，得到2,t[2]，依次类推，直至得到第一个为nil的元素。<br>函数pairs与函数ipairs类似，也用于遍历一个表中的所有元素。不同的是，函数pairs的迭代函数是Lua语言中的一个基本函数next：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairs</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">next</span>,t,<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在低啊用next(t,k)时，k是表t的一个键，该函数会以随机次序返回表中的下一个键及k对应的值（作为第二个返回值）。调用next(t,nil)时，返回表中的第一个键值对。当所有元素被遍历完时，函数next返回nil。<br>我们可以不调用pairs而直接使用next：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">next</span> , t <span class="keyword">do</span></span><br><span class="line">	loop body</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>请注意，for循环会把表达式列表的结果调整为三个值，因此上例得到的是next、t和nil，这也正与pairs(t)的返回值完全一致。<br>关于无状态迭代器的另一个有趣的示例是遍历链表的迭代器（链表在Lua语言中并不常见，但有时也需要用到）。我们的第一反应可能是只把当前节点当做控制变量，以便于迭代函数能够返回下一个节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getnext</span><span class="params">(node)</span></span></span><br><span class="line">	<span class="keyword">return</span> node.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">return</span> getnext, <span class="literal">nil</span>, list</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>但是，这种实现会跳过第一个节点。所以，我们需要使用如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getnext</span><span class="params">(list,node)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> list</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node.<span class="built_in">next</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">return</span> getnext, list,<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里的技巧是，除了将当前节点作为控制变量，还要将头节点作为不可变状态。第一次调用迭代函数getnext时，node为nil，因此函数返回list作为第一个节点。在后续的调用中，node不再是nil，所以迭代函数会像我们所期望的那样返回node.next。</p>
<h2 id="按顺序遍历表"><a href="#按顺序遍历表" class="headerlink" title="按顺序遍历表"></a>按顺序遍历表</h2><p>一个常见的困惑发生在开发人员想要对表中的元素进行排序时。由于一个表中的元素没有顺序，所以如果想对这些元素排序，就不得不把键值对拷贝到一个数组中，然后再对数组进行排序。<br>假设我们要读取一个源文件，然后构造一个表来保存每个函数的名称及其声明所在的行数，形式如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lines</span> = &#123;</span><br><span class="line">	[<span class="string">&quot;luaH_set&quot;</span>]     = <span class="number">10</span>,</span><br><span class="line">	[<span class="string">&quot;luaH_get&quot;</span>]	 = <span class="number">24</span>,</span><br><span class="line">	[<span class="string">&quot;luaH_present&quot;</span>] = <span class="number">48</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们想按照字母顺序输出这些函数名。如果使用pairs遍历表，那么函数名会按照随机的顺序出现。由于这些函数名是表的键，所以我们无法直接对其进行排序。不过，我们把他们放到数组中，那么就可以对它们进行排序了。首先，我们必须创建一个包含函数名的数组，然后对其排序，再最终输出结果。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">lines</span>) <span class="keyword">do</span> a[#a + <span class="number">1</span>] = n <span class="keyword">end</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(a)</span><br><span class="line"><span class="keyword">for</span> _, n <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span> <span class="built_in">print</span>(n) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有些人可能会困惑。毕竟，对于Lua语言来说，数组也没有顺序。但是我们知道如何数数！因此，当我们使用有序的索引访问数组时，就实现了有序。这正是应该总是使用ipairs而不是pairs来遍历数组的原因。第一个函数通过有序的键1、2等来实现有序，然而后者使用则是天然的随机顺序（虽然大多数情况下顺序随机也无碍，但有时可能并非我们想要的）。<br>现在，我们已经准备好写一个按照键的顺序来遍历表的迭代器了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairsByKeys</span><span class="params">(t,f)</span></span></span><br><span class="line">	<span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="comment">--  创建一个包含所有键的表</span></span><br><span class="line">		a[#a + <span class="number">1</span>] = n</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">sort</span>( a, f )  <span class="comment">-- 对列表排序</span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">0</span>         <span class="comment">-- 迭代变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>   <span class="comment">-- 迭代函数</span></span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">		returna[i],t[a[i]]		<span class="comment">--返回键和值</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>工厂函数pairsByKeys首先把键放到一个数组中，然后对数组进行排序，最后返回迭代函数。在每一步中，迭代器都会按照数组a中的顺序返回原始表中的下一个键值对。可选的参数f允许指定一种其他的排序方法。<br>使用这个函数，可以很容易地解决开始时提出的按顺序遍历表的问题：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,line <span class="keyword">in</span> pairsByKeys(<span class="built_in">lines</span>) <span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">print</span>(name,line)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>像通常的情况一样，所有的复杂性都被隐藏到了迭代器中。</p>
<h2 id="迭代器的真实含义"><a href="#迭代器的真实含义" class="headerlink" title="迭代器的真实含义"></a>迭代器的真实含义</h2><p>“迭代器”这个名称多少有点误导性，这是因为迭代器并没有进行实际的迭代：真正的迭代时for循环完成的，迭代器只不过为每次的迭代提供连续的值。或许，称其为“生成器”更好，表示迭代生产元素；不过，“迭代器”这个名字已在出入Java等其他语言中被广泛是用了。<br>然而，还有一种创建迭代器的方式可以让迭代器进行实际的迭代操作。当使用这种迭代器时，就不再需要编写循环了。相反，只需要调用这个迭代器，并传入一个描述了在每次迭代时需要做什么的参数即可。更确切地说，迭代器接收了一个函数作为参数，这个函数在循环的内部被调用，这种迭代器就被称为真正的迭代器。<br>&ensp;&ensp;举一个具体的例子，让我们使用这种风格再次重写allowrds迭代器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allwords</span><span class="params">(f)</span></span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.line() <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(line,<span class="string">&quot;%w+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">			f(word)			<span class="comment">--调用函数</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>使用这个迭代器时，我们必须传入一个函数作为循环体。如果我们只想输出每个单词，那么简单地使用函数print即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allwords(<span class="built_in">print</span>)</span><br></pre></td></tr></table></figure>
<p>通常，我们可以使用一个匿名函数作为循环体。例如，以下的代码用于计算单词”hello”在输入文件中出现的次数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">allwords(<span class="function"><span class="keyword">function</span><span class="params">(w)</span></span></span><br><span class="line">	<span class="keyword">if</span> w == <span class="string">&quot;hello&quot;</span> <span class="keyword">then</span> count = count + <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>
<p>同样的需求，如果采用之前的迭代器风格，差异也不是特别大：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> allwords() <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> w == <span class="string">&quot;hello&quot;</span> <span class="keyword">then</span> count = count + <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;真正的迭代器在老版本的Lua语言中曾非常流行，那是还没有for语句。真正的迭代器与生成器风格的迭代器相比怎么样呢？这两种风格都有大致相同的开销，即每次迭代都有一次函数调用。一方面，编写真正的迭代器比较容易。另一方面，生成器风格的迭代器则更灵活。首先，生成器风格的迭代器允许两个或更多个并行的迭代。其次，生成器风格的迭代器允许在循环体中使用break和return语句。使用真正的迭代器，return语句从匿名函数中返回而非从进行迭代的函数中返回。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/21/Lua%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/Lua%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/" class="post-title-link" itemprop="url">Lua中模块和包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 20:41:58" itemprop="dateCreated datePublished" datetime="2020-04-21T20:41:58+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通常，Lua语言不会设置规则。相反，Lua语言提供的是足够强大的机制供不同的开发者实现最适合自己的规则。然而，这种方法对于模块而言并不是特别适用。模块系统的主要目标之一就是允许不同的人共享代码，缺乏公共规则就无法实现这样的分享。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>Lua语言从5.1版本开始为模块和包定义了一系列的规则。这些规则不需要从语言中引入额外的功能，程序猿可以使用目前为止我们学习到的机制实现这些规则。程序员也可以自由地使用不同的策略。当然，不同的实现可能会导致程序不能使用外部模块，或者模块不能被外部程序使用。<br>从用户观点来看，一个模块就是一些代码，这些代码可以通过函数require加载，然后创建和返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。<br>例如，所有的标准库都是模块。我们可以按照如下的方式使用数学库：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">sin</span>(<span class="number">3.14</span>))				<span class="comment">-- 0.0015926529164868</span></span><br></pre></td></tr></table></figure>
<p>独立解释器会使用跟如下代码等价的方式提前加载所有标准库：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">math</span> = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="built_in">string</span> = <span class="built_in">require</span> <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure>
<p>这种提前加载使得我们可以不用费劲地编写代码来加载模块math就可以直接使用函数math.sin。<br>使用表来实现模块的显著优点之一是，让我们可以像操作普通表那样操作模块，并且能利用Lua语言的所有功能实现额外的功能。在大多数语言中，模块不是第一类值（即它们不能被保存在变量中，也不能被当作参数传递给函数等），所以那些语言需要为模块实现一套专门的机制。而在Lua语言中，我们则可以轻易地实现这些功能。<br>例如，用户调用模块中的函数就有几种方法。其中常见的方法是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line"><span class="built_in">mod</span>.foo()</span><br></pre></td></tr></table></figure>
<p>用户可以为模块设置一个局部名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line">m.foo()</span><br></pre></td></tr></table></figure>
<p>也可以为个别函数提供不同的名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line"><span class="keyword">local</span> f = m.foo</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>还可以只引入特定的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span>.foo 			<span class="comment">-- (require(&quot;mod&quot;)).foo</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>上述这些方法的好处是无须语言的特别支持，它们使用的都是语言已经提供的功能。</p>
<h2 id="函数-require"><a href="#函数-require" class="headerlink" title="函数 require"></a>函数 require</h2><p>尽管函数require也只是一个没什么特殊之处的普通函数，但在Lua语言的模块实现中扮演者核心角色。要加载模块时，只需要简单地调用这个函数，然后传入模块作为参数。请记住，当函数的参数只有一个字符串常量时括号是可以省略的，而且一般在使用require时按照惯例也会省括号。不过尽管如此，下面这些用法也是正确的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> modname = <span class="string">&#x27;math&#x27;</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(modname)</span><br></pre></td></tr></table></figure>
<p>函数require尝试对模块的定义做最小的假设。对于函数来说，一个模块可以是定义了一些变量的代码。典型地，这些代码返回一个由模块中函数组成的表。不过，由于这个动作是由模块代码而不是由函数require完成的，所以某些模块可能会选择返回其他的值或者甚至引发副作用。<br>首先，函数require在表package.loaded中检查模块是否已被加载。如果模块已经被加载，函数require就返回相应的值。因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。<br>如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径有变量package.path指定）。如果函数require找到了相应的文件，那么就用函数loadfile将其进行加载，结果是一个我们称之为加载器的函数。<br>如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。如果找到了一个C标准库，则使用底层函数package.loadlib进行加载，这个底层函数会查找名为luaopen_modname的函数。在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数luaopen_modname。<br>不管模块是Lua文件还是C标准库中找到的，函数require此时都具有了用于加载它的加载函数。为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在文件名称。如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载同一个模块时返回相同的值。如果加载函数么有返回值且表中的package.loaded【@rep{modname}]为空，函数require就假设模块的返回值是true。如果没有这种补偿，那么后续调用函数require时将会重复加载模块。<br>要强制函数require加载同一模块两次，可以先将模块从package.loaded中删除：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>.modname = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>下一次在加载这个模块时，函数require就会重新加载模块。<br>对于函数require来说，一个常见的抱怨是它不能给待加载的模块传递参数。例如，数学模块可以对角度和弧度的选择增加一个选项：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误的代码</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">math</span> = <span class="built_in">require</span>(<span class="string">&quot;math&quot;</span>,<span class="string">&quot;degree&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的问题在于，函数require的主要目的之一就是避免重复加载模块，一旦一个模块被加载，该模块就会在后续所有调用require的程序部分被复用。这样，不同参数的同名模块之间就会产生冲突。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line"><span class="built_in">mod</span>.init(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果加载函数返回的是模块本身，那么还可以写成：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span>.init(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>请记住，模块在任何情况下只加载一次；至于如何处理冲突的加载，取决于模块自己。</p>
<h3 id="模块重命名"><a href="#模块重命名" class="headerlink" title="模块重命名"></a>模块重命名</h3><p>通常，我们通过模块本来的名称来使用它们，但有时，我们也需要将一个模块改名以避免命名冲突。一点典型的情况就是，处于测试的目的而需要加载同一模块的不同版本。对于一个Lua语言模块来说，其内部的名称并不要求是固定的，因此通常修改.lua文件的文件名就够了。不过，我们却无法修改C标准库的二进制目标代码中<code>luaopen_*</code>函数的名称。为了进行这种重命名，函数require运用了一个连字符的技巧：如果一个模块名中包含连字符，那么函数require就会用连字符之前的内容创建<code>luaopen_*</code>函数的名称。例如，如果一个模块的名称为mod-v3.4，那么函数require会认为该模块的加载函数应该是<code>luaopen_mod</code>而不是luaopen_mod-v3.4（这也不是有效的C语言函数名）。因此，如果需要使用两个名称均为mod的模块（或相同模块的两个不同版本），那么可以对其中的一个进行重命名，如mod-v1.当调用m1&#x3D;require “mod-v1”时，函数require会找到改名后的文件mod-v1并将其中原名为luaopen_mod的函数作为加载函数。</p>
<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>在搜索一个Lua文件时，函数require使用的路径与典型的路径略有不同。典型的路径是很多目录组成的列表，并在其中搜索指定的文件。不过，IOS C（Lua语言依赖的抽象平台）并没有目录的概念。所以，函数require使用的路径是一组模块，其中的每项都指定了蒋模块名(函数require的参数)转换为文件名的方式。更准确地说，这种路径中的每一个模块都是一个包含可选问号的文件名。对于每个模板，函数require会用模块名来替换每一个问号，然后检查结果是否存在对应的文件；如果不存在，则尝试下一个模板。路径中模板以在大所述操作系统中很少被用于文件名的分号隔开。例如，考虑如下路径：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?;?.lua;c:\windows\?;/usr/<span class="keyword">local</span>/lua/?/?.lua</span><br></pre></td></tr></table></figure>
<p>在使用这个路径时，调用require “sql”将尝试打开如下的Lua文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">sql.lua</span><br><span class="line">c:\windows\sql</span><br><span class="line">/usr/<span class="keyword">local</span>/lua/sql/sql.lua</span><br></pre></td></tr></table></figure>
<p>函数require只处理分号（作为分隔号）和问号，所有其他的部分（包括目录分隔符合文件扩展名）则由路径自有定义。<br>函数require用于搜索Lua文件的路径是变量package.path的当前值。当package模块被初始化后，它就把变量package.path设置成环境变量LUA_PATH_5_3的值。如果这个环境变量没有被定义，那么Lua语言则尝试另一个环境变量LUA_PATH。如果这两个环境变量都没有被定义，那么Lua语言则使用一个编译是定义的默认路径。在使用一个环境变量的值时，Lua语言会将其中所有的”;;”替换成默认路径。例如，如果LUA_PATH_5_3设为”mydir&#x2F;r.lua;;”,那么最终路径就会是模板”mydir&#x2F;?.lua”后跟默认路径。<br>搜索C标准库的路径的逻辑与此相同，只不过C标准库的路径来自变量package.cpath而不是package.path。类似地，这个变量的初始值也来自环境变量LUA_CPATH_5_3或LUA_CPATH。在POSIX系统中这个路径的典型值形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./?.so;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.2</span>/?.so</span><br></pre></td></tr></table></figure>
<p>请注意定义文件扩展名的路径。在上例中，所有模块使用的都是.so，而在Windows操作系统中此典型路径通常形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\&gt;.dll;C:\Program Files\Lua502\dll\?.dll</span><br></pre></td></tr></table></figure>
<p>函数package.searchpath中实现了搜索库的所有规则，该函数的参数包括模块名和路径，然后遵循上述规则来搜索文件。函数package.searchpath要么返回第一个存在的文件的文件名，要么返回nil外加描述所有文件都无法成功打开的错误信息，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">&quot;.\\?.dll;C:\\Programe Files\\Lua502\\dll\\?.dll&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.searchpath(<span class="string">&quot;X&quot;</span>,<span class="built_in">path</span>))</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">			no file <span class="string">&#x27;.\X.dll&#x27;</span></span><br><span class="line">			no file <span class="string">&#x27;C:\Program Files\Lua502\dll\X.dll&#x27;</span></span><br></pre></td></tr></table></figure>
<p>作为一个有趣的练习，我们在示例中实现了与函数package.searchpath类似的函数。</p>
<blockquote>
<p>示例，实验班的package.searchpath</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">(modname,path)</span></span></span><br><span class="line">	modname = <span class="built_in">string</span>.<span class="built_in">gsub</span>(modname,<span class="string">&quot;%.&quot;</span>,<span class="string">&quot;/&quot;</span>)</span><br><span class="line">	<span class="keyword">local</span> msg = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(<span class="built_in">path</span>, <span class="string">&quot;[^;]+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> fname = <span class="built_in">string</span>.<span class="built_in">gsub</span>(c,<span class="string">&quot;?&quot;</span>,modname)</span><br><span class="line">		<span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">open</span>(fname)</span><br><span class="line">		<span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">			f:<span class="built_in">close</span>()</span><br><span class="line">			<span class="keyword">return</span> fname</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			msg[#msg + <span class="number">1</span>] = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;\n\tno file &#x27;%s&#x27;&quot;</span>,fname);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> , <span class="built_in">table</span>.<span class="built_in">concat</span>(msg)			<span class="comment">-- 没找到</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述函数首先替换目录分隔符，在本例中即把所有的点换成斜杠。之后，该函数遍历路径中的所有组成部分，也就是每一个不含分号的最长匹配。对于每一个组成部分，该函数使用模块名来替换问号得到最终的文件名，然后检查相应的文件是否存在。如果存在，该函数关闭这个文件，然后返回文件的名称；否则，该函数保存失败的文件名用于可能的错误提示（请注意字符串缓冲区在避免创建无用的长字符串时的作用）。如果一个文件都找不到，该函数则返回nil及最终的错误信息。</p>
<h3 id="搜索器"><a href="#搜索器" class="headerlink" title="搜索器"></a>搜索器</h3><p>在现实中，函数require比此前描述过的稍微复杂一点。搜索Lua文件和C标准库的方式只是更加通用的搜索器的两个实例。一个搜索器是一个以模块名为参数，以对应模块的加载器或nil为返回值的简单函数。<br>数组package.searchers列出了函数require使用的所有搜索器。在寻找模块时，函数require传入模块名并调用列表中的每一个搜索器知道它们其中的一个找到了指定模块的加载器。如果所有所搜器都被调用完后还找不到，那么函数require就抛出一个异常。<br>用一个列表来驱动对一个模块的搜索给函数require提供了极大的灵活性。例如，如果想保存被压缩在zip文件中的模块，只需要提供一个合适的搜索器，然后把它增加到该列表中。在默认配置中，我们此前学习过的用于搜索Lua文件和C标准库的搜索器排在列表的第二、三位，在它们之前是预加载搜索器。<br>预加载搜索器使得我们能够为要记载的模块定义任意的加载函数。预加载搜索器使用一个名为package.preload的表来映射模块名称和加载函数。当搜索指定的模块名时，该搜索器只是简单地在表中搜索指定的名称。如果它找到了对应的函数，那么就将该函数作为相应模块的加载函数返回；否则，则返回nil。预加载搜索器为处理非标场景提供了一种通用的方式。例如，一个静态链接到Lua中的C标准库可以将其luaopen_函数注册到表preload中，这样luaopen_函数只有当用户加载这个模块时才会被调用。用这种方式，程序不会为没有用到的模块浪费资源。</p>
<h2 id="Lua语言中编写模块的基本方法"><a href="#Lua语言中编写模块的基本方法" class="headerlink" title="Lua语言中编写模块的基本方法"></a>Lua语言中编写模块的基本方法</h2><p>在lua语言中创建模块的最简单方法是，创建一个表并将所有需要导出的函数放入其中，最后返回个表。示例就是这个方法：</p>
<blockquote>
<p>一个用于复数的简单模块</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;   <span class="comment">-- 模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个新的复数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,i)</span></span></span><br><span class="line">	<span class="keyword">return</span>&#123;r = r , i = i&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">M.new = new 		<span class="comment">-- 把&#x27;new&#x27;加到模块中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- constant &#x27;i&#x27;</span></span><br><span class="line">M.i = new(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.add</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r + c2.r,c1.i + c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.sub</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r - c2.r,c1.i - c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.mul</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> new(c1.r*c2.r - c1.i*c2.i,c1.r*c2.i + c1.i*c2.r)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">inv</span><span class="params">(c)</span></span></span><br><span class="line">	<span class="keyword">local</span> n = c.r^<span class="number">2</span> + c.i^<span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> new(c.r/n,-c.i/n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.div</span><span class="params">(c1,c2)</span></span></span><br><span class="line">	<span class="keyword">return</span> M.mul(c1,inv(c2))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.tostring</span><span class="params">(c)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;(%g,%g)&quot;</span>,c.r,c.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure>
<p>请注意我们是如何通过简单地把new和inv声明为局部变量而使它们称为代码段的私有函数的。<br>有些人不喜欢最后的返回语句。一种将其省略的方式是直接把模块对应的表放在package.loaded中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[...] = M</span><br></pre></td></tr></table></figure>
<p>请注意，函数require会把模块的名称作为第一个参数传给加载函数。因此，表索引中的可变长参数表达式…其实就是模块名。在这一赋值语句后，我们就不再需要在模块的最后返回M了：如果一个模块没有返回值，那么函数require会返回package.loaded[modname]的当前值。不过，笔者认为在模块的最后加上return语句更清晰。如果我们忘了return语句，那么在测试模块的时候就很容易就会发现问题。<br>另一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表，参考示例</p>
<blockquote>
<p>示例：使用导出表的模块</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,i)</span></span> <span class="keyword">return</span> &#123;r = r, i = i&#125; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> i = complex.new(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">	new  = new,</span><br><span class="line">	i    = i,</span><br><span class="line">	add  = add,</span><br><span class="line">	<span class="built_in">sub</span>  = <span class="built_in">sub</span>,</span><br><span class="line">	mul  = mul,</span><br><span class="line">	div  = div,</span><br><span class="line">	<span class="built_in">tostring</span> = <span class="built_in">tostring</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的有点在于，无须在每一个标识符前增加前缀M.或类似的东西。通过显式的导出表，我们能够以与在模块中相同的方式定义和使用导出和内部函数。这种方式的缺点在于，导出表位于最后不是最前面（把前面的话当作简略文档的话更有用），而且由于必须把每个名字都写两遍，所以导出表有点冗余（这一点其实可能会变成优点，因为这允许函数在模块内和模块外具有不同的名称，不过程序很少会用到）。<br>不管怎样，无论怎样定义模块，用户都能用标准的方法使用模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cpx = <span class="built_in">require</span> <span class="string">&quot;complex&quot;</span></span><br><span class="line"><span class="built_in">print</span>(cpx.<span class="built_in">tostring</span>(cpx.add(cpx.new(<span class="number">3</span>,<span class="number">4</span>),cpx.i)))				<span class="comment">-- (3,5)</span></span><br></pre></td></tr></table></figure>
<p>后续，我们会看到如何使用诸如元表和环境之类的高级Lua语言功能来编写模块。 不过，除了发现由于失误而定义的全局变量时又一个技巧外，笔者编写模块时都是用基本功能。</p>
<h2 id="子模块和包"><a href="#子模块和包" class="headerlink" title="子模块和包"></a>子模块和包</h2><p>Lua支持具有层次结构的模块名，通过点来分隔名称中的层次。例如，一个名为mod.sub的模块是模块魔的一个子模块。一个包是一棵由模块组成的完整的树，它是Lua语言中用于发行程序的单位。<br>当加载一个名为mod.sub的模块时，函数require一次使用原始的模块名”mod.sub”作为键来查询表package.loaded和表package.preload。这里，模块名中的点像模块名中的其他字符一样，没有特殊含义。<br>然而，当搜索一个定义子模块的文件时，函数require会将点转换为另一个字符，通常就是操作系统的目录分隔符（例如，POSIX操作系统的斜杠或Windows操作系统的反斜杠）。转换之后，函数require会像搜索其他名称一样搜索这个名称。例如，假设目录分隔符是斜杠并且有如下路径：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./?.lua;/usr/<span class="keyword">local</span>/lua/?.lua;/usr/<span class="keyword">local</span>/lua/?/init.lua</span><br></pre></td></tr></table></figure>
<p>调用require “a.b”会尝试打开以下文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./a/b.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/lua/a/b.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/lua/a/b/init.lua </span><br></pre></td></tr></table></figure>
<p>这种行为使得一个包中的所有模块能够放到一个目录中。例如，一个具有模块p、p.a和p.b的包对应的文件可以分贝是p&#x2F;init.lua、p&#x2F;a.lua和p&#x2F;b.lua，目录p又位于其他合适的目录中。<br>Lua语言使用的目录分隔符是编译时配置的，可以是任意的字符串（请记住，Lua并不知道目录的存在）。例如，没有目录层次的系统可以使用下画线作为”目录分隔符“，因此调用require “a,b”会搜索文件a_b.lua。<br>作为一种额外的机制，函数require在加载C语言编写的子模块时还有另外一个搜索器。当该函数找不到子模块对应的Lua文件或C文件时，它会再次搜索C文件所在的路径，不过这次将搜索包的名称。例如，如果一个程序要加载子模块a.b.c，搜索器会搜索文件a。如果找到了C标准库a，那么函数require就会在该库中搜索对应的加载函数luaopen_a_b_c。这种机制允许一个发行包将几个子模块组织为一个C标准库，每个子模块有各自的加载函数。<br>从Lua语言的视角看，同一个包中的子模块没有显式的关联。加载一个模块并不会自动加载它的任何子模块。同样，加载子模块也不会自动地加载其父模块。当然，只要包的实现者愿意，也可以创造这种关联。例如，一个特定的模块可能一开始就显式地加载它的一个或全部子模块。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/20/Lua%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/Lua%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">Lua编译执行和错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-20 17:26:38" itemprop="dateCreated datePublished" datetime="2020-04-20T17:26:38+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虽然我们把Lua语言成为解释型语言，但Lua语言总是在运行代码前先预编译源码为中间代码（这没什么大不了的，很多解释型语言也这样做）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/20/Lua%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/20/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">用树莓派搭建虚拟专用网络服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-20 14:07:31" itemprop="dateCreated datePublished" datetime="2020-04-20T14:07:31+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 18:38:11" itemprop="dateModified" datetime="2024-05-14T18:38:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/" itemprop="url" rel="index"><span itemprop="name">树莓派</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">服务器搭建</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">虚拟专用网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文详细介绍了如何使用树莓派在Ubuntu系统上搭建虚拟专用网络服务器，包括安装pptp、配置内网IP策略、配置DNS、设置TCP/IP数据转发、开放网络端口等步骤。通过这个方法，你可以在树莓派上轻松搭建自己的VPN服务器。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/20/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">Lua数据文件和序列化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 23:56:16" itemprop="dateCreated datePublished" datetime="2020-04-18T23:56:16+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在处理数据文件时，写数据通常比读数据简单很多。当向一个文件中写时，我们拥有绝对的控制权；但是，当从一个文件中读时，我们并不知道会读什么东西。一个健壮的程序除了能够处理一个合法文件中所包含的所有类型的数据外，还应该能够优雅地处理错误的文件。因此，编写一个健壮的处理输入的程序总是比较困难的。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>Lua语言自1993年发布以来，其主要用途之一就是描述数据。在那个年代，主要的文本数据描述语言之一是SGML。对于很多人来说，SGML既臃肿又复杂。在1998年，有些人将其简化成XML，但以我们的眼光看仍然臃肿又复杂。有些人跟我们的观点一直，进而在2001年开发了JSON。JSON基于JavaScript，类似于一种精简过的Lua语言数据文件。一方面，JSON的一大优势在于它是国际标准，包括Lua语言在内的多种语言都具有操作JSON文件的标准库。另一方面，Lua语言数据文件的读取更加容易和灵活。<br>使用一门全功能的编程语言来描述数据确实非常灵活，但也会带来两个问题。问题之一在于安全性，这是因为“数据”文件能够肆意地在我们的程序中运行。我们可以通过沙盒中运行程序来解决这个问题。<br>另一个问题是性能问题。Lua语言不仅运行得快，编译也很快。例如，在笔者的新机器上，Lua5.3可以在4秒以内，占用240MB内存，完成1000万条赋值语句的读取、编译和运行。作为对比，Perl5.18需要21秒、占用6GB内存，Python2.7和Python3.4直接崩溃，Node.js0.10.25在运行8秒后抛出“内存溢出”异常，Rhino1.7在运行6分钟后也抛出了“内存溢出”异常。</p>
<h2 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h2><p>对于文件格式来说，表构造器提供了一种有趣的替代方法。只需在写入数据时做一点额外的工作，就能使得读数据变得容易。这种技巧就是将数据文件写成Lua代码，当这些代码运行时，程序也就把数据重建了。使用表构造器时，这些代码段看上去会非常像是一个普通的数据文件。<br>下面通过一个示例来进一步展示处理数据文件的方式。如果数据文件使用的是诸如CSV或XML等预先定义好的格式，那么我们能够选择的方法不多。不过，如果处理的是处于自身需求而创建的数据文件，那么就可以将Lua语言的构造器用于格式定义。此时，我们把每条数据记录表示为一个Lua构造器。这样，原来类似</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Donald E. Knuth,Literate Programming,CSLI,<span class="number">1992</span></span><br><span class="line">Jon Bentley,More Programming Pearls, Addison-Wesley,<span class="number">1990</span></span><br></pre></td></tr></table></figure>
<p>的数据文件就可以改为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry&#123;<span class="string">&quot;Donald E. Knuth&quot;</span>,<span class="string">&quot;Literate Programming&quot;</span>,<span class="string">&quot;CSLI&quot;</span>,<span class="number">1992</span>&#125;</span><br><span class="line">Entry&#123;<span class="string">&quot;Jon Bentley&quot;</span>,<span class="string">&quot;More Programming Pearls&quot;</span>,<span class="string">&quot;Addison-Wesley&quot;</span>,<span class="number">1990</span>&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，Entry{code}与Entry({code})是相同的，后者以表作为唯一的参数来调用函数Entry。因此，上面这段数据也是一个Lua程序。当需要读取该文件时，我们只需要定义一个合法的Entry，然后运行这个程序即可。例如，以下代码用于计算某个数据文件中数据条目的个数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entry</span><span class="params">()</span></span> count = count + <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;number of entries:&quot;</span> .. count)</span><br></pre></td></tr></table></figure>
<p>下面的程序获取某个数据文件中所有作者的姓名，然后打印出这些姓名：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> authors = &#123;&#125;		<span class="comment">-- 保存作者姓名的集合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entry</span> <span class="params">(b)</span></span> authors[b[<span class="number">1</span>]] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">pairs</span>(authors) <span class="keyword">do</span> <span class="built_in">print</span>(name) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>请注意，上述的代码段中使用了事件驱动的方式：函数Entry作为一个回调函数会在函数dofile处理数据文件中的每个条目时被调用。<br>当文件的大小并不是太大时，可以使用键值对的表示方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Entry&#123;</span><br><span class="line">	author = <span class="string">&quot;Donald E. Knuth&quot;</span>,</span><br><span class="line">	title = <span class="string">&quot;Literate Programming&quot;</span>,</span><br><span class="line">	publisher = <span class="string">&quot;CSLI&quot;</span>,</span><br><span class="line">	year = <span class="number">1992</span></span><br><span class="line">&#125;</span><br><span class="line">Entry&#123;</span><br><span class="line">	author = <span class="string">&quot;Jon Bentley&quot;</span>,</span><br><span class="line">	title = <span class="string">&quot;More Programming Pearls&quot;</span>,</span><br><span class="line">	year = <span class="number">1990</span>,</span><br><span class="line">	pyblisher = <span class="string">&quot;Addison-Wesley&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种格式是所谓的自描述数据格式，其中数据的每个字段都具有一个对应其含义的简略描述。自描述数据比CSV或其他压缩格式的可读性更好；同时，当需要修改时，自描述数据也已于手工编辑；此外，自描述数据还允许我们在不改变数据文件的情况下对基本数据格式进行细微的修改。例如，当我们想要增加一个新字段时，只需要对读取数据文件的程序稍加修改，使其在新字段不存在时使用默认值。<br>此时，字段的次序就无关紧要了。即使有些记录没有作者字段，我们也只需要修改Entry函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entry</span><span class="params">(b)</span></span></span><br><span class="line">	authors[b.author <span class="keyword">or</span> <span class="string">&quot;unknown&quot;</span>] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>我们常常需要将某些数据序列化&#x2F;串行化，即将数据转换为字节流动或字符流，以便将其存储到文件中或者通过网络传输。我们也可以将序列化后的数据表示为Lua代码，当这些代码运行时，被序列化的数据就可以在读取程序中得到重建。<br>通常，如果想要恢复一个全局变量的值，那么可能会使用形如varname &#x3D; exp这样的代码。其中，exp是用于创建这个值的Lua代码，而varname是一个简单的标识符。接下来，让我们学习如何编写创建值的代码。例如，对于一个数值类型而言，可以简单地使用如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">tostring</span>(o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，用十进制格式保存浮点数可能损失精度。此时，可以利用十六进制格式来避免这个问题，使用格式”%a”可以保留被读取浮点型树洞额原始精度。此外，由于从Lua5.3开始就对浮点类型和整数类型进行了区分，因此通过使用正确的子类型就能够恢复它们的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fmt = &#123;integer = <span class="string">&quot;%d&quot;</span>,float = <span class="string">&quot;%a&quot;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt[<span class="built_in">math</span>.<span class="built_in">type</span>(o)],o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br></pre></td></tr></table></figure>
<p>对于字符串类型的值，最简单的序列化方式形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#x27;&quot;</span>,o,<span class="string">&quot;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>不过，字符串包含特殊字符，那么结果就会是错误的。<br>也许有人会告诉读者通过修改引号来解决这个问题：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;[[&quot;</span>,o,<span class="string">&quot;]]&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里，要当心代码诸如！如果某个恶意用户设法使读者的程序保存了形如<code>&quot;]]..os.execute(&#39;rm *&#39;)..[[&quot;</code>这样的内容，那么最终被保存下来的代码将变成：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varname = <span class="string">[[]]</span> .. <span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&#x27;rm *&#x27;</span>)..<span class="string">[[]]</span></span><br></pre></td></tr></table></figure>
<p>一旦这样的“数据”被加载，就会导致意想不到的后果。<br>我么可以使用一种安全的方法来括住一个字符串，那就是使用函数string.format的”%q”选项，该选项被设计为一种能够让Lua语言安全地反序列化字符串的方式来序列化字符串，它使用双引号括住字符串并正确地转义其中的双引号和换行符等其他字符。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;a &quot;problematic&quot; \\ string&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,a))		<span class="comment">--&quot;a \&quot;problematic\&quot; \\ string&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过使用这个特行，函数serialize将变为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	it <span class="built_in">type</span>(o) == <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt[<span class="built_in">math</span>.<span class="built_in">type</span>(o)],o))</span><br><span class="line">	<span class="keyword">elseif</span> <span class="built_in">type</span>(o) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Lua5.3.3对格式选项”%q”进行了扩展，使其也可以用于数值、nil和Boolean类型，进而使它们能够正确地被序列化和反序列化。因此，从Lua5.3.3开始，我们还能够再对函数serialize进行进一步的简化和发展：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">local</span> t = <span class="built_in">type</span>(o)</span><br><span class="line">	<span class="keyword">if</span> t == <span class="string">&quot;number&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;string&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;boolean&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;nil&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>另一种保存字符串的方式是使用主要用于长字符串的<code>[=[...]=]</code>。不过，这种方式主要是为不用改变字符串常量的手写代码提供的。在自动生成的代码中，像函数string.format那样使用”%q”选项来转义有问题的字符更加简单。<br>尽管如此，如果要在自动生成的代码中使用<code>[=[...]=]</code>，那么还必须注意几个细节。首先，我们必须选择恰当数量的等号，这个恰当的数量应比原字符串中出现的最长等号序列的长度大1.由于在字符串中出现长等号序列很常见，因此我们应该把注意力集中在以方括号开头的等号序列上。其次，Lua语言总是会忽略长字符串开头的换行符，要解决这个问题可以通过一种简单方式，即总是在字符串开头多增加一个换行符。</p>
<blockquote>
<p>示例： 引用任意字符串常量</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quote</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="comment">--寻找最长等号序列的长度</span></span><br><span class="line">	<span class="keyword">local</span> n = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;]=*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		n = <span class="built_in">math</span>.<span class="built_in">max</span>(n,#w - <span class="number">1</span>)     <span class="comment">-- -1用于移除&#x27;]&#x27;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 生成一个具有&#x27;n&#x27;+1个等号的字符串</span></span><br><span class="line">	<span class="keyword">local</span> eq = <span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;=&quot;</span>,n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 创建被引起来的字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot; [%s[\n%s]%s &quot;</span> , eq,s,eq)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数可以接收任意一个字符串，并返回按长字符串对其进行格式化后的结果。函数gmatch创建一个遍历字符串s中所有匹配模式’]&#x3D;*’之处的迭代器（即右方括号后跟零个或多个等号）。在每个匹配的地方，循环会用当前所遇到的最大等号数量更新变量n。循环结束后，使用函数string.rep重复等号n+1次，也就是生成一个比原字符串中出现的最长等号序列的长度大1的等号序列。最后，使用函数strig.format将s放入一对具有正确数量等号的括号中，并在字符串s的开头插入一个换行符。</p>
<h3 id="保存不带循环的表"><a href="#保存不带循环的表" class="headerlink" title="保存不带循环的表"></a>保存不带循环的表</h3><p>接下来，更难一点的需求是保存表。保存表有几种方法，选用哪种方法取决于对具体表结构的假设，但没有一种算法使用与所有的情况。对于简单的表来说，不仅可以使用更简单的算法，而且输出也会更简洁和清晰。</p>
<blockquote>
<p>示例：不使用循环序列化表</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">local</span> t = <span class="built_in">type</span>(o)</span><br><span class="line">	<span class="keyword">if</span> t == <span class="string">&quot;number&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;string&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;boolean&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;nil&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,o))</span><br><span class="line">	<span class="keyword">elseif</span> t == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#123;\n&quot;</span>)</span><br><span class="line">			<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(o) <span class="keyword">do</span></span><br><span class="line">				<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&quot;</span>,k,<span class="string">&quot; = &quot;</span>)</span><br><span class="line">				serialize(v)</span><br><span class="line">				<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;,\n&quot;</span>)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#125;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;cannot serialize a &quot;</span> .. <span class="built_in">type</span>(o))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>尽管这个函数很简单，但它却可以合理地满足需求。只要表结构是一棵树，那么该函数甚至能处理嵌套的表。<br>上例中的函数假设了表中的所有键都是合法的标识符，如果一个表的键是数字或者不是合法的Lua标识符，那么就会有问题。解决该问题的一种简单方法是像下列代码一样处理每个键：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot; [%s] = &quot;</span>,serialize(k)))</span><br></pre></td></tr></table></figure>
<p>经过这样的修改后，我们提高了该函数的健壮性，但却牺牲了结果文件的美观性。考虑如下的调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialize&#123;a = <span class="number">12</span>, b = <span class="string">&#x27;Lua&#x27;</span>,key = <span class="string">&#x27;another &quot;one&quot;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>第1版的函数serialize会输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">a = <span class="number">12</span>,</span><br><span class="line">b = <span class="string">&#x27;Lua&#x27;</span></span><br><span class="line">key = <span class="string">&quot;another \&quot;one\&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之对比，第2版的函数serialize则会输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">[<span class="string">&quot;a&quot;</span>] = <span class="number">12</span>,</span><br><span class="line">[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;Lua&quot;</span>,</span><br><span class="line">[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;another \&quot;one\&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过测试每个键是否需要方括号，可以在健壮性和美观性之间得到平衡。</p>
<h3 id="保存带有循环的表"><a href="#保存带有循环的表" class="headerlink" title="保存带有循环的表"></a>保存带有循环的表</h3><p>由于表构造器不能创建带循环的或共享子表的表，所以如果要处理表示通过拓扑结构的表，就需要采用不同的方法。我们需要引入名称来表示循环。因此，下面的函数把值外加其名称一起作为参数。另外，还必须使用一个额外的表来存储已保存表的名称，以便在发现循环时对其进行复用。这个额外的表使用此前已被保存的表作为键，以表的名称作为值。</p>
<blockquote>
<p>示例：保存带有循环的表</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicSerialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="comment">-- 假设&#x27;o&#x27;是一个数字或字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span> (<span class="string">&quot;%q&quot;</span>,o)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save</span> <span class="params">(name,value,saved)</span></span></span><br><span class="line">	saved = saved <span class="keyword">or</span> &#123;&#125;			<span class="comment">-- 初始值</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(name,<span class="string">&quot; = &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">type</span>(value) == <span class="string">&quot;number&quot;</span> <span class="keyword">or</span> <span class="built_in">type</span>(value) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(basicSerialize(value),<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">elseif</span> <span class="built_in">type</span>(value) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">if</span> saved[value] <span class="keyword">then</span>				<span class="comment">-- 值是否被保存？</span></span><br><span class="line">			<span class="built_in">io</span>.<span class="built_in">write</span>(saved[value],<span class="string">&quot;\n&quot;</span>)		<span class="comment">-- 使用之前的名称</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			saved[value] = name		<span class="comment">-- 保存名称供后续使用</span></span><br><span class="line">			<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>)		<span class="comment">-- 创建新表</span></span><br><span class="line">			<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(value) <span class="keyword">do</span> <span class="comment">-- 保存表的字段</span></span><br><span class="line">				k = basicSerialize(k)</span><br><span class="line">				<span class="keyword">local</span> fname = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s[%s]&quot;</span>,name,k)</span><br><span class="line">				save(fname,v,saved)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;cannot save a &quot;</span> .. <span class="built_in">type</span>(value))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们将设要序列化只使用字符串或数值作为键。函数basicSerialize用于对这些基本类型进行序列化并返回序列化后的结果，另一个函数save则完成具体的工作，其参数saved就是之前所说的用于存储已保存表的表。例如，假设要创建一个如下所示的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x = <span class="number">1</span>, y = <span class="number">2</span>;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;</span><br><span class="line">a[<span class="number">2</span>] = a <span class="comment">-- 循环</span></span><br><span class="line">a.z = a[<span class="number">1</span>]	<span class="comment">-- 共享子表</span></span><br></pre></td></tr></table></figure>
<p>调用save(“a”,a)会将其保存为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="number">1</span>] = &#123;&#125;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>] = a</span><br><span class="line">a[<span class="string">&quot;y&quot;</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="string">&quot;x&quot;</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="string">&quot;z&quot;</span>] = a[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>取决于表的遍历情况，这些赋值语句的实际执行顺序可能会有所不同。不过尽管如此，上述算法能够保证任何新定义节点中所用到节点都是已经被定义过的。<br>如果想保存具有共享部分的几个表，那么可以在调用函数save时使用相同的表saved函数，例如，假设有如下两个表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>&#125;,<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;k = a[<span class="number">1</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>如果以独立的方式保存这些表，那么结果中不会有共同的部分。不过，如果调用save函数时使用同一个表saved，那么结果就会共享共同的部分：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">save(<span class="string">&quot;a&quot;</span>,a,t)</span><br><span class="line">save(<span class="string">&quot;b&quot;</span>,b,t)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- a = &#123;&#125;</span></span><br><span class="line"><span class="comment">-- a[1] = &#123;&#125;</span></span><br><span class="line"><span class="comment">-- a[1][1] = &quot;one&quot;</span></span><br><span class="line"><span class="comment">-- a[1][2] = &quot;two&quot;</span></span><br><span class="line"><span class="comment">-- a[2] = 3</span></span><br><span class="line"><span class="comment">-- b = &#123;&#125;</span></span><br><span class="line"><span class="comment">-- b[&quot;k&quot;] = a[1]</span></span><br></pre></td></tr></table></figure>
<p>在Lua语言中，还有其他一些比较常见的方法。例如，我们可以保存一个值时不指定全局名称而是通过一段代码来创建一个局部值并将其返回，也可以在可能的时候使用列表的语法等等。Lua预压给我们提供了构建这些机制的工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Lua数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 18:44:36" itemprop="dateCreated datePublished" datetime="2020-04-18T18:44:36+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言中的表并不是一种数据结构，它们是其他数据结构的基础。我们可以用Lua语言中的表来实现其他语言提供的数据结构，如数组、记录、列表、队列、集合等。而且，用Lua语言中的表实现这些数据结构还很高效。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>在像C和Pascal这样更加传统的语言中，通常使用数组和列表来实现大多数数据结构。虽然在Lua语言中也可以使用表来实现数组和列表，但表实际上比数组和列表强大很多。使用表时，很多算法可以被简化。例如，由于表本身就支持任意数据类型的直接访问，因此我们很少在Lua语言中编写搜索算法。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在Lua语言中，简单地使用整数来索引表即可实现数组。因此，数组的大小不用非得是固定的，而是可以按需增长的。通常，在初始化数组时就间接地定义了数组的大小。例如，在执行了以下的代码后，任何访问范围1~1000之外的元素都会返回nil而不是0：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">1000</span> <span class="keyword">do</span> </span><br><span class="line">	a[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>长度运算符（#）正是基于此来计算数组大小的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#a)</span><br></pre></td></tr></table></figure>
<p>可以使用0、1或其他任何值来作为数组的起始索引：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-5</span> , <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">	a[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，在Lua语言中一般以1作为数组的起始索引，Lua语言的标准库和长度运算符都遵循这个惯例。如果数组的索引不从1开始，那就不能使用这些机制。<br>可以通过表构造器在一句表达式中同时创建和初始化数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这种表构造器根据需求要多大就能多大。在Lua语言中，利用数据描述文件创建包含几百万个元素组成的构造器很常见。</p>
<h2 id="矩阵及多维数组"><a href="#矩阵及多维数组" class="headerlink" title="矩阵及多维数组"></a>矩阵及多维数组</h2><p>在Lua语言中，有两种方式来表示矩阵。第一种方式就是使用一个不规则数组，即数组的数组，也就是一个所有元素均是另一个表的表。例如，可以使用如下代码来创建一个全0元素的N*M维矩阵：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> , N <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> row = &#123;&#125;</span><br><span class="line">	mt[i] = row</span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">		row[j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于表在Lua语言中是一种对象，因此在创建矩阵时必须显示地创建每一行。一方面，这比在C语言中直接声明一个多维数组更加具体；另一方面，这也给我们提供了很多的灵活性。例如，只需将前例中的内层循环改为for j &#x3D; 1,i do … end就可以创建一个三角矩阵。使用这套代码，三角矩阵较原来的矩阵可以节约一半的内存。<br>在Lua中表示矩阵的第二种方式是将两个索引合并为一个。典型情况下，我们通过将第一个索引乘以一个合适的常量再加上第二个索引来实现这种效果。在这种方式下，我们可以使用以下的代码来创建一个全0元素的N*M维矩阵：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> aux = (i <span class="number">-1</span>) * M </span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">		mt[aux = j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>应用程序中经常会用到稀疏矩阵，这种矩阵中的大多数元素是0或nil。例如，我们可以使用邻接矩阵来表示图。当矩阵出元素的值为x时，表示图中的节点m和n是相连的，连接的权重为x；若上述的两个节点不相连，那么矩阵的 (m,n)处元素的值为nil。如果要表示一个具有1万个节点的图，那么需要一个包含1亿个元素的矩阵，但是其中大约只有5万个元素不为nil。许多有关数据结构的书籍都会深入地讨论如何实现这种稀疏矩阵而不必浪费800MB内存空间，但在Lua语言中却很少需要用到那些技巧。这是因为，我们使用表实现数组而表本来就是稀疏的。在第一种实现中，需要1万个表，每个表5个元素，总共5万个元素。在第二种实现中，只需要一个表，其中包含5万个元素。无论哪种实现，都是只非nil的元素才占用空间。<br>由于在有效元素之间存在空间，因此不能对稀疏举着使用长度运算符。这没什么大不了的，即使我们能够使用长度运算符，最好也不要那么做。对于大多数针对稀疏矩阵的操作来说，遍历空元素是非常低效的。相反，可以使用pairs来只遍历非nil的元素。例如，考虑如何进行由不规则数组表示的稀疏矩阵的矩阵乘法。<br>假设矩阵a[M,K]乘以矩阵b[K,N]的结果为矩阵c[M,N]，常见的矩阵相乘算法形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">		c[i][j] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> k = <span class="number">1</span>,K <span class="keyword">do</span></span><br><span class="line">			c[i][j] = c[i][j] + a[i][k] * b[k][j]</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>外层的两个循环遍历了整个结果矩阵，然后使用内层循环计算每一个元素的值。<br>对于使用不规则矩阵实现的稀疏矩阵，内层循环会有问题。由于内层循环遍历的是一列b而不是一行，因此不能再此处使用pairs：这个循环必须遍历每一行来检查对应的行是否在对应列中有元素。除了遍历了少量非0元素以外，这个循环还遍历了所有的0元素。（由于不知道元素的空间位置，所以在其他场景下遍历一列可也能会有问题。）<br>以下的算法与之前的示例非常类似，但是该算法调换了两个内层循环的顺序。通过这个简单的调整，该算法避免了遍历列：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span> , K <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">			c[i][j] = c[i][j] + a[i][k] * b [k][j]</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，中间的一层循环遍历行a[i]，而内层循环遍历行b[k]。这两个遍历都可以使用pairs来实现遍历非0元素。由于一个空的稀疏矩阵本身就是使用0填充的，所以对结果矩阵c的初始化没有任何问题。<br>下面代码战士了上述算法的完整实现，其中使用了pairs来处理稀疏矩阵的元素。这种实现只访问非nil元素，同时结果也是稀疏矩阵。此外，下面的代码还删去了结果中偶然为0的元素。</p>
<blockquote>
<p>稀疏矩阵相乘</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mult</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> c = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> resultline = &#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> k ,va <span class="keyword">in</span> <span class="built_in">pairs</span>(a[i]) <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j , vb <span class="keyword">in</span> <span class="built_in">pairs</span>(b[k]) <span class="keyword">do</span></span><br><span class="line">				<span class="keyword">local</span> res = (resultline[j] <span class="keyword">or</span> <span class="number">0</span> ) + va * vb</span><br><span class="line">				resultline[j] = (res ~= <span class="number">0</span>) <span class="keyword">and</span> res  <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		c[i] = resultline</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>由于表是动态对象，所以在Lua语言中可以很容易地实现链表。我们可以把每个节点用一个表来表示，链接则为一个包含指向其他表的引用的简单表字段。例如，让我们实现一个单链表，其中每个节点具有两个字段value和next。最简单的变量就是根节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>要在表头插入一个值为v的元素，可以使用如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = &#123;<span class="built_in">next</span> = list, value = v&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过如下的方式遍历链表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> l = list</span><br><span class="line"><span class="keyword">while</span> l <span class="keyword">do</span></span><br><span class="line">	visit l.value</span><br><span class="line">	l = l.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>诸如双向链表或环形表等其他类型的链表也很容易实现。不过，由于通常无须链表即可用更简单的方式来表示数据，所以在Lua语言中很少需要用到这些数据结构。例如，我们可以通过一个无界数组来表示栈。</p>
<h2 id="队列及双端队列"><a href="#队列及双端队列" class="headerlink" title="队列及双端队列"></a>队列及双端队列</h2><p>在Lua语言中实现队列的一种简单方法是使用table标准库中的函数insert和remove。</p>
<blockquote>
<p>示例： 一个双端队列</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listNew</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> &#123;first = <span class="number">0</span> ,last = <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushFisrt</span><span class="params">(list,value)</span></span></span><br><span class="line">	<span class="keyword">local</span> first = list.first - <span class="number">1</span></span><br><span class="line">	list.first = first</span><br><span class="line">	list[first] = value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushLast</span> <span class="params">(list ,value)</span></span></span><br><span class="line">	<span class="keyword">local</span> last = list.last + <span class="number">1</span></span><br><span class="line">	list.last = last</span><br><span class="line">	list[last] = value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popFirst</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">local</span> first = list.first</span><br><span class="line">	<span class="keyword">if</span> first &gt; list.last <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;list is empty&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> value = list[first]</span><br><span class="line">	list[first] = <span class="literal">nil</span></span><br><span class="line">	list.first = first + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popLast</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">local</span> last = list.last</span><br><span class="line">	<span class="keyword">if</span> list.first &gt; last <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;list is empty&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> value = list[last]</span><br><span class="line">	list[last] = <span class="literal">nil</span></span><br><span class="line">	list.last = last  - <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果希望严格地遵循队列的规范使用这个结构，那么就只能调用pushLast和popFirst函数，first和last都会不断增长。不过，由于我们在Lua语言中使用表来表示数组，所以我们既可以在1-20的范围内对数组进行索引，也可以在16777201-16777220的范围内索引数组。对于一个64为整型数而言，以每秒1000万次的速度进行插入也需要运行3万年才会发生溢出的问题。</p>
<h2 id="反向表"><a href="#反向表" class="headerlink" title="反向表"></a>反向表</h2><p>我们很少在Lua语言中进行索引操作。但是，我们使用被称为索引表或反向表的数据结构。<br>假设有一个存放了一周每一天名称的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要将一周每一天的名称转换为其在一周里的位置，那么可以通过索引这表来寻找指定的名称。不过，一种更高效的方式是构造一个方向表，假定为revDays，该表中的索引为一周每一天的名称而值为其在一周里的位置。这个表形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revDays = &#123;[<span class="string">&quot;Sunday&quot;</span>] = <span class="number">1</span> ,[<span class="string">&quot;Monday&quot;</span>] = <span class="number">2</span>,[<span class="string">&quot;Tuesday&quot;</span>] = <span class="number">3</span>,[<span class="string">&quot;Wednesday&quot;</span>] = <span class="number">4</span>,[<span class="string">&quot;Thursday&quot;</span>] = <span class="number">5</span>,[<span class="string">&quot;Friday&quot;</span>] = <span class="number">6</span>,[<span class="string">&quot;Saturday&quot;</span>] = <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后，只需要直接在反向表中根据名称进行索引就可以了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;Tuesday&quot;</span></span><br><span class="line"><span class="built_in">print</span>(revDays[x])				<span class="comment">-- 3</span></span><br></pre></td></tr></table></figure>
<p>当然，这个反向表不同手工声明，可以从原始的表中自动地构造出方向标：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">revDays = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(days) <span class="keyword">do</span> </span><br><span class="line">	revDays[v] = k</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上例中的循环会对每个元素days进行赋值，变量k获取到的是键(1,2,…)而变量v获取到的是值(“Sunday”,”Monday”,…)。</p>
<h2 id="集合与包"><a href="#集合与包" class="headerlink" title="集合与包"></a>集合与包</h2><p> 假设我们想列出一个程序源代码中的所有标识符，同时过滤掉其中的保留字。一些C程序员可能倾向于使用字符串数组来表示保留字集合，然后搜索这个数组来决定某个单词是否属于该集合。为了提高搜索的速度，他们还可能使用二叉树来表示该集合。<br>在Lua语言中，还可以用一中高效且简单的方式来表示这类集合，即集合元素作为索引放入表中。那么，对于指定的元素无须再搜索表，只需要该元素检索表并检查结果是否为nil即可。以上述需求为例，代码形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reserved = &#123;[<span class="string">&quot;while&quot;</span>] = <span class="literal">true</span>, [<span class="string">&quot;if&quot;</span>] = <span class="literal">true</span>,[<span class="string">&quot;else&quot;</span>] = <span class="literal">true</span>,[<span class="string">&quot;do&quot;</span>] =<span class="literal">true</span>,&#125;</span><br><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;[%a_][%w_]*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> reserved[w] <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">do</span> something with <span class="string">&#x27;w&#x27;</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们可以借助一个辅助函数来构造集合，使得初始化过程更清晰：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, l <span class="keyword">in</span> <span class="built_in">ipairs</span>(list) <span class="keyword">do</span></span><br><span class="line">		set[l] = <span class="literal">true</span> </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">reserved = Set&#123;<span class="string">&quot;while&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;function&quot;</span>,<span class="string">&quot;local&quot;</span>,&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用另一个集合来保存标识符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ids = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;[%a_][%w_]*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> reserved[w] <span class="keyword">then</span></span><br><span class="line">		ids[w] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 输出每一个标识符</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">pairs</span>(ids) <span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">print</span>(w)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>包(bag)，也被称为多重集合，与普通集合的不同之处在于其中的元素可以出现多次。在Lua语言中，包的简单表示类似于此前集合的表示，只不过其中的每一个键都有一个对应的计数器。如果要插入一个元素，可以递增其计数器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> <span class="params">(bag,element)</span></span></span><br><span class="line">	bag[element] = (bag[element] <span class="keyword">or</span> <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果要删除一个元素，可以递减其计数器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> <span class="params">(bag,element)</span></span></span><br><span class="line">	<span class="keyword">local</span> count = bag[element]</span><br><span class="line">	bag[element] = (count <span class="keyword">and</span> count &gt; <span class="number">1</span>) <span class="keyword">and</span> count - <span class="number">1</span> <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>只有当计数器存在且大于0时我们才会保留计数器。</p>
<h2 id="字符串缓冲区"><a href="#字符串缓冲区" class="headerlink" title="字符串缓冲区"></a>字符串缓冲区</h2><p>假设我们正在开发一段处理字符串的程序，比如逐行地读取一个文件。典型的代码可能形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> buff = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	buff = buff .. line .. <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>虽然这段Lua语言代码看似能够正常工作，但实际上在处理大文件时却可能导致巨大的性能开销。<br>这是为什么呢？为了搞清楚到底发生了什么，让我们想象一下读取循环中发生了什么。假设每行有20字节，当我们读取了大概2500行后，buff就会变成一个50KB大小的字符串。在Lua语言中进行字符串连接<code>buff..line..&quot;\n&quot;</code>时，会创建一个50020字节的新字符串，然后从buff中复制50000字节中到这个新字符串中。这样，对于后续的每一行，Lua语言都需要移动大概50KB且还在不断增长的内存。因此，该算法的时间复杂度是二次方的。在读取了100行以后，Lua语言就已经移动了至少5MB内存。当Lua语言完成了350KB的读取后，它已经至少移动了50GB的数据。<br>对于较小的字符串，上述循环并没什么问题。当读取整个文件时，Lua语言提供了带有参数的函数io.read(“a”)来一次性读取整个文件。不过，有时候我们必须面对这个问题。Java提供了StringBuffer类还解决这个问题；而在Lua语言中，我们可以把一个表当做字符串缓冲区，其关键是使用函数table.concat，这个函数会将指定列表中的所有字符串连接起来并返回连接后的结果。使用函数concat可以这样重写上述循环：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	t[#t + <span class="number">1</span>] = line .. <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t)</span><br></pre></td></tr></table></figure>
<p>之前的代码读取同样的文件需要超过半分钟，而上述实现则只需要不到0.05秒。我们还可以做得更好。函数concat还有第2个可选参数，用于指定插在字符串间的分隔符。有了这个分隔符，我们就不必在每行后插入换行符了。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	t[#t + <span class="number">1</span>] = line</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t,<span class="string">&quot;\n&quot;</span>) .. <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然函数concat能够在字符串之间插入分隔符，但我们还需要增阿基最后一个换行符。最后一次字符串连接创建了结果字符串的一个副本，这个副本可能已经相当长了。虽然没有直接的选项能够让函数concat插入这个额外的分隔符，但我们可以想办法绕过，只需在字符串t后面添加一个空字符串就行了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[#t + <span class="number">1</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t,<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>现在，正如我们所期望的那样，函数concat会在结果字符串的额最后添加一个换行符。</p>
<h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><p>像其他现代编程语言一眼个，Lua语言也允许开发人员使用多种实现表示图，每种实现都有其所使用的特定算法。<br>我们使用一个由两个字段组成的表来表示每个节点，即name(节点名称)和adj(与此节点邻接的节点和集合)。由于我们会从一个文本文件中加载图对应的数据，所以需要能够根据节点的名称来寻找指定节点的方法。因此，我们使用了一个额外的表来建立节点和节点名称之间的映射。函数name2node可以根据指定节点的名称返回对应的节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">name2node</span><span class="params">(graph,name)</span></span></span><br><span class="line">	<span class="keyword">local</span> node = graph[name]</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">		node = &#123;name = name ,adj = &#123;&#125;&#125;</span><br><span class="line">		graph[name] = node </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> node </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例：从文件中加载图</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readgraph</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> graph = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">		<span class="comment">-- 把一行分割为两个名字</span></span><br><span class="line">		<span class="keyword">local</span> namefrom, nameto = <span class="built_in">string</span>.<span class="built_in">match</span>(line,<span class="string">&quot;(%S+)%s+(%S+)&quot;</span>)</span><br><span class="line">		<span class="comment">-- 找到对应的节点</span></span><br><span class="line">		<span class="keyword">local</span> from = name2node(graph,namefrom)</span><br><span class="line">		<span class="keyword">local</span> to = name2node(graph,nameto)</span><br><span class="line">		<span class="comment">-- 把‘to’增加到邻接集合&#x27;from&#x27;中</span></span><br><span class="line">		from.adj[to] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> graph</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数逐行地读取一个文件，文件的每一行中有两个节点的名称，表示从第1个节点到第2个节点有一条边。对于每一行，调用函数string.match将一行中的两个节点的名称分开，然后根据名称找到对应的节点，最后将这些节点连接在一起。</p>
<blockquote>
<p>示例：寻找两个节点之间的路径</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findpath</span><span class="params">(curr,to,path,visited)</span></span></span><br><span class="line">	<span class="built_in">path</span> = <span class="built_in">path</span> <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	visited = visited <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> visited[curr] <span class="keyword">then</span>   <span class="comment">-- 是否节点已被访问</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>			<span class="comment">-- 不存在路径</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	visited[curr] = <span class="literal">true</span>    <span class="comment">-- 标记节点为已被访问</span></span><br><span class="line">	<span class="built_in">path</span>[#<span class="built_in">path</span> + <span class="number">1</span>] = curr	<span class="comment">-- 增加到路径中</span></span><br><span class="line">	<span class="keyword">if</span> curr == to <span class="keyword">then</span>		<span class="comment">-- 是否是最后一个节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">path</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">pairs</span>(curr.adj) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> p = findpath(node,to ,<span class="built_in">path</span>,visited)</span><br><span class="line">		<span class="keyword">if</span> p <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">return</span> p</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">path</span>)		<span class="comment">-- 从路径中删除节点</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>函数findpath使用深度优先遍历搜索两个节点之间的路径。该函数的第1个参数是当前节点，第2个参数是目标节点，第3个参数用于保存从起点到当前节点的路径，最后一个参数为所有已被访问节点的几何。<br>为了测试上述代码，我们编写一个打印一条路径的函数，再编写一些代码让上述所有代码跑起来：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printpath</span><span class="params">(path)</span></span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">path</span> <span class="keyword">do</span> </span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">path</span>[i].name)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">g = readgraph()</span><br><span class="line">a = name2node(g,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">b = name2node(g,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">p = findpath(a,b)</span><br><span class="line"><span class="keyword">if</span> p <span class="keyword">then</span> printpath(p) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="南锋"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">南锋</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">174</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com/" title="http:&#x2F;&#x2F;yoursite.com" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南锋</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
