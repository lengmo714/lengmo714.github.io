<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="南锋">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/20/Lua%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/Lua%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">Lua编译执行和错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-20 17:26:38" itemprop="dateCreated datePublished" datetime="2020-04-20T17:26:38+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虽然我们把Lua语言成为解释型语言，但Lua语言总是在运行代码前先预编译源码为中间代码（这没什么大不了的，很多解释型语言也这样做）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/20/Lua%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/20/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">用树莓派搭建虚拟专用网络服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-20 14:07:31" itemprop="dateCreated datePublished" datetime="2020-04-20T14:07:31+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 18:38:11" itemprop="dateModified" datetime="2024-05-14T18:38:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/" itemprop="url" rel="index"><span itemprop="name">树莓派</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">服务器搭建</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">虚拟专用网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文详细介绍了如何使用树莓派在Ubuntu系统上搭建虚拟专用网络服务器，包括安装pptp、配置内网IP策略、配置DNS、设置TCP/IP数据转发、开放网络端口等步骤。通过这个方法，你可以在树莓派上轻松搭建自己的VPN服务器。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/20/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">Lua数据文件和序列化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 23:56:16" itemprop="dateCreated datePublished" datetime="2020-04-18T23:56:16+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在处理数据文件时，写数据通常比读数据简单很多。当向一个文件中写时，我们拥有绝对的控制权；但是，当从一个文件中读时，我们并不知道会读什么东西。一个健壮的程序除了能够处理一个合法文件中所包含的所有类型的数据外，还应该能够优雅地处理错误的文件。因此，编写一个健壮的处理输入的程序总是比较困难的。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>Lua语言自1993年发布以来，其主要用途之一就是描述数据。在那个年代，主要的文本数据描述语言之一是SGML。对于很多人来说，SGML既臃肿又复杂。在1998年，有些人将其简化成XML，但以我们的眼光看仍然臃肿又复杂。有些人跟我们的观点一直，进而在2001年开发了JSON。JSON基于JavaScript，类似于一种精简过的Lua语言数据文件。一方面，JSON的一大优势在于它是国际标准，包括Lua语言在内的多种语言都具有操作JSON文件的标准库。另一方面，Lua语言数据文件的读取更加容易和灵活。<br>使用一门全功能的编程语言来描述数据确实非常灵活，但也会带来两个问题。问题之一在于安全性，这是因为“数据”文件能够肆意地在我们的程序中运行。我们可以通过沙盒中运行程序来解决这个问题。<br>另一个问题是性能问题。Lua语言不仅运行得快，编译也很快。例如，在笔者的新机器上，Lua5.3可以在4秒以内，占用240MB内存，完成1000万条赋值语句的读取、编译和运行。作为对比，Perl5.18需要21秒、占用6GB内存，Python2.7和Python3.4直接崩溃，Node.js0.10.25在运行8秒后抛出“内存溢出”异常，Rhino1.7在运行6分钟后也抛出了“内存溢出”异常。</p>
<h2 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h2><p>对于文件格式来说，表构造器提供了一种有趣的替代方法。只需在写入数据时做一点额外的工作，就能使得读数据变得容易。这种技巧就是将数据文件写成Lua代码，当这些代码运行时，程序也就把数据重建了。使用表构造器时，这些代码段看上去会非常像是一个普通的数据文件。<br>下面通过一个示例来进一步展示处理数据文件的方式。如果数据文件使用的是诸如CSV或XML等预先定义好的格式，那么我们能够选择的方法不多。不过，如果处理的是处于自身需求而创建的数据文件，那么就可以将Lua语言的构造器用于格式定义。此时，我们把每条数据记录表示为一个Lua构造器。这样，原来类似</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Donald E. Knuth,Literate Programming,CSLI,<span class="number">1992</span></span><br><span class="line">Jon Bentley,More Programming Pearls, Addison-Wesley,<span class="number">1990</span></span><br></pre></td></tr></table></figure>
<p>的数据文件就可以改为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry&#123;<span class="string">&quot;Donald E. Knuth&quot;</span>,<span class="string">&quot;Literate Programming&quot;</span>,<span class="string">&quot;CSLI&quot;</span>,<span class="number">1992</span>&#125;</span><br><span class="line">Entry&#123;<span class="string">&quot;Jon Bentley&quot;</span>,<span class="string">&quot;More Programming Pearls&quot;</span>,<span class="string">&quot;Addison-Wesley&quot;</span>,<span class="number">1990</span>&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，Entry{code}与Entry({code})是相同的，后者以表作为唯一的参数来调用函数Entry。因此，上面这段数据也是一个Lua程序。当需要读取该文件时，我们只需要定义一个合法的Entry，然后运行这个程序即可。例如，以下代码用于计算某个数据文件中数据条目的个数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entry</span><span class="params">()</span></span> count = count + <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;number of entries:&quot;</span> .. count)</span><br></pre></td></tr></table></figure>
<p>下面的程序获取某个数据文件中所有作者的姓名，然后打印出这些姓名：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> authors = &#123;&#125;		<span class="comment">-- 保存作者姓名的集合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entry</span> <span class="params">(b)</span></span> authors[b[<span class="number">1</span>]] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">pairs</span>(authors) <span class="keyword">do</span> <span class="built_in">print</span>(name) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>请注意，上述的代码段中使用了事件驱动的方式：函数Entry作为一个回调函数会在函数dofile处理数据文件中的每个条目时被调用。<br>当文件的大小并不是太大时，可以使用键值对的表示方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Entry&#123;</span><br><span class="line">	author = <span class="string">&quot;Donald E. Knuth&quot;</span>,</span><br><span class="line">	title = <span class="string">&quot;Literate Programming&quot;</span>,</span><br><span class="line">	publisher = <span class="string">&quot;CSLI&quot;</span>,</span><br><span class="line">	year = <span class="number">1992</span></span><br><span class="line">&#125;</span><br><span class="line">Entry&#123;</span><br><span class="line">	author = <span class="string">&quot;Jon Bentley&quot;</span>,</span><br><span class="line">	title = <span class="string">&quot;More Programming Pearls&quot;</span>,</span><br><span class="line">	year = <span class="number">1990</span>,</span><br><span class="line">	pyblisher = <span class="string">&quot;Addison-Wesley&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种格式是所谓的自描述数据格式，其中数据的每个字段都具有一个对应其含义的简略描述。自描述数据比CSV或其他压缩格式的可读性更好；同时，当需要修改时，自描述数据也已于手工编辑；此外，自描述数据还允许我们在不改变数据文件的情况下对基本数据格式进行细微的修改。例如，当我们想要增加一个新字段时，只需要对读取数据文件的程序稍加修改，使其在新字段不存在时使用默认值。<br>此时，字段的次序就无关紧要了。即使有些记录没有作者字段，我们也只需要修改Entry函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Entry</span><span class="params">(b)</span></span></span><br><span class="line">	authors[b.author <span class="keyword">or</span> <span class="string">&quot;unknown&quot;</span>] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>我们常常需要将某些数据序列化&#x2F;串行化，即将数据转换为字节流动或字符流，以便将其存储到文件中或者通过网络传输。我们也可以将序列化后的数据表示为Lua代码，当这些代码运行时，被序列化的数据就可以在读取程序中得到重建。<br>通常，如果想要恢复一个全局变量的值，那么可能会使用形如varname &#x3D; exp这样的代码。其中，exp是用于创建这个值的Lua代码，而varname是一个简单的标识符。接下来，让我们学习如何编写创建值的代码。例如，对于一个数值类型而言，可以简单地使用如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">tostring</span>(o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，用十进制格式保存浮点数可能损失精度。此时，可以利用十六进制格式来避免这个问题，使用格式”%a”可以保留被读取浮点型树洞额原始精度。此外，由于从Lua5.3开始就对浮点类型和整数类型进行了区分，因此通过使用正确的子类型就能够恢复它们的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fmt = &#123;integer = <span class="string">&quot;%d&quot;</span>,float = <span class="string">&quot;%a&quot;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt[<span class="built_in">math</span>.<span class="built_in">type</span>(o)],o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br></pre></td></tr></table></figure>
<p>对于字符串类型的值，最简单的序列化方式形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#x27;&quot;</span>,o,<span class="string">&quot;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>不过，字符串包含特殊字符，那么结果就会是错误的。<br>也许有人会告诉读者通过修改引号来解决这个问题：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(o) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;[[&quot;</span>,o,<span class="string">&quot;]]&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里，要当心代码诸如！如果某个恶意用户设法使读者的程序保存了形如<code>&quot;]]..os.execute(&#39;rm *&#39;)..[[&quot;</code>这样的内容，那么最终被保存下来的代码将变成：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varname = <span class="string">[[]]</span> .. <span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&#x27;rm *&#x27;</span>)..<span class="string">[[]]</span></span><br></pre></td></tr></table></figure>
<p>一旦这样的“数据”被加载，就会导致意想不到的后果。<br>我么可以使用一种安全的方法来括住一个字符串，那就是使用函数string.format的”%q”选项，该选项被设计为一种能够让Lua语言安全地反序列化字符串的方式来序列化字符串，它使用双引号括住字符串并正确地转义其中的双引号和换行符等其他字符。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;a &quot;problematic&quot; \\ string&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,a))		<span class="comment">--&quot;a \&quot;problematic\&quot; \\ string&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过使用这个特行，函数serialize将变为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	it <span class="built_in">type</span>(o) == <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt[<span class="built_in">math</span>.<span class="built_in">type</span>(o)],o))</span><br><span class="line">	<span class="keyword">elseif</span> <span class="built_in">type</span>(o) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Lua5.3.3对格式选项”%q”进行了扩展，使其也可以用于数值、nil和Boolean类型，进而使它们能够正确地被序列化和反序列化。因此，从Lua5.3.3开始，我们还能够再对函数serialize进行进一步的简化和发展：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">local</span> t = <span class="built_in">type</span>(o)</span><br><span class="line">	<span class="keyword">if</span> t == <span class="string">&quot;number&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;string&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;boolean&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;nil&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,o))</span><br><span class="line">	<span class="keyword">else</span> other cases</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>另一种保存字符串的方式是使用主要用于长字符串的<code>[=[...]=]</code>。不过，这种方式主要是为不用改变字符串常量的手写代码提供的。在自动生成的代码中，像函数string.format那样使用”%q”选项来转义有问题的字符更加简单。<br>尽管如此，如果要在自动生成的代码中使用<code>[=[...]=]</code>，那么还必须注意几个细节。首先，我们必须选择恰当数量的等号，这个恰当的数量应比原字符串中出现的最长等号序列的长度大1.由于在字符串中出现长等号序列很常见，因此我们应该把注意力集中在以方括号开头的等号序列上。其次，Lua语言总是会忽略长字符串开头的换行符，要解决这个问题可以通过一种简单方式，即总是在字符串开头多增加一个换行符。</p>
<blockquote>
<p>示例： 引用任意字符串常量</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quote</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="comment">--寻找最长等号序列的长度</span></span><br><span class="line">	<span class="keyword">local</span> n = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;]=*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		n = <span class="built_in">math</span>.<span class="built_in">max</span>(n,#w - <span class="number">1</span>)     <span class="comment">-- -1用于移除&#x27;]&#x27;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 生成一个具有&#x27;n&#x27;+1个等号的字符串</span></span><br><span class="line">	<span class="keyword">local</span> eq = <span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;=&quot;</span>,n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 创建被引起来的字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot; [%s[\n%s]%s &quot;</span> , eq,s,eq)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数可以接收任意一个字符串，并返回按长字符串对其进行格式化后的结果。函数gmatch创建一个遍历字符串s中所有匹配模式’]&#x3D;*’之处的迭代器（即右方括号后跟零个或多个等号）。在每个匹配的地方，循环会用当前所遇到的最大等号数量更新变量n。循环结束后，使用函数string.rep重复等号n+1次，也就是生成一个比原字符串中出现的最长等号序列的长度大1的等号序列。最后，使用函数strig.format将s放入一对具有正确数量等号的括号中，并在字符串s的开头插入一个换行符。</p>
<h3 id="保存不带循环的表"><a href="#保存不带循环的表" class="headerlink" title="保存不带循环的表"></a>保存不带循环的表</h3><p>接下来，更难一点的需求是保存表。保存表有几种方法，选用哪种方法取决于对具体表结构的假设，但没有一种算法使用与所有的情况。对于简单的表来说，不仅可以使用更简单的算法，而且输出也会更简洁和清晰。</p>
<blockquote>
<p>示例：不使用循环序列化表</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="keyword">local</span> t = <span class="built_in">type</span>(o)</span><br><span class="line">	<span class="keyword">if</span> t == <span class="string">&quot;number&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;string&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;boolean&quot;</span> <span class="keyword">or</span> t == <span class="string">&quot;nil&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,o))</span><br><span class="line">	<span class="keyword">elseif</span> t == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#123;\n&quot;</span>)</span><br><span class="line">			<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(o) <span class="keyword">do</span></span><br><span class="line">				<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&quot;</span>,k,<span class="string">&quot; = &quot;</span>)</span><br><span class="line">				serialize(v)</span><br><span class="line">				<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;,\n&quot;</span>)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#125;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;cannot serialize a &quot;</span> .. <span class="built_in">type</span>(o))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>尽管这个函数很简单，但它却可以合理地满足需求。只要表结构是一棵树，那么该函数甚至能处理嵌套的表。<br>上例中的函数假设了表中的所有键都是合法的标识符，如果一个表的键是数字或者不是合法的Lua标识符，那么就会有问题。解决该问题的一种简单方法是像下列代码一样处理每个键：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot; [%s] = &quot;</span>,serialize(k)))</span><br></pre></td></tr></table></figure>
<p>经过这样的修改后，我们提高了该函数的健壮性，但却牺牲了结果文件的美观性。考虑如下的调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialize&#123;a = <span class="number">12</span>, b = <span class="string">&#x27;Lua&#x27;</span>,key = <span class="string">&#x27;another &quot;one&quot;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>第1版的函数serialize会输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">a = <span class="number">12</span>,</span><br><span class="line">b = <span class="string">&#x27;Lua&#x27;</span></span><br><span class="line">key = <span class="string">&quot;another \&quot;one\&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之对比，第2版的函数serialize则会输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">[<span class="string">&quot;a&quot;</span>] = <span class="number">12</span>,</span><br><span class="line">[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;Lua&quot;</span>,</span><br><span class="line">[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;another \&quot;one\&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过测试每个键是否需要方括号，可以在健壮性和美观性之间得到平衡。</p>
<h3 id="保存带有循环的表"><a href="#保存带有循环的表" class="headerlink" title="保存带有循环的表"></a>保存带有循环的表</h3><p>由于表构造器不能创建带循环的或共享子表的表，所以如果要处理表示通过拓扑结构的表，就需要采用不同的方法。我们需要引入名称来表示循环。因此，下面的函数把值外加其名称一起作为参数。另外，还必须使用一个额外的表来存储已保存表的名称，以便在发现循环时对其进行复用。这个额外的表使用此前已被保存的表作为键，以表的名称作为值。</p>
<blockquote>
<p>示例：保存带有循环的表</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicSerialize</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="comment">-- 假设&#x27;o&#x27;是一个数字或字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span> (<span class="string">&quot;%q&quot;</span>,o)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save</span> <span class="params">(name,value,saved)</span></span></span><br><span class="line">	saved = saved <span class="keyword">or</span> &#123;&#125;			<span class="comment">-- 初始值</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(name,<span class="string">&quot; = &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">type</span>(value) == <span class="string">&quot;number&quot;</span> <span class="keyword">or</span> <span class="built_in">type</span>(value) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(basicSerialize(value),<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">elseif</span> <span class="built_in">type</span>(value) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">if</span> saved[value] <span class="keyword">then</span>				<span class="comment">-- 值是否被保存？</span></span><br><span class="line">			<span class="built_in">io</span>.<span class="built_in">write</span>(saved[value],<span class="string">&quot;\n&quot;</span>)		<span class="comment">-- 使用之前的名称</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			saved[value] = name		<span class="comment">-- 保存名称供后续使用</span></span><br><span class="line">			<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>)		<span class="comment">-- 创建新表</span></span><br><span class="line">			<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(value) <span class="keyword">do</span> <span class="comment">-- 保存表的字段</span></span><br><span class="line">				k = basicSerialize(k)</span><br><span class="line">				<span class="keyword">local</span> fname = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s[%s]&quot;</span>,name,k)</span><br><span class="line">				save(fname,v,saved)</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;cannot save a &quot;</span> .. <span class="built_in">type</span>(value))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们将设要序列化只使用字符串或数值作为键。函数basicSerialize用于对这些基本类型进行序列化并返回序列化后的结果，另一个函数save则完成具体的工作，其参数saved就是之前所说的用于存储已保存表的表。例如，假设要创建一个如下所示的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x = <span class="number">1</span>, y = <span class="number">2</span>;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;</span><br><span class="line">a[<span class="number">2</span>] = a <span class="comment">-- 循环</span></span><br><span class="line">a.z = a[<span class="number">1</span>]	<span class="comment">-- 共享子表</span></span><br></pre></td></tr></table></figure>
<p>调用save(“a”,a)会将其保存为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="number">1</span>] = &#123;&#125;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>] = a</span><br><span class="line">a[<span class="string">&quot;y&quot;</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="string">&quot;x&quot;</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="string">&quot;z&quot;</span>] = a[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>取决于表的遍历情况，这些赋值语句的实际执行顺序可能会有所不同。不过尽管如此，上述算法能够保证任何新定义节点中所用到节点都是已经被定义过的。<br>如果想保存具有共享部分的几个表，那么可以在调用函数save时使用相同的表saved函数，例如，假设有如下两个表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>&#125;,<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;k = a[<span class="number">1</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>如果以独立的方式保存这些表，那么结果中不会有共同的部分。不过，如果调用save函数时使用同一个表saved，那么结果就会共享共同的部分：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">save(<span class="string">&quot;a&quot;</span>,a,t)</span><br><span class="line">save(<span class="string">&quot;b&quot;</span>,b,t)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- a = &#123;&#125;</span></span><br><span class="line"><span class="comment">-- a[1] = &#123;&#125;</span></span><br><span class="line"><span class="comment">-- a[1][1] = &quot;one&quot;</span></span><br><span class="line"><span class="comment">-- a[1][2] = &quot;two&quot;</span></span><br><span class="line"><span class="comment">-- a[2] = 3</span></span><br><span class="line"><span class="comment">-- b = &#123;&#125;</span></span><br><span class="line"><span class="comment">-- b[&quot;k&quot;] = a[1]</span></span><br></pre></td></tr></table></figure>
<p>在Lua语言中，还有其他一些比较常见的方法。例如，我们可以保存一个值时不指定全局名称而是通过一段代码来创建一个局部值并将其返回，也可以在可能的时候使用列表的语法等等。Lua预压给我们提供了构建这些机制的工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Lua数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 18:44:36" itemprop="dateCreated datePublished" datetime="2020-04-18T18:44:36+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言中的表并不是一种数据结构，它们是其他数据结构的基础。我们可以用Lua语言中的表来实现其他语言提供的数据结构，如数组、记录、列表、队列、集合等。而且，用Lua语言中的表实现这些数据结构还很高效。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>在像C和Pascal这样更加传统的语言中，通常使用数组和列表来实现大多数数据结构。虽然在Lua语言中也可以使用表来实现数组和列表，但表实际上比数组和列表强大很多。使用表时，很多算法可以被简化。例如，由于表本身就支持任意数据类型的直接访问，因此我们很少在Lua语言中编写搜索算法。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在Lua语言中，简单地使用整数来索引表即可实现数组。因此，数组的大小不用非得是固定的，而是可以按需增长的。通常，在初始化数组时就间接地定义了数组的大小。例如，在执行了以下的代码后，任何访问范围1~1000之外的元素都会返回nil而不是0：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">1000</span> <span class="keyword">do</span> </span><br><span class="line">	a[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>长度运算符（#）正是基于此来计算数组大小的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#a)</span><br></pre></td></tr></table></figure>
<p>可以使用0、1或其他任何值来作为数组的起始索引：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-5</span> , <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">	a[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>不过，在Lua语言中一般以1作为数组的起始索引，Lua语言的标准库和长度运算符都遵循这个惯例。如果数组的索引不从1开始，那就不能使用这些机制。<br>可以通过表构造器在一句表达式中同时创建和初始化数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这种表构造器根据需求要多大就能多大。在Lua语言中，利用数据描述文件创建包含几百万个元素组成的构造器很常见。</p>
<h2 id="矩阵及多维数组"><a href="#矩阵及多维数组" class="headerlink" title="矩阵及多维数组"></a>矩阵及多维数组</h2><p>在Lua语言中，有两种方式来表示矩阵。第一种方式就是使用一个不规则数组，即数组的数组，也就是一个所有元素均是另一个表的表。例如，可以使用如下代码来创建一个全0元素的N*M维矩阵：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> , N <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> row = &#123;&#125;</span><br><span class="line">	mt[i] = row</span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">		row[j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于表在Lua语言中是一种对象，因此在创建矩阵时必须显示地创建每一行。一方面，这比在C语言中直接声明一个多维数组更加具体；另一方面，这也给我们提供了很多的灵活性。例如，只需将前例中的内层循环改为for j &#x3D; 1,i do … end就可以创建一个三角矩阵。使用这套代码，三角矩阵较原来的矩阵可以节约一半的内存。<br>在Lua中表示矩阵的第二种方式是将两个索引合并为一个。典型情况下，我们通过将第一个索引乘以一个合适的常量再加上第二个索引来实现这种效果。在这种方式下，我们可以使用以下的代码来创建一个全0元素的N*M维矩阵：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> aux = (i <span class="number">-1</span>) * M </span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">		mt[aux = j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>应用程序中经常会用到稀疏矩阵，这种矩阵中的大多数元素是0或nil。例如，我们可以使用邻接矩阵来表示图。当矩阵出元素的值为x时，表示图中的节点m和n是相连的，连接的权重为x；若上述的两个节点不相连，那么矩阵的 (m,n)处元素的值为nil。如果要表示一个具有1万个节点的图，那么需要一个包含1亿个元素的矩阵，但是其中大约只有5万个元素不为nil。许多有关数据结构的书籍都会深入地讨论如何实现这种稀疏矩阵而不必浪费800MB内存空间，但在Lua语言中却很少需要用到那些技巧。这是因为，我们使用表实现数组而表本来就是稀疏的。在第一种实现中，需要1万个表，每个表5个元素，总共5万个元素。在第二种实现中，只需要一个表，其中包含5万个元素。无论哪种实现，都是只非nil的元素才占用空间。<br>由于在有效元素之间存在空间，因此不能对稀疏举着使用长度运算符。这没什么大不了的，即使我们能够使用长度运算符，最好也不要那么做。对于大多数针对稀疏矩阵的操作来说，遍历空元素是非常低效的。相反，可以使用pairs来只遍历非nil的元素。例如，考虑如何进行由不规则数组表示的稀疏矩阵的矩阵乘法。<br>假设矩阵a[M,K]乘以矩阵b[K,N]的结果为矩阵c[M,N]，常见的矩阵相乘算法形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">		c[i][j] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> k = <span class="number">1</span>,K <span class="keyword">do</span></span><br><span class="line">			c[i][j] = c[i][j] + a[i][k] * b[k][j]</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>外层的两个循环遍历了整个结果矩阵，然后使用内层循环计算每一个元素的值。<br>对于使用不规则矩阵实现的稀疏矩阵，内层循环会有问题。由于内层循环遍历的是一列b而不是一行，因此不能再此处使用pairs：这个循环必须遍历每一行来检查对应的行是否在对应列中有元素。除了遍历了少量非0元素以外，这个循环还遍历了所有的0元素。（由于不知道元素的空间位置，所以在其他场景下遍历一列可也能会有问题。）<br>以下的算法与之前的示例非常类似，但是该算法调换了两个内层循环的顺序。通过这个简单的调整，该算法避免了遍历列：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span> , K <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">			c[i][j] = c[i][j] + a[i][k] * b [k][j]</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，中间的一层循环遍历行a[i]，而内层循环遍历行b[k]。这两个遍历都可以使用pairs来实现遍历非0元素。由于一个空的稀疏矩阵本身就是使用0填充的，所以对结果矩阵c的初始化没有任何问题。<br>下面代码战士了上述算法的完整实现，其中使用了pairs来处理稀疏矩阵的元素。这种实现只访问非nil元素，同时结果也是稀疏矩阵。此外，下面的代码还删去了结果中偶然为0的元素。</p>
<blockquote>
<p>稀疏矩阵相乘</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mult</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="keyword">local</span> c = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> resultline = &#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> k ,va <span class="keyword">in</span> <span class="built_in">pairs</span>(a[i]) <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j , vb <span class="keyword">in</span> <span class="built_in">pairs</span>(b[k]) <span class="keyword">do</span></span><br><span class="line">				<span class="keyword">local</span> res = (resultline[j] <span class="keyword">or</span> <span class="number">0</span> ) + va * vb</span><br><span class="line">				resultline[j] = (res ~= <span class="number">0</span>) <span class="keyword">and</span> res  <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		c[i] = resultline</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>由于表是动态对象，所以在Lua语言中可以很容易地实现链表。我们可以把每个节点用一个表来表示，链接则为一个包含指向其他表的引用的简单表字段。例如，让我们实现一个单链表，其中每个节点具有两个字段value和next。最简单的变量就是根节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>要在表头插入一个值为v的元素，可以使用如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = &#123;<span class="built_in">next</span> = list, value = v&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过如下的方式遍历链表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> l = list</span><br><span class="line"><span class="keyword">while</span> l <span class="keyword">do</span></span><br><span class="line">	visit l.value</span><br><span class="line">	l = l.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>诸如双向链表或环形表等其他类型的链表也很容易实现。不过，由于通常无须链表即可用更简单的方式来表示数据，所以在Lua语言中很少需要用到这些数据结构。例如，我们可以通过一个无界数组来表示栈。</p>
<h2 id="队列及双端队列"><a href="#队列及双端队列" class="headerlink" title="队列及双端队列"></a>队列及双端队列</h2><p>在Lua语言中实现队列的一种简单方法是使用table标准库中的函数insert和remove。</p>
<blockquote>
<p>示例： 一个双端队列</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listNew</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> &#123;first = <span class="number">0</span> ,last = <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushFisrt</span><span class="params">(list,value)</span></span></span><br><span class="line">	<span class="keyword">local</span> first = list.first - <span class="number">1</span></span><br><span class="line">	list.first = first</span><br><span class="line">	list[first] = value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushLast</span> <span class="params">(list ,value)</span></span></span><br><span class="line">	<span class="keyword">local</span> last = list.last + <span class="number">1</span></span><br><span class="line">	list.last = last</span><br><span class="line">	list[last] = value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popFirst</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">local</span> first = list.first</span><br><span class="line">	<span class="keyword">if</span> first &gt; list.last <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;list is empty&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> value = list[first]</span><br><span class="line">	list[first] = <span class="literal">nil</span></span><br><span class="line">	list.first = first + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popLast</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">local</span> last = list.last</span><br><span class="line">	<span class="keyword">if</span> list.first &gt; last <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">error</span>(<span class="string">&quot;list is empty&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> value = list[last]</span><br><span class="line">	list[last] = <span class="literal">nil</span></span><br><span class="line">	list.last = last  - <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果希望严格地遵循队列的规范使用这个结构，那么就只能调用pushLast和popFirst函数，first和last都会不断增长。不过，由于我们在Lua语言中使用表来表示数组，所以我们既可以在1-20的范围内对数组进行索引，也可以在16777201-16777220的范围内索引数组。对于一个64为整型数而言，以每秒1000万次的速度进行插入也需要运行3万年才会发生溢出的问题。</p>
<h2 id="反向表"><a href="#反向表" class="headerlink" title="反向表"></a>反向表</h2><p>我们很少在Lua语言中进行索引操作。但是，我们使用被称为索引表或反向表的数据结构。<br>假设有一个存放了一周每一天名称的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要将一周每一天的名称转换为其在一周里的位置，那么可以通过索引这表来寻找指定的名称。不过，一种更高效的方式是构造一个方向表，假定为revDays，该表中的索引为一周每一天的名称而值为其在一周里的位置。这个表形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revDays = &#123;[<span class="string">&quot;Sunday&quot;</span>] = <span class="number">1</span> ,[<span class="string">&quot;Monday&quot;</span>] = <span class="number">2</span>,[<span class="string">&quot;Tuesday&quot;</span>] = <span class="number">3</span>,[<span class="string">&quot;Wednesday&quot;</span>] = <span class="number">4</span>,[<span class="string">&quot;Thursday&quot;</span>] = <span class="number">5</span>,[<span class="string">&quot;Friday&quot;</span>] = <span class="number">6</span>,[<span class="string">&quot;Saturday&quot;</span>] = <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后，只需要直接在反向表中根据名称进行索引就可以了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;Tuesday&quot;</span></span><br><span class="line"><span class="built_in">print</span>(revDays[x])				<span class="comment">-- 3</span></span><br></pre></td></tr></table></figure>
<p>当然，这个反向表不同手工声明，可以从原始的表中自动地构造出方向标：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">revDays = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(days) <span class="keyword">do</span> </span><br><span class="line">	revDays[v] = k</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上例中的循环会对每个元素days进行赋值，变量k获取到的是键(1,2,…)而变量v获取到的是值(“Sunday”,”Monday”,…)。</p>
<h2 id="集合与包"><a href="#集合与包" class="headerlink" title="集合与包"></a>集合与包</h2><p> 假设我们想列出一个程序源代码中的所有标识符，同时过滤掉其中的保留字。一些C程序员可能倾向于使用字符串数组来表示保留字集合，然后搜索这个数组来决定某个单词是否属于该集合。为了提高搜索的速度，他们还可能使用二叉树来表示该集合。<br>在Lua语言中，还可以用一中高效且简单的方式来表示这类集合，即集合元素作为索引放入表中。那么，对于指定的元素无须再搜索表，只需要该元素检索表并检查结果是否为nil即可。以上述需求为例，代码形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reserved = &#123;[<span class="string">&quot;while&quot;</span>] = <span class="literal">true</span>, [<span class="string">&quot;if&quot;</span>] = <span class="literal">true</span>,[<span class="string">&quot;else&quot;</span>] = <span class="literal">true</span>,[<span class="string">&quot;do&quot;</span>] =<span class="literal">true</span>,&#125;</span><br><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;[%a_][%w_]*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> reserved[w] <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">do</span> something with <span class="string">&#x27;w&#x27;</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们可以借助一个辅助函数来构造集合，使得初始化过程更清晰：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span><span class="params">(list)</span></span></span><br><span class="line">	<span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, l <span class="keyword">in</span> <span class="built_in">ipairs</span>(list) <span class="keyword">do</span></span><br><span class="line">		set[l] = <span class="literal">true</span> </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">reserved = Set&#123;<span class="string">&quot;while&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;function&quot;</span>,<span class="string">&quot;local&quot;</span>,&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用另一个集合来保存标识符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ids = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;[%a_][%w_]*&quot;</span>) <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> reserved[w] <span class="keyword">then</span></span><br><span class="line">		ids[w] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 输出每一个标识符</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">pairs</span>(ids) <span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">print</span>(w)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>包(bag)，也被称为多重集合，与普通集合的不同之处在于其中的元素可以出现多次。在Lua语言中，包的简单表示类似于此前集合的表示，只不过其中的每一个键都有一个对应的计数器。如果要插入一个元素，可以递增其计数器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> <span class="params">(bag,element)</span></span></span><br><span class="line">	bag[element] = (bag[element] <span class="keyword">or</span> <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果要删除一个元素，可以递减其计数器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> <span class="params">(bag,element)</span></span></span><br><span class="line">	<span class="keyword">local</span> count = bag[element]</span><br><span class="line">	bag[element] = (count <span class="keyword">and</span> count &gt; <span class="number">1</span>) <span class="keyword">and</span> count - <span class="number">1</span> <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>只有当计数器存在且大于0时我们才会保留计数器。</p>
<h2 id="字符串缓冲区"><a href="#字符串缓冲区" class="headerlink" title="字符串缓冲区"></a>字符串缓冲区</h2><p>假设我们正在开发一段处理字符串的程序，比如逐行地读取一个文件。典型的代码可能形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> buff = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	buff = buff .. line .. <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>虽然这段Lua语言代码看似能够正常工作，但实际上在处理大文件时却可能导致巨大的性能开销。<br>这是为什么呢？为了搞清楚到底发生了什么，让我们想象一下读取循环中发生了什么。假设每行有20字节，当我们读取了大概2500行后，buff就会变成一个50KB大小的字符串。在Lua语言中进行字符串连接<code>buff..line..&quot;\n&quot;</code>时，会创建一个50020字节的新字符串，然后从buff中复制50000字节中到这个新字符串中。这样，对于后续的每一行，Lua语言都需要移动大概50KB且还在不断增长的内存。因此，该算法的时间复杂度是二次方的。在读取了100行以后，Lua语言就已经移动了至少5MB内存。当Lua语言完成了350KB的读取后，它已经至少移动了50GB的数据。<br>对于较小的字符串，上述循环并没什么问题。当读取整个文件时，Lua语言提供了带有参数的函数io.read(“a”)来一次性读取整个文件。不过，有时候我们必须面对这个问题。Java提供了StringBuffer类还解决这个问题；而在Lua语言中，我们可以把一个表当做字符串缓冲区，其关键是使用函数table.concat，这个函数会将指定列表中的所有字符串连接起来并返回连接后的结果。使用函数concat可以这样重写上述循环：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	t[#t + <span class="number">1</span>] = line .. <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t)</span><br></pre></td></tr></table></figure>
<p>之前的代码读取同样的文件需要超过半分钟，而上述实现则只需要不到0.05秒。我们还可以做得更好。函数concat还有第2个可选参数，用于指定插在字符串间的分隔符。有了这个分隔符，我们就不必在每行后插入换行符了。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	t[#t + <span class="number">1</span>] = line</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t,<span class="string">&quot;\n&quot;</span>) .. <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然函数concat能够在字符串之间插入分隔符，但我们还需要增阿基最后一个换行符。最后一次字符串连接创建了结果字符串的一个副本，这个副本可能已经相当长了。虽然没有直接的选项能够让函数concat插入这个额外的分隔符，但我们可以想办法绕过，只需在字符串t后面添加一个空字符串就行了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[#t + <span class="number">1</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t,<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>现在，正如我们所期望的那样，函数concat会在结果字符串的额最后添加一个换行符。</p>
<h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><p>像其他现代编程语言一眼个，Lua语言也允许开发人员使用多种实现表示图，每种实现都有其所使用的特定算法。<br>我们使用一个由两个字段组成的表来表示每个节点，即name(节点名称)和adj(与此节点邻接的节点和集合)。由于我们会从一个文本文件中加载图对应的数据，所以需要能够根据节点的名称来寻找指定节点的方法。因此，我们使用了一个额外的表来建立节点和节点名称之间的映射。函数name2node可以根据指定节点的名称返回对应的节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">name2node</span><span class="params">(graph,name)</span></span></span><br><span class="line">	<span class="keyword">local</span> node = graph[name]</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">then</span></span><br><span class="line">		node = &#123;name = name ,adj = &#123;&#125;&#125;</span><br><span class="line">		graph[name] = node </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> node </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例：从文件中加载图</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readgraph</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> graph = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">		<span class="comment">-- 把一行分割为两个名字</span></span><br><span class="line">		<span class="keyword">local</span> namefrom, nameto = <span class="built_in">string</span>.<span class="built_in">match</span>(line,<span class="string">&quot;(%S+)%s+(%S+)&quot;</span>)</span><br><span class="line">		<span class="comment">-- 找到对应的节点</span></span><br><span class="line">		<span class="keyword">local</span> from = name2node(graph,namefrom)</span><br><span class="line">		<span class="keyword">local</span> to = name2node(graph,nameto)</span><br><span class="line">		<span class="comment">-- 把‘to’增加到邻接集合&#x27;from&#x27;中</span></span><br><span class="line">		from.adj[to] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> graph</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该函数逐行地读取一个文件，文件的每一行中有两个节点的名称，表示从第1个节点到第2个节点有一条边。对于每一行，调用函数string.match将一行中的两个节点的名称分开，然后根据名称找到对应的节点，最后将这些节点连接在一起。</p>
<blockquote>
<p>示例：寻找两个节点之间的路径</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findpath</span><span class="params">(curr,to,path,visited)</span></span></span><br><span class="line">	<span class="built_in">path</span> = <span class="built_in">path</span> <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	visited = visited <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> visited[curr] <span class="keyword">then</span>   <span class="comment">-- 是否节点已被访问</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>			<span class="comment">-- 不存在路径</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	visited[curr] = <span class="literal">true</span>    <span class="comment">-- 标记节点为已被访问</span></span><br><span class="line">	<span class="built_in">path</span>[#<span class="built_in">path</span> + <span class="number">1</span>] = curr	<span class="comment">-- 增加到路径中</span></span><br><span class="line">	<span class="keyword">if</span> curr == to <span class="keyword">then</span>		<span class="comment">-- 是否是最后一个节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">path</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">pairs</span>(curr.adj) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> p = findpath(node,to ,<span class="built_in">path</span>,visited)</span><br><span class="line">		<span class="keyword">if</span> p <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">return</span> p</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">path</span>)		<span class="comment">-- 从路径中删除节点</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>函数findpath使用深度优先遍历搜索两个节点之间的路径。该函数的第1个参数是当前节点，第2个参数是目标节点，第3个参数用于保存从起点到当前节点的路径，最后一个参数为所有已被访问节点的几何。<br>为了测试上述代码，我们编写一个打印一条路径的函数，再编写一些代码让上述所有代码跑起来：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printpath</span><span class="params">(path)</span></span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">path</span> <span class="keyword">do</span> </span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">path</span>[i].name)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">g = readgraph()</span><br><span class="line">a = name2node(g,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">b = name2node(g,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">p = findpath(a,b)</span><br><span class="line"><span class="keyword">if</span> p <span class="keyword">then</span> printpath(p) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/Lua%E4%BD%8D%E5%92%8C%E5%AD%97%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/Lua%E4%BD%8D%E5%92%8C%E5%AD%97%E8%8A%82/" class="post-title-link" itemprop="url">Lua连续教程之Lua位和字节</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 11:51:18" itemprop="dateCreated datePublished" datetime="2020-04-18T11:51:18+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言处理二进制数据的方式与处理文本的方式类似。Lua语言中的字符串可以包含热议字节，并且几乎所有能够处理字符串的库函数也能处理任意字节。我们甚至可以对二进制数据进行模式匹配。以此为基础，Lua5.3中引入了用于操作二进制数据的额外机制：除了整型数外，该版本还引入了位操作及用于打包&#x2F;解包二进制数据的函数。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>Lua语言从5.3版本开始提供了针对数值类型的一组标准位运算符与算术运算符不同的是，位运算符只能用于整型数。位运算符包括<code>&amp;</code>(按位与)、<code>|</code>(按位或)、<code>~</code>(按位异或)、<code>&gt;&gt;</code>(逻辑右移)、<code>&lt;&lt;</code>(逻辑左移)和一元运算符<code>~</code>(按位取反)。<br>所有的位运算都针对构成一个整型数的所有位。在标准Lua中，也就是64位。这对于用32位整型数的算法可能会成问题。不过，要操作32位整型数也不难。除了右移操作外，只要忽略高32位，那么所有针对64位整型数的操作与针对32位整型数的操作都一样。这对于加法、减法和乘法都有效。因此，在操作32位整型数时，只需要在进行右移前抹去高32位即可。<br>两个移位操作都会用0填充空出的位，这种行为通常被称为逻辑移位。Lua语言没有提供算术右移，即使用符号位填充空出的位。我们可以通过向下取整除法，除以合适的2的整数次幂实现算术右移。<br>移位数是负数表示向相反的方向移位，即a&gt;&gt;n与a&lt;&lt;-n等价：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%x&quot;</span>,<span class="number">0xff</span> &lt;&lt; <span class="number">12</span>) 			<span class="comment">-- ff000</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%x&quot;</span>,<span class="number">0xff</span> &gt;&gt; <span class="number">-12</span>)			<span class="comment">-- ff000</span></span><br></pre></td></tr></table></figure>
<p>如果移位数等于或大于整型表示的位数，由于所有的位都被从结果中移出了，所有结果是0：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%x&quot;</span>,<span class="number">-1</span> &lt;&lt; <span class="number">80</span>)		<span class="comment">-- 0</span></span><br></pre></td></tr></table></figure>

<h2 id="无符号整型数"><a href="#无符号整型数" class="headerlink" title="无符号整型数"></a>无符号整型数</h2><p>整型表示中使用一个比特来存储符号位。因此，64位整型数最大可以表示2^63^ - 1 而不是2^64^ -1。通常，这点区别是无关紧要的。因为2^63^ - 1 已经相当大了。不过，由于我们可能需要处理使用无符号整型表示的外部数据或实现一些需要64位整型数的算法，因而有时也不能浪费这个符号位。因此，在精简Lua中，这种区别可能会很重要。例如，如果用一个32位有符号整型数表示文件中的位置，那么能够操作的最大文件大小就是2GB；而一个无符号整型数能操作的最大文件大小则是有符号整型数的2倍，即4GB。<br>Lua语言不显示支持无符号整型数。不过尽管如此，只要稍加注意，在Lua语言中处理无符号整型数并不难。<br>虽然看上去不太友好，但可以直接写出比2^63^-1大的常量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">13835058055282163712</span>		<span class="comment">-- 3 &lt;&lt; 62</span></span><br><span class="line">x 	<span class="comment">-- -4611686018427387904</span></span><br></pre></td></tr></table></figure>
<p>这里的问题并不在于常量本身，而在于Lua语言输出常量的方式：默认情况下，打印数值时是将其作为有符号整型数进行处理的。我们可以使用选项%u或%x在函数string.format中指定以无符号整型数进行输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%u&quot;</span>,x)			<span class="comment">-- 1383505855282163712</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;0x%X&quot;</span>,x)			<span class="comment">-- 0xC000000000000000</span></span><br></pre></td></tr></table></figure>
<p>根据有符号整型数的表示方式，加法、减法和乘法操作对于有符号整型数和无符号整型数是一样的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%u&quot;</span>,x)			<span class="comment">-- 1383505855282163712</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%u&quot;</span>,x+<span class="number">1</span>)			<span class="comment">-- 1383505855282163713</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%u&quot;</span>,x<span class="number">-1</span>)			<span class="comment">-- 1383505855282163711</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于这么大的数，即便x乘以2也会溢出，所以示例中没有演示乘法</p>
</blockquote>
<p>关系运算对于有符号整型数和无符号整型数是不一样的，当比较具有不同符号位的整型数时就会出现问题。对于有符号整型数而言，符号位被置位的整数更小，因为它代表的是负数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffffffffff</span> &lt; <span class="number">0x8000000000000000</span>  <span class="comment">-- false</span></span><br></pre></td></tr></table></figure>
<p>如果把两个整型数当作无符号的，那么结果显然是不正确的。因此，我们需要使用一种不同的操作来比较无符号整型数。Lua5.3提供了函数math.ult来完成这个需求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">math</span>.ult(<span class="number">0x7fffffffffffffff</span>,<span class="number">0x8000000000000000</span>)  <span class="comment">-- true</span></span><br></pre></td></tr></table></figure>
<p>另一种方法是在进行有符号比较前先用掩码掩去两个操作数的符号位：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = <span class="number">0x8000000000000000</span></span><br><span class="line">(<span class="number">0x7fffffffffffffff</span> ~mask)&lt;(<span class="number">0x8000000000000000</span> ~mask)		<span class="comment">--true</span></span><br></pre></td></tr></table></figure>
<p>无符号除法和有符号除法也不一样</p>
<blockquote>
<p>无符号除法</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">udiv</span><span class="params">(n,d)</span></span></span><br><span class="line">	<span class="keyword">if</span> d &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">math</span>.ult(n,d) <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">local</span> q = ((n &gt;&gt; <span class="number">1</span>)//d) &lt;&lt; <span class="number">1</span></span><br><span class="line">	<span class="keyword">local</span> r = n - q * d</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">math</span>.ult(r,d) <span class="keyword">then</span> q = q + <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> q</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>第一个比较（d&lt;0）等价于比较d是否大于2^63^。如果大于，那么商只能是1（如果n等于或大于d）或0。否则，我们使被除数除以2，然后除以除数，再把结果乘以2。右移1位等价于除以2的无符号除法，其结果是一个非负的有符号整型数。后续的左移纠正了商，还原了之前的除法。<br>总体上说，floor(floor(n&#x2F;2)&#x2F;d)*2(算法进行的计算)与floor(((n&#x2F;2)&#x2F;d)*2)(正确的结果）并不等价，不过，要证明它们之间最多相差1并不困难。因此，算计计算了余数（变量r），然后判断余数是否比除数大，如果余数比除数大则纠正商即可。<br>无符号整型数和浮点型数之间的转换需要进行一些调整。要把一个无符号整型数转换为浮点型数，可以先将其转换成有符号整型数，然后通过取模运算纠正救过：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="number">11529215046068469760</span></span><br><span class="line">f = (u + <span class="number">0.0</span>) % <span class="number">2</span>^<span class="number">64</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%.0f&quot;</span>,f)			<span class="comment">-- 11529215046068469760</span></span><br></pre></td></tr></table></figure>
<p>由于标准转换把u当做有符号整型数，因此表达式u+0.0的值是-6917529027641081856，而之后的取模操作会把这个值限制在有符号整型数的表示范围内。<br>要把一个浮点型数转换为无符号整型数，可以使用如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="number">0xA000000000000000</span><span class="number">.0</span>		</span><br><span class="line">u = <span class="built_in">math</span>.tointerger(((f + <span class="number">2</span>^<span class="number">63</span>)%<span class="number">2</span>^<span class="number">64</span>) - <span class="number">2</span>^<span class="number">63</span>)</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%x&quot;</span>,u)			<span class="comment">-- a000000000000000</span></span><br></pre></td></tr></table></figure>
<p>加法把一个大于2^63^的数转换为一个大于2^64^的数，取模运算把这个数限制到[0,2^63^)范围内，然后通过减法把结果变成一个“负”值。对于小于2^63^的值，加法结果小于2^64^，所以取模运算没有任何效果，之后的减法则把它恢复到了之前的值。</p>
<h2 id="打包和解包二进制数据"><a href="#打包和解包二进制数据" class="headerlink" title="打包和解包二进制数据"></a>打包和解包二进制数据</h2><p>Lua5.3还引入了一个在二进制数和基本类型值之间进行转换的函数。函数string.pack会把值“打包”为二进制字符串，而函数string.unpack则从字符串中提取这些值。<br>函数string.pack和函数string.unpack的第1个参数是格式化字符串，用于描述如何打包数据。格式化字符串中的每个字母都描述了如何打包&#x2F;解包一个值，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.pack(<span class="string">&quot;iii&quot;</span>,<span class="number">3</span>,<span class="number">-27</span>,<span class="number">450</span>)</span><br><span class="line">#s</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;iii&quot;</span>,s)		<span class="comment">-- 3	-27	450	13</span></span><br></pre></td></tr></table></figure>
<p>调用函数string.pack将创建一个字符串，其中为3个整型数的二进制代码。每一个”i”编码对与之对应的参数进行了编码，而字符串的长度则是一个整型数本身大小的3倍。调用函数string.unpack对给定字符串中的3个整型数进行了解码并返回解码后的结果。<br>为了便于迭代，函数string.unpack还会返回最后一个读取的元素在字符串中的位置。相应地，该函数还有一个可选的第3个参数，这个参数用于指定开始读取的位置。例如，下例输出了一个指定字符串中所有被打包的字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello\0Lua\0world\0&quot;</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= #s <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> res</span><br><span class="line">	res, i = <span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;z&quot;</span>,s,i)</span><br><span class="line">	<span class="built_in">print</span>(res)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- hello</span></span><br><span class="line"><span class="comment">-- Lua</span></span><br><span class="line"><span class="comment">-- world</span></span><br></pre></td></tr></table></figure>
<p>对于编码一个整型数而言有几种选项，每一种对应了一种整型大小：b(char)、h(short)、i(int)、l(long)和j(代表Lua语言中整型数的大小)。要是使用固定的、与机器无关的大小，可以在选项i后加上一个1~16的数。例如，i7会产生7个字节的整型数。所有的大小都会被检查是否存在一处的情况：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">string</span>.pack(<span class="string">&quot;i7&quot;</span>, i &lt;&lt; <span class="number">54</span>)</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;i7&quot;</span>,x)				<span class="comment">-- 18014398509481984	8</span></span><br><span class="line">x = <span class="built_in">string</span>.pack(<span class="string">&quot;i7&quot;</span>,-(<span class="number">1</span> &lt;&lt; <span class="number">54</span>))</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;i7&quot;</span>,x)				<span class="comment">-- -1801439850948		8</span></span><br><span class="line">x = <span class="built_in">string</span>.pack(<span class="string">&quot;i7&quot;</span>,<span class="number">1</span> &lt;&lt; <span class="number">55</span>)</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>:bad argument #<span class="number">2</span> to <span class="string">&#x27;pack&#x27;</span>(interger overflow)</span><br></pre></td></tr></table></figure>
<p>我们可以打包和解包比Lua语言原生整型数更大的整型数，但是在解包的时候它们的实际值必须能够被Lua语言的整型数容纳：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">string</span>.pack(<span class="string">&quot;i12&quot;</span>,<span class="number">2</span>^<span class="number">61</span>)</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;i12&quot;</span>,x)				<span class="comment">-- 23058443009213693952		13</span></span><br><span class="line">x = <span class="string">&quot;aaaaaaaaaaaa&quot;</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;i12&quot;</span>,x)</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>: <span class="number">12</span>-<span class="built_in">byte</span> integer does <span class="keyword">not</span> fit into Lua integer</span><br></pre></td></tr></table></figure>
<p>每一个针对整型数的选项都有一个对应的大写版本，对应相应大小的无符号整型数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;\xFF&quot;</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;b&quot;</span>,s)		<span class="comment">-- -1 2</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;B&quot;</span>,s)		<span class="comment">-- 255 2</span></span><br></pre></td></tr></table></figure>
<p>同时，无符号整型数对于size_t而言还有一个额外的选项T。<br>我们可以用3中表示形式打包自付出：\0结尾的字符串、定长字符串和使用显示长度的字符串。\0结尾的字符串使用选项z；定长字符串使用选项cn，其中n是被打包字符串的字节数。显示长度的字符串在存储时会在字符串前加上该字符串的长度。在这种情况下，选项格式形如sn，其中n是用于保存字符串长度的无符号整型数的大小。例如，选项s1表示把字符串长度保存在一个字节中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.pack(<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #s <span class="keyword">do</span> <span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;B&quot;</span>,s,i))) <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5	(length)</span></span><br><span class="line"><span class="comment">-- 104	(&#x27;h&#x27;)</span></span><br><span class="line"><span class="comment">-- 101	(&#x27;e&#x27;)</span></span><br><span class="line"><span class="comment">-- 108	(&#x27;l&#x27;)</span></span><br><span class="line"><span class="comment">-- 108	(&#x27;l&#x27;)</span></span><br><span class="line"><span class="comment">-- 111	(&#x27;o&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>如果用于保存长度的字节容纳不了字符串长度，那么Lua语言会抛出异常。我们也可以单纯使用选项s，在这种情况下，字符串长度会被以足够容纳任何字符串长度的size_t类型保存。<br>对于浮点型数，有3中选项：f用于单精度浮点数、d用于双精度浮点数、n用于Lua语言浮点数。<br>格式字符串也有用来控制大小端模式和二进制数据对齐的选项。在默认情况下，格式使用的是机器原生的大小端模式。选项&gt;把所有后续的编码转换改为大端模式或网络字节序：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.pack(<span class="string">&quot;&gt;i4&quot;</span>,<span class="number">1000000</span>)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #s <span class="keyword">do</span> <span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;B&quot;</span>,s,i))) <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 00</span></span><br><span class="line"><span class="comment">-- 15</span></span><br><span class="line"><span class="comment">-- 66</span></span><br><span class="line"><span class="comment">-- 64</span></span><br></pre></td></tr></table></figure>
<p>选项&lt;则改为小端模式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.pack(<span class="string">&quot;&lt;i2 i2&quot;</span>,<span class="number">500</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #s <span class="keyword">do</span> <span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">unpack</span>(<span class="string">&quot;B&quot;</span>,s,i))) <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 244</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- 24</span></span><br><span class="line"><span class="comment">-- 0</span></span><br></pre></td></tr></table></figure>
<p>最后，选项&#x3D;改回机器默认的原生大小端模式。<br> 对于对齐而言，选项!n强制数据对齐到以n为倍数的索引上。更准确地说，如果数据比n小，那么对齐到其自身大小上；否则，对齐到n上。例如，假设格式化字符串为!4，那么1字节整型数会被写入以1为倍数的索引位置上，2字节的整型数会被写入以2为倍数的索引位置上，而4字节或更大的整型数则会被写入以4为倍数的索引位置上，而选项!(不带数字)则把对齐设为机器默认的对齐方式。<br> 函数string.pack通过在结果字符串到达合适索引值前增加0的方式实现对齐，函数string.unpack在读取字符串时会简单地跳过这些补位。对齐只对2的整数次幂有效，如果把对齐设为4但视图操作3字节的整型数，那么Lua语言会抛出异常。<br> 所有的格式化字符串默认带有前缀”&#x3D;!1”，即表示使用默认大小端模式且不对齐。我们可以在程序执行过程中的任意时点改变大小端模式和对齐方式。<br> 如果需要，可以手工添加补位。选项x代表1字节的补位，函数string.pack会在结果字符串中增加一个0字节，而函数string.unpack则从目标字符串中跳过1字节。</p>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>函数io.input和io.output总是以文本方式打开文件。在POSIX操作系统中，二进制文件和文本文件是没有差别的。然后，在其他一些像Windows之类的操作系统中，必须用特殊方式打开二进制文件，即在io.open的模式字符串中使用字母b。<br>通常，在读取二进制数据时，要么使用模式”a”开读取整个文件，要么使用模式n来读取n个字节。下面是一个简单的示例，它会把Windows格式的文本文件转换为POSIX格式，即把\r\n转换为\n:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> inp = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(<span class="built_in">arg</span>[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>))</span><br><span class="line"><span class="keyword">local</span> out = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(<span class="built_in">arg</span>[<span class="number">2</span>],<span class="string">&quot;wb&quot;</span>))</span><br><span class="line"><span class="keyword">local</span> data = inp:<span class="built_in">read</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">data = <span class="built_in">string</span>.<span class="built_in">gsub</span>(data,<span class="string">&quot;\r\n&quot;</span>,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">out:<span class="built_in">write</span>(data)</span><br><span class="line"><span class="built_in">assert</span>(out:<span class="built_in">close</span>())</span><br></pre></td></tr></table></figure>
<p>由于标准I&#x2F;O流是以文本模式打开的，所以上例不能使用标准I&#x2F;O流。相反，该程序假设输入和输出文件的名称是由程序的参数指定的。可以使用如下的命令调用该程序：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua prog.lua file.dos file.unix</span><br></pre></td></tr></table></figure>
<p>再举一个例子，一下的程序输出了一个二进制文件中的所有字符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>))</span><br><span class="line"><span class="keyword">local</span> data = f:<span class="built_in">read</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> validchars = <span class="string">&quot;[%g%s]&quot;</span></span><br><span class="line"><span class="keyword">local</span> pattern = <span class="string">&quot;(&quot;</span> .. <span class="built_in">string</span>.<span class="built_in">rep</span>(validchars,<span class="number">6</span>) .. <span class="string">&quot;+)\0&quot;</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(data,pattern) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(w)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个程序假定字符串是一个以\0结尾的、包含6个或6个以上有效字符的序列，其中有效字符是指能与模式validchars匹配的任意字符。在这个示例中，这个模式由可打印字符组成。我们使用函数string.rep和字符串连接创建用于捕获以\0结尾的、包含6个或6个以上有效字符validchars的模式，这个模式中的括号用于捕获不带\0的字符串。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/17/Lua%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/17/Lua%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/" class="post-title-link" itemprop="url">Lua日期和时间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:12:47" itemprop="dateCreated datePublished" datetime="2020-04-17T20:12:47+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言的标准库提供了两个用于操作日期和时间的函数，这两个函数在C语言标准库中也存在，提供的是同样的功能。虽然这两个函数看上去很简单，但依旧可以基于这些简单的功能完成很多复杂的工作。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>Lua语言针对日期和时间使用两种表示方式。第1中表示方式是一个数字，这个数字通常是一个整型数。尽管并非IOS C所必需的，但在大多数系统中这个数字时自一个被称为纪元的固定日期后至今的秒数。特别地，在POSIX和Windows系统中国这个固定日期均是Jan 01,1970,0:00 UTC。<br>Lua语言针对日期和时间提供的第2中表示方式是一个表。日期表具有以下几个重要的字段：year、month、day、hour、min、sec、wday、yady和isdst，除isdst以外的所有字段均为整型值。前6个字段的含义非常明显，而wday字段表示本周中的第几天（第1天为星期天）；yday表示当年中的第几天（第1天是1月1日）；isdst字段表示布尔类型，如果使用夏时令则为真。例如，Sep 16,1998,23:48:10（星期三）对应的表是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = <span class="number">1998</span>,month = <span class="number">9</span>,day = <span class="number">16</span>,yday = <span class="number">259</span>,wday = <span class="number">4</span>,hour = <span class="number">23</span>,<span class="built_in">min</span> = <span class="number">48.</span>sec = <span class="number">10</span>,isdst = <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>日期表中不包括时区，程序需要负责结合相应的时区对其正确解析。</p>
<h2 id="函数os-time"><a href="#函数os-time" class="headerlink" title="函数os.time"></a>函数os.time</h2><p>不带任何参数调用函数os.time,会以数字形式返回当前的日期和时间：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>()	   <span class="comment">-- 1587123725</span></span><br></pre></td></tr></table></figure>
<p>对应的时间是April 17,2020,19:42:05。在一个POSIX系统中，可以使用一些基本的数字运算分离这个数字：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">date</span> = <span class="number">1587123725</span></span><br><span class="line"><span class="keyword">local</span> day2year = <span class="number">265.242</span>			 一年的天数</span><br><span class="line"><span class="keyword">local</span> sec2hour = <span class="number">60</span> * <span class="number">60</span>			 一小时的秒数</span><br><span class="line"><span class="keyword">local</span> sec2day  = sec2hour * <span class="number">24</span>       一天的秒数</span><br><span class="line"><span class="keyword">local</span> sec2year = sec2day * day2year  一年的秒数</span><br><span class="line"></span><br><span class="line"> 年</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> // sec2year + <span class="number">1970</span>)</span><br><span class="line"></span><br><span class="line"> 小时</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> % sec2day // sec2hour)</span><br><span class="line"></span><br><span class="line"> 分钟</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> % sec2hour // <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"> 秒</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> % <span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p>如果以一个日期表作为参数调用os.time，那么改函数会返回该表中所描述日期和时间对应的数字。year、month和day字段是必需的，hour、min和sec字段如果没有提供的话则默认为12:00:00，其余字段则会被忽略。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2020</span>,month = <span class="number">4</span>,day = <span class="number">17</span>,hour = <span class="number">19</span>,<span class="built_in">min</span> = <span class="number">42</span>,sec = <span class="number">5</span>&#125;)		 <span class="number">1587123725</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">1970</span>,month = <span class="number">1</span>,day = <span class="number">1</span>, hour = <span class="number">0</span>&#125;)							 <span class="number">10800</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">1970</span>,month = <span class="number">1</span>,day = <span class="number">1</span>, hour = <span class="number">0</span>,sec = <span class="number">1</span>&#125;)					 <span class="number">10801</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">1970</span>,month = <span class="number">1</span>,day = <span class="number">1</span>&#125;)									 <span class="number">54000</span></span><br></pre></td></tr></table></figure>
<p>请注意，10800是3个小时的秒数，54000则是10800加上12个小时的秒数。</p>
<h2 id="函数os-date"><a href="#函数os-date" class="headerlink" title="函数os.date"></a>函数os.date</h2><p>函数os.date在一定程度上是函数os.time的反函数，它可以将一个表示日期和时间的数字转换为某些高级的表示形式，要么是日期表要么是字符串。该函数的第1个参数是描述期望表示形式的格式化字符串，第2个参数是数字形式的日期和时间。<br>要生成一个日期表，可以使用格式化字符串”*t”。例如，调用函数os.date(“*t”,1587123725)会返回下列表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = <span class="number">2020</span>,month = <span class="number">9</span>,day = <span class="number">16</span>,yday = <span class="number">108</span>,wday = <span class="number">6</span>,hour = <span class="number">19</span>,<span class="built_in">min</span> = <span class="number">42</span>,sec = <span class="number">5</span>,isdst = <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>大致上，对于任何有效的时间t，os.time(os.date(“*t”,t)) &#x3D;&#x3D; t均成立。<br>除了isdst,结果中的其余字段均为整型数且范围分别是：</p>
<hr>
<p>year   一整年<br>month  1<del>12<br>day    1</del>31<br>hour   0<del>23<br>min    0</del>59<br>sec    0<del>60<br>wday   1</del>7<br>yday   1~366</p>
<hr>
<p>对于其他格式化字符串，函数os.date会将日期格式化为一个字符串，该字符串是根据指定的时间和日期信息对特定的指示符进行了替换的结果。所有的指示符都以百分号开头紧跟一个字母，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;a %A in %B&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%d/%m/%Y&quot;</span>,<span class="number">1587123725</span>))      <span class="number">17</span>/<span class="number">4</span>/<span class="number">2020</span></span><br></pre></td></tr></table></figure>
<p>所有的表现形式取决于当前的区域设置。<br>下表列出了主要的指示符。</p>
<hr>
<p>%a星期几的简写<br>%A星期几的全名<br>%b月份的简写<br>%B月份的全名<br>%c日期和时间<br>%d一个月中的第几天[01<del>31]<br>%H24小时制中的小时数[00</del>23]<br>%I12小时制中的小时数[01<del>12]<br>%j一年中的第几天[001</del>365]<br>%m月份[1<del>12]<br>%M分钟[0</del>59]<br>%p”am”或”pm”<br>%S秒数[0<del>60]<br>%w星期[0</del>6 &#x3D; Sunday ~ Saturday]<br>%W一年中的第几周[0<del>53]<br>%x日期<br>%X时间<br>%y两位数的年份[0</del>99]<br>%Y完整的年份<br>%z时区<br>%%百分号</p>
<hr>
<p>对于数值，表中也给出了它们的有效范围。以下是一些演示如何创建IOS 8601格式日期和时间的示例：<br>用函数os.date(“*t”,1587123725)会返回下列表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = <span class="number">2020</span>,month = <span class="number">9</span>,day = <span class="number">16</span>,yday = <span class="number">108</span>,wday = <span class="number">6</span>,hour = <span class="number">19</span>,<span class="built_in">min</span> = <span class="number">42</span>,sec = <span class="number">5</span>,isdst = <span class="literal">false</span>&#125;</span><br><span class="line">```lua</span><br><span class="line">t = <span class="number">1587123725</span>	<span class="comment">-- IOS 8601格式的日期</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%m-%d&quot;</span>,t))	 <span class="number">2020</span><span class="number">-04</span><span class="number">-17</span></span><br><span class="line"> IOS <span class="number">8601</span>格式的日期和时间</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%m-%dT%H:%M:%S&quot;</span>,t))	 <span class="number">2020</span><span class="number">-04</span><span class="number">-17</span>T19:<span class="number">42</span>:<span class="number">05</span></span><br><span class="line"> IOS <span class="number">8601</span>格式的序数日期</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%j&quot;</span>,t))			</span><br></pre></td></tr></table></figure>
<p>如果格式化字符串以叹号开头，那么函数os.date会以UTC格式对其进行解析：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 纪元</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;!%c&quot;</span>,<span class="number">0</span>))		 Zhu Jan <span class="number">1</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br></pre></td></tr></table></figure>
<p>如果不带任何参数调用函数os.date，那么该函数会使用格式%c，即以一种合理的格式表示日期和时间信息。请注意，%x、%X和%c会根据不同的区域和系统而发生变化。如果需要诸如dd&#x2F;mm&#x2F;yyyy这样的固定表示形式，那么就必须显示地使用诸如”%d&#x2F;%m&#x2F;%Y”这样的格式化字符串。</p>
<h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><p>当函数os.date创建日期表时，该表的所有字段均在有效的范围内。当我们给函数os.time传入一个日期表时，其中的字段并不需要归一化。这个特行对于日期和时间处理非常重要。<br>举一个简单的例子，假设想知道从当前向后数40天的日期，那么可以使用如下的代码进行计算：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)		</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">04</span>/<span class="number">17</span></span><br><span class="line">t.day = t.day + <span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">05</span>/<span class="number">27</span></span><br></pre></td></tr></table></figure>
<p>如果我们把数字表示的时间转换成日期表，那么就能得到日期和时间的归一化形式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t.day,t.month)		 <span class="number">26</span> <span class="number">2</span></span><br><span class="line">t.day = t.day - <span class="number">40</span> 	</span><br><span class="line"><span class="built_in">print</span>(t.day,t.month)		 <span class="number">-14</span> <span class="number">2</span></span><br><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(t))</span><br><span class="line"><span class="built_in">print</span>(t.day,t.month)		 <span class="number">17</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在大多数系统中，也可以对数字形式的时间增加或减少34356000（40天对应的秒数）。不过，由于标准C并不要求数值表示的时间是从纪元开始的，因此标准C并不保证这种操作的正确性。此外，如果我们想增加的是月份而非天数，由于不同的月份具有不同的天数，那么直接操作秒数就会有问题。而以归一化的方式处理则没有这些问题：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)	<span class="comment">-- 获取当前时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>.<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">04</span>/<span class="number">17</span></span><br><span class="line">t.month = t.month + <span class="number">6</span>		 从当天开始往后<span class="number">6</span>个月</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>.<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">10</span>/<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>在操作日期时，我们必须要小心。虽然归一化是显而易见的方式进行的，但是也可能会有一些不明显的后果。例如，如果计算March 31之后的一个月，将会得到April 31，而实际上应该被归一化为May 1。尽管这听上去很自然，但实际上如果从结果（May 1）中减去一个月，得到的确实April 1而不是原来的March 31。请注意，这种不一致是日历机制导致的结果，与Lua语言无关。<br>函数os.difftime用来计算两个时间之间的差值，该函数以秒为单位返回两个指定数字形式表示的时间的差值。对于大多数系统而言，这个差值就是一个时间相对于另一个时间的减法结果。但是，与减法不同，函数os.difftime的行为在任何系统中都是确定的。以下示例计算了Lua5.2和Lua5.3发布时间之间间隔的天数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t5_3 = <span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2015</span>,month = <span class="number">1</span>,day = <span class="number">12</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> t5_2 = <span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2011</span>,month = <span class="number">12</span>,day = <span class="number">16</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> d = <span class="built_in">os</span>.<span class="built_in">difftime</span>(t5_3,t5_2)</span><br><span class="line"><span class="built_in">print</span>(d//(<span class="number">24</span> * <span class="number">3600</span>))     <span class="number">1123.0</span></span><br></pre></td></tr></table></figure>
<p>使用函数difftime可以获取指定日期和相对任意时刻的秒数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myepoch = <span class="built_in">os</span>.<span class="built_in">time</span>&#123;year = <span class="number">2000</span>,month = <span class="number">1</span>,day = <span class="number">1</span>,hour = <span class="number">0</span>&#125;</span><br><span class="line">now = <span class="built_in">os</span>.<span class="built_in">time</span>&#123;year = <span class="number">2015</span>,month = <span class="number">11</span>,day = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">difftime</span>(now,myepoch)			 <span class="number">501336000.0</span></span><br></pre></td></tr></table></figure>
<p>通过归一化，可以很容易地将用秒表示的时间转换为合法的数字形式表示的时间，即我们以创建一个带有开始时刻的日期表并将日期表中的秒数设置为想要转换的数字。例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T = &#123;year = <span class="number">2000</span>,month = <span class="number">1</span>,day = <span class="number">1</span>,hour = <span class="number">0</span>&#125;</span><br><span class="line">t.sec = <span class="number">501336000</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%d/%m/%Y&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(T))		 <span class="number">20</span>/<span class="number">11</span>/<span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用函数os.difftime来计算一段代码的执行时间。不过，对于这个需求更好的方式是使用函数os.clock，该函数会返回程序消耗的CPU时间（单位是秒）。函数os.clock在性能测试中的典型用法如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> x = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line"><span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">100000</span> <span class="keyword">do</span> s = s + i <span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;elapsed time: %.2f\n&quot;</span>,<span class="built_in">os</span>.<span class="built_in">clock</span>() - x))</span><br></pre></td></tr></table></figure>
<p>与函数os.time不同，函数os.clock通常具有比秒更高的精度，因此返回值为一个浮点数。具体的精度与平台相关，在POSIX系统中通常是1毫秒。</p>
<p>@[toc]<br>Lua语言的标准库提供了两个用于操作日期和时间的函数，这两个函数在C语言标准库中也存在，提供的是同样的功能。虽然这两个函数看上去很简单，但依旧可以基于这些简单的功能完成很多复杂的工作。<br>Lua语言针对日期和时间使用两种表示方式。第1中表示方式是一个数字，这个数字通常是一个整型数。尽管并非IOS C所必需的，但在大多数系统中这个数字时自一个被称为纪元的固定日期后至今的秒数。特别地，在POSIX和Windows系统中国这个固定日期均是Jan 01,1970,0:00 UTC。<br>Lua语言针对日期和时间提供的第2中表示方式是一个表。日期表具有以下几个重要的字段：year、month、day、hour、min、sec、wday、yady和isdst，除isdst以外的所有字段均为整型值。前6个字段的含义非常明显，而wday字段表示本周中的第几天（第1天为星期天）；yday表示当年中的第几天（第1天是1月1日）；isdst字段表示布尔类型，如果使用夏时令则为真。例如，Sep 16,1998,23:48:10（星期三）对应的表是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = <span class="number">1998</span>,month = <span class="number">9</span>,day = <span class="number">16</span>,yday = <span class="number">259</span>,wday = <span class="number">4</span>,hour = <span class="number">23</span>,<span class="built_in">min</span> = <span class="number">48.</span>sec = <span class="number">10</span>,isdst = <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>日期表中不包括时区，程序需要负责结合相应的时区对其正确解析。</p>
<h2 id="函数os-time-1"><a href="#函数os-time-1" class="headerlink" title="函数os.time"></a>函数os.time</h2><p>不带任何参数调用函数os.time,会以数字形式返回当前的日期和时间：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>()	    <span class="number">1587123725</span></span><br></pre></td></tr></table></figure>
<p>对应的时间是April 17,2020,19:42:05。在一个POSIX系统中，可以使用一些基本的数字运算分离这个数字：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">date</span> = <span class="number">1587123725</span></span><br><span class="line"><span class="keyword">local</span> day2year = <span class="number">265.242</span>			 一年的天数</span><br><span class="line"><span class="keyword">local</span> sec2hour = <span class="number">60</span> * <span class="number">60</span>			 一小时的秒数</span><br><span class="line"><span class="keyword">local</span> sec2day  = sec2hour * <span class="number">24</span>       一天的秒数</span><br><span class="line"><span class="keyword">local</span> sec2year = sec2day * day2year  一年的秒数</span><br><span class="line"></span><br><span class="line"> 年</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> // sec2year + <span class="number">1970</span>)</span><br><span class="line"></span><br><span class="line"> 小时</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> % sec2day // sec2hour)</span><br><span class="line"></span><br><span class="line"> 分钟</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> % sec2hour // <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"> 秒</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">date</span> % <span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p>如果以一个日期表作为参数调用os.time，那么改函数会返回该表中所描述日期和时间对应的数字。year、month和day字段是必需的，hour、min和sec字段如果没有提供的话则默认为12:00:00，其余字段则会被忽略。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2020</span>,month = <span class="number">4</span>,day = <span class="number">17</span>,hour = <span class="number">19</span>,<span class="built_in">min</span> = <span class="number">42</span>,sec = <span class="number">5</span>&#125;)		 <span class="number">1587123725</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">1970</span>,month = <span class="number">1</span>,day = <span class="number">1</span>, hour = <span class="number">0</span>&#125;)							 <span class="number">10800</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">1970</span>,month = <span class="number">1</span>,day = <span class="number">1</span>, hour = <span class="number">0</span>,sec = <span class="number">1</span>&#125;)					 <span class="number">10801</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">1970</span>,month = <span class="number">1</span>,day = <span class="number">1</span>&#125;)									 <span class="number">54000</span></span><br></pre></td></tr></table></figure>
<p>请注意，10800是3个小时的秒数，54000则是10800加上12个小时的秒数。</p>
<h2 id="函数os-date-1"><a href="#函数os-date-1" class="headerlink" title="函数os.date"></a>函数os.date</h2><p>函数os.date在一定程度上是函数os.time的反函数，它可以将一个表示日期和时间的数字转换为某些高级的表示形式，要么是日期表要么是字符串。该函数的第1个参数是描述期望表示形式的格式化字符串，第2个参数是数字形式的日期和时间。<br>要生成一个日期表，可以使用格式化字符串”*t”。例如，调用函数os.date(“*t”,1587123725)会返回下列表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = <span class="number">2020</span>,month = <span class="number">9</span>,day = <span class="number">16</span>,yday = <span class="number">108</span>,wday = <span class="number">6</span>,hour = <span class="number">19</span>,<span class="built_in">min</span> = <span class="number">42</span>,sec = <span class="number">5</span>,isdst = <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>大致上，对于任何有效的时间t，os.time(os.date(“*t”,t)) &#x3D;&#x3D; t均成立。<br>除了isdst,结果中的其余字段均为整型数且范围分别是：</p>
<hr>
<p>year    一整年<br>month   1<del>12<br>day     1</del>31<br>hour    0<del>23<br>min     0</del>59<br>sec     0<del>60<br>wday    1</del>7<br>yday    1~366</p>
<hr>
<p>对于其他格式化字符串，函数os.date会将日期格式化为一个字符串，该字符串是根据指定的时间和日期信息对特定的指示符进行了替换的结果。所有的指示符都以百分号开头紧跟一个字母，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;a %A in %B&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%d/%m/%Y&quot;</span>,<span class="number">1587123725</span>))     <span class="number">17</span>/<span class="number">4</span>/<span class="number">2020</span></span><br></pre></td></tr></table></figure>
<p>所有的表现形式取决于当前的区域设置。<br>下表列出了主要的指示符。</p>
<hr>
<p>%a星期几的简写<br>%A星期几的全名<br>%b月份的简写<br>%B月份的全名<br>%c日期和时间<br>%d一个月中的第几天[01<del>31]<br>%H24小时制中的小时数[00</del>23]<br>%I12小时制中的小时数[01<del>12]<br>%j一年中的第几天[001</del>365]<br>%m月份[1<del>12]<br>%M分钟[0</del>59]<br>%p”am”或”pm”<br>%S秒数[0<del>60]<br>%w星期[0</del>6 &#x3D; Sunday ~ Saturday]<br>%W一年中的第几周[0<del>53]<br>%x日期<br>%X时间<br>%y两位数的年份[0</del>99]<br>%Y完整的年份<br>%z时区<br>%%百分号</p>
<hr>
<p>对于数值，表中也给出了它们的有效范围。以下是一些演示如何创建IOS 8601格式日期和时间的示例：<br>用函数os.date(“*t”,1587123725)会返回下列表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = <span class="number">2020</span>,month = <span class="number">9</span>,day = <span class="number">16</span>,yday = <span class="number">108</span>,wday = <span class="number">6</span>,hour = <span class="number">19</span>,<span class="built_in">min</span> = <span class="number">42</span>,sec = <span class="number">5</span>,isdst = <span class="literal">false</span>&#125;</span><br><span class="line">```lua</span><br><span class="line">t = <span class="number">1587123725</span>	 IOS <span class="number">8601</span>格式的日期</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%m-%d&quot;</span>,t))	 <span class="number">2020</span><span class="number">-04</span><span class="number">-17</span></span><br><span class="line"> IOS <span class="number">8601</span>格式的日期和时间</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%m-%dT%H:%M:%S&quot;</span>,t))	 <span class="number">2020</span><span class="number">-04</span><span class="number">-17</span>T19:<span class="number">42</span>:<span class="number">05</span></span><br><span class="line"> IOS <span class="number">8601</span>格式的序数日期</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%j&quot;</span>,t))			</span><br></pre></td></tr></table></figure>
<p>如果格式化字符串以叹号开头，那么函数os.date会以UTC格式对其进行解析：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 纪元</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;!%c&quot;</span>,<span class="number">0</span>))		 Zhu Jan <span class="number">1</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br></pre></td></tr></table></figure>
<p>如果不带任何参数调用函数os.date，那么该函数会使用格式%c，即以一种合理的格式表示日期和时间信息。请注意，%x、%X和%c会根据不同的区域和系统而发生变化。如果需要诸如dd&#x2F;mm&#x2F;yyyy这样的固定表示形式，那么就必须显示地使用诸如”%d&#x2F;%m&#x2F;%Y”这样的格式化字符串。</p>
<h2 id="日期和时间处理-1"><a href="#日期和时间处理-1" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><p>当函数os.date创建日期表时，该表的所有字段均在有效的范围内。当我们给函数os.time传入一个日期表时，其中的字段并不需要归一化。这个特行对于日期和时间处理非常重要。<br>举一个简单的例子，假设想知道从当前向后数40天的日期，那么可以使用如下的代码进行计算：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)		</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">04</span>/<span class="number">17</span></span><br><span class="line">t.day = t.day + <span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">05</span>/<span class="number">27</span></span><br></pre></td></tr></table></figure>
<p>如果我们把数字表示的时间转换成日期表，那么就能得到日期和时间的归一化形式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t.day,t.month)		 <span class="number">26</span> <span class="number">2</span></span><br><span class="line">t.day = t.day - <span class="number">40</span> 	</span><br><span class="line"><span class="built_in">print</span>(t.day,t.month)		 <span class="number">-14</span> <span class="number">2</span></span><br><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(t))</span><br><span class="line"><span class="built_in">print</span>(t.day,t.month)		 <span class="number">17</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在大多数系统中，也可以对数字形式的时间增加或减少34356000（40天对应的秒数）。不过，由于标准C并不要求数值表示的时间是从纪元开始的，因此标准C并不保证这种操作的正确性。此外，如果我们想增加的是月份而非天数，由于不同的月份具有不同的天数，那么直接操作秒数就会有问题。而以归一化的方式处理则没有这些问题：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)	 获取当前时间</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>.<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">04</span>/<span class="number">17</span></span><br><span class="line">t.month = t.month + <span class="number">6</span>		 从当天开始往后<span class="number">6</span>个月</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y/%m/%d&quot;</span>.<span class="built_in">os</span>.<span class="built_in">time</span>(t)))		 <span class="number">2020</span>/<span class="number">10</span>/<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>在操作日期时，我们必须要小心。虽然归一化是显而易见的方式进行的，但是也可能会有一些不明显的后果。例如，如果计算March 31之后的一个月，将会得到April 31，而实际上应该被归一化为May 1。尽管这听上去很自然，但实际上如果从结果（May 1）中减去一个月，得到的确实April 1而不是原来的March 31。请注意，这种不一致是日历机制导致的结果，与Lua语言无关。<br>函数os.difftime用来计算两个时间之间的差值，该函数以秒为单位返回两个指定数字形式表示的时间的差值。对于大多数系统而言，这个差值就是一个时间相对于另一个时间的减法结果。但是，与减法不同，函数os.difftime的行为在任何系统中都是确定的。以下示例计算了Lua5.2和Lua5.3发布时间之间间隔的天数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t5_3 = <span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2015</span>,month = <span class="number">1</span>,day = <span class="number">12</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> t5_2 = <span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2011</span>,month = <span class="number">12</span>,day = <span class="number">16</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> d = <span class="built_in">os</span>.<span class="built_in">difftime</span>(t5_3,t5_2)</span><br><span class="line"><span class="built_in">print</span>(d//(<span class="number">24</span> * <span class="number">3600</span>))     <span class="number">1123.0</span></span><br></pre></td></tr></table></figure>
<p>使用函数difftime可以获取指定日期和相对任意时刻的秒数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myepoch = <span class="built_in">os</span>.<span class="built_in">time</span>&#123;year = <span class="number">2000</span>,month = <span class="number">1</span>,day = <span class="number">1</span>,hour = <span class="number">0</span>&#125;</span><br><span class="line">now = <span class="built_in">os</span>.<span class="built_in">time</span>&#123;year = <span class="number">2015</span>,month = <span class="number">11</span>,day = <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">difftime</span>(now,myepoch)			 <span class="number">501336000.0</span></span><br></pre></td></tr></table></figure>
<p>通过归一化，可以很容易地将用秒表示的时间转换为合法的数字形式表示的时间，即我们以创建一个带有开始时刻的日期表并将日期表中的秒数设置为想要转换的数字。例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T = &#123;year = <span class="number">2000</span>,month = <span class="number">1</span>,day = <span class="number">1</span>,hour = <span class="number">0</span>&#125;</span><br><span class="line">t.sec = <span class="number">501336000</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%d/%m/%Y&quot;</span>,<span class="built_in">os</span>.<span class="built_in">time</span>(T))		 <span class="number">20</span>/<span class="number">11</span>/<span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用函数os.difftime来计算一段代码的执行时间。不过，对于这个需求更好的方式是使用函数os.clock，该函数会返回程序消耗的CPU时间（单位是秒）。函数os.clock在性能测试中的典型用法如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> x = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line"><span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">100000</span> <span class="keyword">do</span> s = s + i <span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;elapsed time: %.2f\n&quot;</span>,<span class="built_in">os</span>.<span class="built_in">clock</span>() - x))</span><br></pre></td></tr></table></figure>
<p>与函数os.time不同，函数os.clock通常具有比秒更高的精度，因此返回值为一个浮点数。具体的精度与平台相关，在POSIX系统中通常是1毫秒。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/15/Lua%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/Lua%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">Lua模式匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 14:15:06" itemprop="dateCreated datePublished" datetime="2020-04-15T14:15:06+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>与其他几种脚本语言不通，Lua语言既没有使用POSIX正则表达式，也没有使用Perl正则表达式来进行模式匹配。之所以这样做的主要原因在于大小问题：一个典型的POSIX正则表达式实现需要超过4000行代码，这比所有Lua语言标准库总大小的一半还大。相比之下，Lua语言模式匹配的实现代码只有不到600行。尽管Lua语言的欧式匹配做不到完整POSIX实现的所有功能，但是Lua语言的模式匹配仍然非常强大，同时还具有一些与标准POSIX不同但又可与之媲美的功能。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<h2 id="模式匹配的相关函数"><a href="#模式匹配的相关函数" class="headerlink" title="模式匹配的相关函数"></a>模式匹配的相关函数</h2><p>字符串标准库提供了基于模式的4个函数。我们已经初步了解过函数find和gsub，其余两个函数分别是match和gmatch。</p>
<h3 id="函数string-find"><a href="#函数string-find" class="headerlink" title="函数string.find"></a>函数string.find</h3><p>函数string.find用于在指定的目标字符串中搜索指定的模式。最简单的模式就是一个单词，它智慧匹配到这个单词本身。例如，模式’hello’会在目标自服装中所搜子串”hello”。函数string.find找到一个模式后，会返回两个值：匹配到模式开始位置的索引和结束位置的索引。如果没有找到任何匹配，则返回nil：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">i,j = <span class="built_in">string</span>.<span class="built_in">find</span>(s,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(i,j)				<span class="comment">-- 1	5</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(s,i,j)) <span class="comment">-- hello</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(s,<span class="string">&quot;world&quot;</span>))	<span class="comment">--	7	11</span></span><br><span class="line">	i,j = <span class="built_in">string</span>.<span class="built_in">find</span>(s,<span class="string">&quot;l&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(i,j)			<span class="comment">-- 3	3</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(s,<span class="string">&quot;lll&quot;</span>))		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>
<p>匹配成功后，可以以函数find返回的结果为参数调用函数string.sub来获取目标字符串匹配相应模式的子串。对于简单的模式来说，这一般就是模式本身。<br>函数string.find具有两个可选参数。第3个参数是一个索引，用于说明从目标字符串的哪个位置开始搜索。第4个参数是一个布尔值，用于说明是否进行简单搜索。所谓简单所有就是忽略模式而在目标字符串中进行单纯的“查找子字符串”的动作：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;a[word]&quot;</span>,<span class="string">&quot;[&quot;</span>)</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>:malformed pattern (missing <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">&gt; <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;a [word]&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="number">1</span>,<span class="literal">true</span>) 		<span class="comment">-- 3	3</span></span><br></pre></td></tr></table></figure>
<p>由于’[‘在模式中具有特殊含义，因此第1个函数调用会报错。在第2个函数调用中，函数只是把’[‘当作简单字符串。请注意，如果没有第3个参数，是不能传入第4个可选参数的。</p>
<h3 id="函数string-match"><a href="#函数string-match" class="headerlink" title="函数string.match"></a>函数string.match</h3><p>由于函数string.match也用于在一个字符串搜索模式，因此它与函数string.find非常相似。不过，函数string.match返回的是目标字符串中与模式相匹配的那部分子串，而非该模式所在的位置：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;hello world&quot;</span>,<span class="string">&quot;hello&quot;</span>))			<span class="comment">-- hello</span></span><br></pre></td></tr></table></figure>
<p>对于诸如’hello’这样固定的模式，使用这个函数并没有什么意义。然而，当模式是变量时，这个函数的强大之处就显现出来了。例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> = <span class="string">&quot;Today is 15/4/2020&quot;</span></span><br><span class="line">d = <span class="built_in">string</span>.<span class="built_in">match</span>(<span class="built_in">date</span>,<span class="string">&quot;%d + /%d + /%d +&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)		<span class="comment">-- 15/4/2020</span></span><br></pre></td></tr></table></figure>

<h3 id="函数string-gmatch"><a href="#函数string-gmatch" class="headerlink" title="函数string.gmatch"></a>函数string.gmatch</h3><p> 函数string.gmatch返回一个函数，通过返回的函数可以遍历一个字符串中所有出现的指定模式。例如，以下示例可以找出字符串s中出现的所有单词：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;some string&quot;</span></span><br><span class="line">words = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;%a+&quot;</span>) <span class="keyword">do</span> </span><br><span class="line">	words[#words + <span class="number">1</span>] = w</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p> 大多数模式匹配库都是用反斜杠作为转义符。然后，这种方式可能会导致一些不良的后果。对于Lua语言的解析器而言，模式仅仅是普通的字符串。模式与其他的字符串一样遵循相同的规则，并不会被特殊对待；只有模式匹配相关的函数才会把它们当做模式进行解析。由于反斜杠是Lua语言中的转义符，所以我们应该避免它传递给任何函数。模式本身就难以阅读，到处把“\”换成“\”就更加火上浇油了。<br> 我们可以使用双括号把模式括起来构成的长字符串来解决这个问题。然而，长字符串的写法对于通常比较短的模式而言又往往显得冗长。此外，我们还会失去在模式内进行转义的能力。<br> Lua语言的解决方案更加简单：Lua语言中的模式使用百分号作为转义符。总体上，所有被转义的字母都具有某些特殊含义，而所有被转移的非字母则代表其本身。<br> 我们首先来学习字符分类的模式。所谓字符分类，就是模式中能够与一个特定集合中的任意字符相匹配的一项。例如，分类%d匹配的是任意数字。因此，可以使用模式’%d%d&#x2F;%d%&#x2F;d%d%d%d’来匹配dd&#x2F;mm&#x2F;yyyy格式的日期：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Deadline is 15/04/2020, firm</span></span><br><span class="line"><span class="string">date = &quot;</span>%d%d/%d%d/%d%d%d%d<span class="string">&quot;</span></span><br><span class="line"><span class="string">print(string.match(s,date))		-- 15/04/2020</span></span><br></pre></td></tr></table></figure>
<p>下表列出了所有预置的字符串分类及其对应的含义：</p>
<hr>
<p>.					  任意字符<br>%a				  字母<br>%c				  控制字符<br>%d				  数字<br>%g				  除空格外的可打印字符	<br>%l				  小写字母<br>%p				  标点符号<br>%s				  空白字符<br>%u				  大写字母<br>%w				  字母和数字<br>%x				  十六进制数字</p>
<hr>
<p> 这些类的大写形式表示类的补集。例如，<code>%A</code>代表任意非字母的字符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello, up-down!&quot;</span>,<span class="string">&quot;%A&quot;</span>,<span class="string">&quot;.&quot;</span>))) <span class="comment">-- hello..up.down.</span></span><br></pre></td></tr></table></figure>
<p>在输出函数gsub的返回结果时，我们使用了额外的括号来丢弃第二个结果，也就是特换发生的次数。<br> 当在模式中使用时，还有一些被称为魔法字符的字符具有特殊含义。Lua语言的模式所使用的魔法字符包括：<br><code>()</code> <code>.</code> <code>%</code> <code>+</code> <code>-</code> <code>*</code> <code>?</code> <code>[</code> <code>]</code> <code>^</code> <code>$</code><br>正如我们之前已经看到的，百分号同样可以用于这些魔法字符的转义。因此，<code>%?</code>匹配一个问号，<code>%%</code>匹配一个百分号。我们不仅可以用百分号对魔法字符进行转义，还可以将其用于其他所有字母和数字外的字符。当不确定是否需要转义时，为了保险起见就可以使用转义符。<br> 可以使用字符集来创建自定义的字符分类，只需要在方括号内将单个字符和字符分类组合起来即可。例如，字符集<code>[%w_]</code>匹配所有以下画线结尾的字母和数字，<code>[01]</code>匹配二进制数字，<code>[%[%]]</code>匹配方括号。如果想要统计一段文本中元音的数量，可以使用如下的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,nvow = <span class="built_in">string</span>.<span class="built_in">gsub</span>(text,<span class="string">&quot;[AEIOUaeiou]&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>还可以在字符集中包含一段字符范围，做法是写出字符范围的第一个字符和最后一个字符并用横线将它们连接在一起。由于大多数常用的字符范围都被预先定义了，所以这个功能很少被使用。例如，<code>%d</code>相当于<code>[0,9]</code>，<code>%x</code>相当于<code>[0-9a-fA-F]</code>。不过，如果需要查找一个八进制的数字，那么使用<code>[0-7]</code>就比显示地枚举<code>[01234567]</code>强多了。<br> 在字符集前加一个补字符^就可以得到这个字符集对应的补集：模式<code>[^\n]</code>则代表除换行符以外的其他字符。尽管如此，我们还是要记得对于简单的分类来说可以使用大写形式来获得对应的补集：<code>$S</code>显然要比<code>[^%s]</code>更简单。<br> 还可以通过描述模式中重复和可选部分的修饰符来让模式更加有用。Lua语言中的模式提供了4中修饰符：</p>
<hr>
<p><code>+</code>  重复一次或多次<br><code>*</code>  重复零次或多次<br><code>-</code>  重复零次或多次（最小匹配）<br><code>?</code>  可选（出现零次或一次）</p>
<hr>
<p> 修饰符 + 匹配原始字符串分类中的一个或多个字符，它总是获取与模式相匹配的最长序列。例如，模式’%a+’代表一个或多个字母：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.gusb(<span class="string">&quot;one , and two; and three&quot;</span>, <span class="string">&quot;%a+&quot;</span>,<span class="string">&quot;word&quot;</span>)))</span><br><span class="line"><span class="comment">-- word, word word; word word</span></span><br></pre></td></tr></table></figure>
<p>模式’%d+’匹配一个或多个数字</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;the number 1298 is event&quot;</span>,<span class="string">&quot;%d+&quot;</span>))	<span class="comment">-- 1298</span></span><br></pre></td></tr></table></figure>
<p> 修饰符 * 类似于修饰符+，但是它还接受对应字符分类出现零次的情况。该修饰符一个典型的用法就是在模式的部分之间匹配可选的空格。例如，为了匹配像（）或（）这样的空括号对，就可以使用模式<code>&#39;%(%s*%)&#39;</code>，其中的<code>&#39;%s*&#39;</code>匹配零个或多个空格。另一个示例是用模式<code>&#39;[_%a][_%w]*&#39;</code>匹配Lua程序中的标识符：标识符是一个由字母或下画线开头，并紧跟零个或多个由下画线、字母或数字组成的序列。<br> 修饰符-和修饰符 * 类似，也是用于匹配原始字符分类的零次或多次出现。不过，跟修饰符 * 总是匹配能匹配的最长序列不同，修饰符-只会匹配最短序列。虽然有时它们两者并没有什么区别，但大多数情况下这两者会导致截然不同的结果。例如，当试图用模式<code>&#39;[_%a][_%w]-&#39;</code>查找标识符时，由于<code>[_%w]-</code>总是匹配空序列，所以我们只会找到第一个字母。又如，假设我们想要删掉某C语言程序中的所有注释，通常会首先尝试使用<code>&#39;/%*.*%*/&#39;</code>。然而，由于<code>&#39;.*</code>会尽可能长地匹配，因此程序中的第一个<code>&quot;/*&quot;</code>只会与最后一个<code>&quot;*/&quot;</code>相匹配：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">&quot;int x; /* x */ int y; /* y * /&quot;</span></span><br><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">gsub</span>(test,<span class="string">&quot;/%*.*%*/&quot;</span>, <span class="string">&quot;&quot;</span>)))</span><br><span class="line"><span class="comment">-- int x</span></span><br></pre></td></tr></table></figure>
<p>相反，模式’.-‘则只会匹配到找到的第一个”*&#x2F;“，这样就能得到期望的结果：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">&quot;int x; /* x */ int y; /* y * /&quot;</span></span><br><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">gsub</span>(test,<span class="string">&quot;/%*.-*%*/&quot;</span>, <span class="string">&quot;&quot;</span>)))</span><br><span class="line"><span class="comment">-- int x;	int y</span></span><br></pre></td></tr></table></figure>
<p> 最后一个修饰符？可用于匹配一个可选的字符。例如，假设我们想在一段文本中寻找一个证书，而这个证书可能包括一个可选的符号，那么就可以使用模式<code>[+-]?%d+</code>来完成这个需求，该模式可以匹配像“-12”、“23”和“+1009”这样的数字。其中字符分类<code>[+-]</code>匹配加号或减号，而其后的问号则代表这个符号是可选的。<br> 与其他系统不同的是，Lua语言中的修饰符只能作用于一个字符模式，而无法作用于一组分类。例如，我们不能写出匹配一个可选的单词的模式。通常，可以使用一些高级技巧来绕开这个限制。<br> 以补字符^开头的模式表示从目标字符串开头开始匹配。类似地，以$结尾的模式表示匹配到目标字符串的结尾。我们可以同时使用这两个标记来限制匹配查找和锚定模式。例如，如下的代码可以用来检查字符串s是否以数字开头：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">find</span>(s,<span class="string">&quot;^%d&quot;</span>) <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>
<p>如下的代码用来检查字符串是否为一个没有多余前缀字符和后缀字符的整数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">find</span>(s.<span class="string">&quot;^[+-]?%d+$&quot;</span>) <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>
<p>^和$字符只有位于模式的开头和结尾时才具有特殊含义；否则，它们仅仅就是与其身相匹配的普通字符。<br> 模式<code>%b</code>匹配成对的字符串，它的写法是<code>%bxy</code>，其中x和y是任意两个不同的字符，x作为起始符而y作为结束字符。例如，模式<code>%b()</code>匹配以左括号开始并以对应右括号结束的子串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;a (enclosed (in) parentheses line&quot;</span></span><br><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">gsub</span>（s,<span class="string">&quot;%b()&quot;</span>,<span class="string">&quot;&quot;</span>))			<span class="comment">-- a line</span></span><br></pre></td></tr></table></figure>
<p>通常，我们使用<code>%b()</code>、<code>%b[]</code>、<code>%b&#123;&#125;</code>或<code>%b&lt;&gt;</code>等作为模式，但实际上可以用任意不同的字符作为分隔符。<br> 最后，模式<code>%f[char-set]</code>代表前置模式。该模式只有在后一个字符位于char-set内而前一个字符不在时匹配一个空字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;the anthem is then theme&quot;</span></span><br><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;%f[%w]the%f[%W]&quot;</span>,<span class="string">&quot;one&quot;</span>)))			<span class="comment">-- one anthem is one theme</span></span><br></pre></td></tr></table></figure>
<p>模式<code>%f[%w]</code>匹配位于一个非字母或数字的字符和一个字母或数字的字符之间的前置，而模式<code>%f[%W]</code>则匹配一个字母或数字的字符和一个非字母或数字的字符之间的前置。因此，指定的模式只会匹配完整的字符串”the”。请注意，即使字符集只有一个分类，也必须把它用括号括起来。<br> 前置模式把目标字符串中第一个字符前和最后一个字符后的位置当成空字符。在前例中，第一个”the”在不属于集合<code>[%W]</code>的空字符和属于集合<code>[%W]</code>的t之间匹配了一个前置。</p>
<h2 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h2><p> 捕获机制允许根据一个模式从目标字符串中抽出与该模式匹配的内容来用于后续用途，可以通过把模式中需要捕获的部分放到一对圆括号内来指定捕获。<br> 对于具有捕获的模式，函数string.match会将所有捕获到的值作为单独的结果返回；换句话说，该函数将字符串切分成多个被捕获的部分：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair = <span class="string">&quot;name = Anna&quot;</span></span><br><span class="line">key,value = <span class="built_in">string</span>.<span class="built_in">match</span>(pair, <span class="string">&quot;(%a+)%s*=%s*(%a+)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(key,value)		<span class="comment">-- name Anna</span></span><br></pre></td></tr></table></figure>
<p>模式<code>%a+</code>表示一个非空的字母序列，模式<code>%s*</code>表示一个可能为空的空白序列。因此，上例中的这个模式表示一个字母序列、紧跟着空白序列、一个等号、空白序列以及另一个字母序列。模式中的两个字母系列被分别放在圆括号中，因此在匹配时就能捕获到它们。下面是一个类似的示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> = <span class="string">&quot;Today is 15/4/2020&quot;</span></span><br><span class="line">d,m,y = <span class="built_in">string</span>.<span class="built_in">match</span>(<span class="built_in">date</span>,<span class="string">&quot;(%d+)/(%d+)/(%d+)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d,m,y)		<span class="comment">-- 15 4 2020</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，使用了3个捕获，每个捕获对应一个数字序列。<br> 在模式中，形如<code>%n</code>的分类，表示匹配第n个捕获的副本。举一个典型的例子，假设想在一个字符串中寻找一个由单引号或双引号括起来的子串。那么可能会尝试使用模式’[“ ‘].-[“ ‘]’，它表示一个引号后面跟任意内容及另外一个引号；但是，这种模式在处理像”it’s all right”这样的字符串时会有问题。要解决这个问题，可以捕获第一个引号然后用它来指明第二个引号：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">[[then he said:&quot;it&#x27;s all right&quot;!]]</span></span><br><span class="line">q, quotedPart = <span class="built_in">string</span>.<span class="built_in">match</span>(s,<span class="string">&quot;([\&quot;&#x27;])(.-)%1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(quotedPart)			<span class="comment">-- it&#x27;s all right</span></span><br><span class="line"><span class="built_in">print</span>(q)					<span class="comment">-- &quot;</span></span><br></pre></td></tr></table></figure>
<p>第1个捕获是引号本身，第2个捕获是引号中的内容。<br>下例是一个类似的示例，用于匹配Lua语言中的长字符串的模式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[(=*)%[(.-)%]%<span class="number">1</span>%]</span><br></pre></td></tr></table></figure>
<p>它所匹配的内容依次是：一个左方括号、零个或多个等号、另一个左方括号、任意内容（字符串的内容）、一个右方括号、相同数量的等号及另一个右方括号：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="string">&quot;%[(=*)%[(.-)%]%1%]&quot;</span></span><br><span class="line">s = <span class="string">&quot;a = [ = [[[ something ]] ] == ] ] =];print(a)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(s,p))   <span class="comment">-- [[something]] ] == ]</span></span><br></pre></td></tr></table></figure>
<p>第1个捕获是等号序列，第2个捕获是字符串内容。<br> 被捕获对象的第3个用途是在函数gsub的替代字符串中。像模式一样，替代字符串同样可以包括像”%n”一样的字符分类，当发生替换时会被替换为相应的捕获。特别地，“%0”意味着整个匹配，并且替换字符串中的百分号必须被转义为“%%”。下面这个示例会重复字符串中的每个字母，并且在每个被重复的字母之间插入一个减号：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello Lua!&quot;</span>,<span class="string">&quot;%a&quot;</span>,<span class="string">&quot;%0-%0&quot;</span>)))		<span class="comment">-- h-he-el-ll-lo-o L-Lu-ua-a!</span></span><br></pre></td></tr></table></figure>
<p>下例交换了相邻的字符：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello Lua!&quot;</span>,<span class="string">&quot;(.)(.)&quot;</span>,<span class="string">&quot;%2%1&quot;</span>)))  <span class="comment">-- ehll ouLa	</span></span><br></pre></td></tr></table></figure>

<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p> 正如我们此前已经看到的，函数string.gsub的第3个参数不仅可以是字符串，还可以是一个函数或表。当第3个参数是一个函数时，函数string.gsub会在每次找到匹配时调用该函数，参数是捕获到的内容而返回值则被作为替换字符串。当第3个参数是一个表时，函数string.gsub会把第一个捕获到的内容作为建，然后将表中对应该键的值作为替换字符串。如果函数的返回值为nil或表中不包含这个键或表中键的对应值为nil，那么函数gsub不改变这个匹配。<br> 先举一个例子，下述函数用于变量展开，它会把字符串中所有出现的$varname替换为全局变量varname的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expand</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;$(%w+)&quot;</span>,<span class="built_in">_G</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;Lua&quot;</span>;<span class="built_in">status</span> = <span class="string">&quot;great&quot;</span></span><br><span class="line"><span class="built_in">print</span>(expand(<span class="string">&quot;$name is %status, isn&#x27;t it?&quot;</span>))	<span class="comment">-- Lua is great ,isn&#x27;t it?</span></span><br></pre></td></tr></table></figure>
<p>（_G是预先定义的包括所有全局变量的表）对于每个与<code>$(%w_)</code>匹配到的地方，函数gsub都会在全局表_G中查找捕获到的名字，并用找到的结果替换字符串中相匹配的部分；如果表中没有对应的键，则不进行替换：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(expand(<span class="string">&quot;$othername is $status, isn&#x27;t it?&quot;</span>))	<span class="comment">-- $othername is great,isn&#x27;t it?</span></span><br></pre></td></tr></table></figure>
<p>如果不确定是否制定变量具有字符串值，那么可以对它们的值调用函数tostring。在这种情况下，可以用一个函数来返回要替换的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expand</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;$(%w+)&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">tostring</span>(<span class="built_in">_G</span>[n])</span><br><span class="line">	<span class="keyword">end</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(expand(<span class="string">&quot;print = $print; a = $a&quot;</span>))		<span class="comment">-- print = function:0x8050; a = nil</span></span><br></pre></td></tr></table></figure>
<p>在函数expand中，对于所有匹配<code>$(%w+)</code>的地方，函数gsub都会调用给定的函数，传入捕获到的名字作为参数，并使用返回字符串替换匹配到的内容。</p>
<h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>我们的下一个示例中将用到URL编码，也就是HTTP所使用的在URL中传递参数的编码方式。这种编码方式会将特殊字符编码为”%xx”的形式，其中xx是对应字符的十六进制。此外，URL编码还会将空格转换为加号。例如，字符串<code>a + b = c</code>的URL编码为<code>a%2Bb+%3D+c</code>。最后，URL编码会将对参数名及其值用等号连接起来，然后将每对name &#x3D; value用&amp;连接起来。例如，值<br><code>name = &quot;al&quot;</code>;<code>query = &quot;a+b = c&quot;</code>;<code>q = &quot;yes or no&quot;</code><br>对应的URL编码为<code>name=al&amp;query=a%2Bb+%3D+c&amp;q=yes+or+no</code>。<br>现在，假设要将这个URL解码并将其中的键值对保存到一个表内，以相应的键作为索引，那么可以使用一下函数完成基本的解码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unescape</span><span class="params">(s)</span></span></span><br><span class="line">	s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;+&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">	s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;%%(%x%x)&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">(h)</span></span></span><br><span class="line">		<span class="keyword">return</span> sting.<span class="built_in">char</span>(<span class="built_in">tonumber</span>(h,<span class="number">16</span>))</span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(unescape(<span class="string">&quot;a%2Bb+%3D+c&quot;</span>))			<span class="comment">-- a + b = c</span></span><br></pre></td></tr></table></figure>
<p>第一个gsub函数将字符串中的所有加号替换为空格，第二个gsub函数则匹配所有以百分号开头的两位十六进制数，并对每处匹配调用一个匿名函数。这个匿名函数会将十六进制转换成一个数字并返回其对应的字符。<br>可以使用函数gmatch来对键值对name &#x3D; value进行解码。由于键名和值都不能包含&amp;或&#x3D;，所以可以使用模式<code>[^&amp;=]+</code>来匹配它们：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cgi = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="keyword">for</span> name, value <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s,<span class="string">&quot;([^&amp;=]+)=([^&amp;=]+)&quot;</span>) <span class="keyword">do</span></span><br><span class="line">		neme = unescape(name)</span><br><span class="line">		value = unescape(value)</span><br><span class="line">		cgi[name] = value</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用函数gmatch会匹配所有格式为name&#x3D;value的键值对。对于每组键值对，迭代器会返回对应的捕获，捕获到的内容也就是name和value的值。循环体内只是简单地对两个字符串调用函数unescape，然后将结果保存到表cgi中。<br>对应的编码函数也很容易编写。先写一个escape函数，用它将所有的特殊字符编码为百分号紧跟对应的十六进制形式，然后把空格替换成加号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function escape(s)</span><br><span class="line">	s - string.gsub(s,&quot;[&amp;=+%%%c]&quot;,function(c)</span><br><span class="line">		return string.format(&quot;%%%02X&quot;,string.byte(c))</span><br><span class="line">	end)</span><br><span class="line">	s = string.gsub(s,&quot; &quot;,&quot;+&quot;)</span><br><span class="line">	return s</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>encode函数会遍历整个待编码的表，然后构造出最终的字符串：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> b = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">		b[#b + <span class="number">1</span>] = (escape(k) .. <span class="string">&quot;=&quot;</span> .. escape(v))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">-- 将b中所有元素连接在一起，使用&quot;&amp;&quot;分隔</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">table</span>.<span class="built_in">concat</span>(b,<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;name = <span class="string">&quot;al&quot;</span>,query = <span class="string">&quot;a+b=c&quot;</span> , q = <span class="string">&quot;yes or no&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(encode(t)) 	<span class="comment">-- q = yes+or+no&amp;query=a%2Bb+%3D+c&amp;name=al</span></span><br></pre></td></tr></table></figure>

<h3 id="制表符展开"><a href="#制表符展开" class="headerlink" title="制表符展开"></a>制表符展开</h3><p>在Lua语言中，像<code>()</code>这样的空白捕获具有特殊含义。该模式并不代表捕获空内容，而是捕获模式在目标字符串中的位置：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(strig.<span class="built_in">match</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;()ll()&quot;</span>))   <span class="comment">-- 3    5</span></span><br></pre></td></tr></table></figure>
<p>另一个关于位置捕获的良好示例是在字符串中进行制表符展开：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expandTabs</span><span class="params">(s,tab)</span></span></span><br><span class="line">	tab = tab <span class="keyword">or</span> <span class="number">8</span> 	<span class="comment">-- 制表符的&quot;大小&quot;（默认是8）</span></span><br><span class="line">	<span class="keyword">local</span> corr = <span class="number">0</span> 	<span class="comment">-- 修正量</span></span><br><span class="line">	s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;()\t&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">(p)</span></span></span><br><span class="line">		<span class="keyword">local</span> sp = tab - (p - <span class="number">1</span> + corr)%tab)</span><br><span class="line">		corr = corr - <span class="number">1</span> + sp</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;&quot;</span>,sp)</span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>函数gsub会匹配字符串中所有的制表符并捕获它们的位置。对于每个制表符，匿名函数会根据其所在位置计算出需要多少个空格才能恰好凑够一列（整数个tab）：该函数先将位置减去1以从0开始计数，然后加上corr凑整之前的指标符（每一个被展开的指标符都会影响后续制表符的位置）。之后，该函数更新下一个制表符的修正量：为正在被去掉的制表符减1，再加上要增加的空格数sp。最后，这个函数返回由替代制表符的合适数量的空格组成的字符串。<br>为了完整起见，让我们再看下如何实现逆向操作，即将空格转换为制表符。第一种方法是通过空捕获来对位置进行操作，但还有一种更简单的方法：即在字符串中每隔8个字符插入一个标记，然后将前面有空格的标记替换为制表符。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unexpandTabs</span><span class="params">(s,tab)</span></span></span><br><span class="line">	tab = tab <span class="keyword">or</span> <span class="number">8</span></span><br><span class="line">	s = expandTabs(s,tab)</span><br><span class="line">	<span class="keyword">local</span> pat = <span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;.&quot;</span>,tab)			<span class="comment">-- 辅助模式</span></span><br><span class="line">	s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,pat,<span class="string">&quot;%0\1&quot;</span>)			<span class="comment">-- 在每8个字符后添加一个标记\1</span></span><br><span class="line">	s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;+\1&quot;</span>,<span class="string">&quot;\t&quot;</span>)			<span class="comment">-- 将所有以此标记结尾的空格序列都替换为制表符\t</span></span><br><span class="line">	s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;\1&quot;</span>,<span class="string">&quot;&quot;</span>)				<span class="comment">-- 将剩下的标记\1删除</span></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个函数首先对字符串进行了制表符展开以移除其中所有的制表符，然后构造出一个用于匹配所有8个字符序列的辅助模式，再利用这个模式在每8个字符后添加一个标记。接着，它将所有以此标记结尾的空格序列都替换为制表符。最后，将剩下的标记删除。</p>
<h2 id="诀窍"><a href="#诀窍" class="headerlink" title="诀窍"></a>诀窍</h2><p>模式匹配是进行字符串处理的强大工具之一。虽然通过多次调用函数string.gsub就可以完成许多复杂的操作，但是还是应该谨慎地使用函数。<br>模式匹配替代不了传统的解析器。对于那些用后即弃的程序来说，我们确实可以在源代码中做一些有用的操作，但却很难构建出高质量的产品。<br>通常，在Lua程序中使用模式匹配时的效率是足够高的，但仍然需要注意，应该永远使用尽可能的精确的模式，不精确的模式会比精确的模式慢很多。一个极端的例子是模式<code>(.-)%$</code>，它用于获取字符串中第一个$字符前的所有内容。如果目标字符串中有$符号，那么这个模式工作很正常；但是，如果字符串中没有$符号，那么匹配算法就会受限从字符串起始位置开始匹配，直至为了搜索$符号而遍历完整字符串。当到达字符串结尾时，这次从字符串起始位置开始的模式匹配就失败了。之后，模式匹配算法又从字符串的第二个位置开始第二次搜索，结果仍然是无法匹配这个模式。这个匹配过程会在字符串的每个位置上进行一次，从而导致O(n^2^)的时间复杂度。<br>此外，还要留心空模式，也就是那些匹配空字符串的模式。例如，如果试图使用模式<code>%a*</code>来匹配名字，那么 就会发现到处都是名字：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i,j = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;;$% **#$hello13&quot;</span>,<span class="string">&quot;%a*&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(i,j)			<span class="comment">-- 1   0 </span></span><br></pre></td></tr></table></figure>
<p>在这个示例汇中，函数string.find在字符串的开始位置正确地找到一个空的字母序列。<br>在模式的结束处使用修饰符-是没有意义的，因为这样只会匹配到空字符串。该修饰符总是需要在其后跟上其他的东西来限制扩展的范围。同样，含有”.*”的模式也非常容易出错，这主要是因为这种模式可能会匹配到超出我们预期范围的内容。<br>有时，用Lua语言来构造一个模式也很有用。我们已经在将空格转换为制表符的程序中使用过这个技巧。接下来再看另外一个示例，考虑如何找出一个文本中较长的行（比如超出70个字符的行）。较长的行就是一个具有70个或更多字符的序列，其中每个字符都不为换行符，因而可以使用字符分类<code>[^\n]</code>来匹配除换行符以外的其他单个字符。这样，就能够通过把这个匹配单个字符的模式重复70次来匹配较长的行。除了手写以外，还可以使用函数string.rep来创建这个模式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="built_in">string</span>.ret(<span class="string">&quot;[^\n]&quot;</span>,<span class="number">70</span> .. <span class="string">&quot;+&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>再举一个例子，假设要进行大小写无关的查找。一种方法就是将模式中的所有字母x用<code>[xX]</code>替换，即同时包含原字母大小写形式的字符分类。我们可以使用如下函数来自动地完成这种替换：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oncase</span><span class="params">(s)</span></span></span><br><span class="line">	s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;%a&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">(c)</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;[&quot;</span> .. <span class="built_in">string</span>.<span class="built_in">lower</span>(c) .. <span class="built_in">string</span>.<span class="built_in">upper</span>(c)..<span class="string">&quot;]&quot;</span></span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(nocase(<span class="string">&quot;Hi there!&quot;</span>))		<span class="comment">-- [hH][iI][tT][hH][eE][rR][eE]!</span></span><br></pre></td></tr></table></figure>
<p>有时，我们可能需要将所有出现的s1替换为s2，而不管其中是否包含魔法字符。如果字符串s1和s2是常量，那么可以在编写字符串时对魔法字符进行合理的转义；但如果字符串是一个变量，那么就需要用另一个gsub函数来进行转义：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s1,<span class="string">&quot;(%W)&quot;</span>,<span class="string">&quot;%%%1&quot;</span>)</span><br><span class="line">s2 = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s2,<span class="string">&quot;%%&quot;</span>,<span class="string">&quot;%%%%&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在进行字符串搜索时，我们对所有字母和数字外的字符进行了转义（即大写的W）。而在替换字符串中，我们只对百分号进行了转义。<br>模式匹配的另一个有用的技巧就是，在进行实际工作前对目标字符串进行预处理。假设想把一个字符串中所有被双引号(“)引起来的内容改为大写，但又允许内容中包含转义的引号(“&quot;“):</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">follows a typical <span class="built_in">string</span>:<span class="string">&quot;This is \&quot;great\&quot;!&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>处理这种情况的方法之一就是先对文本进行预处理，将所有可能导致歧义的内容编码成别的内容。例如，可以讲<code>&quot;\&quot;&quot;</code>编码成<code>&quot;\1&quot;</code>。不过，如果原文中本身就含有<code>&quot;\1&quot;</code>，那么就会遇到问题。另一种可以避免这个问题的简单做法是将所有<code>&quot;\x&quot;</code>编码为<code>&quot;\ddd&quot;</code>，其中ddd为字符x的十六进制表示形式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">code</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;\\(.)&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">(x)</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;\\%03d&quot;</span>,<span class="built_in">string</span>.<span class="built_in">byte</span>(x))</span><br><span class="line">	<span class="keyword">end</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，由于原字符串中所有的<code>&quot;\ddd&quot;</code>都进行了编码，所以编码后字符串中的<code>&quot;\ddd&quot;</code>序列一定都是编码造成的。这样，解码也就很简单了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&quot;\\(%d%d%d)&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">(d)</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;\\&quot;</span> .. <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="built_in">tonumber</span>(d))</span><br><span class="line">	<span class="keyword">end</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>现在我们就可以完成把一个字符串中被双引号(“)引起来的内容改为大写的需求。由于编码后的字符串中不包含任何转义的引号<code>(&quot;\&quot;&quot;)</code>，所以就可以直接使用<code>&quot;._&quot;</code>来查找位于一对引号中的内容：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">[[follows a typical string:&quot;This is \&quot;great\&quot;!&quot;.]]</span></span><br><span class="line">s = code(s)</span><br><span class="line">s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s,<span class="string">&#x27;&quot;.-&quot;&#x27;</span>,<span class="built_in">string</span>.<span class="built_in">upper</span>)</span><br><span class="line">s = decode(s)</span><br><span class="line"><span class="built_in">print</span>(s)	<span class="comment">-- follows a typical string:&quot;THIS IS \&quot;GREAT\&quot;!&quot;.</span></span><br></pre></td></tr></table></figure>
<p>或者写成：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(decode(<span class="built_in">string</span>.<span class="built_in">gsub</span>(code(s),<span class="string">&#x27;&quot;.-&quot;&#x27;</span>,<span class="built_in">string</span>.<span class="built_in">upper</span>)))</span><br></pre></td></tr></table></figure>
<p>是否能够将模式匹配函数用于UTF-8字符串取决于模式本身。由于UTF-8的主要特征之一就是任意字符的编码不会出现在别的字符的编码中，因此文本类的模式一般可以正常工作。字符分类和字符集只对ASCII字符有效。例如，可以对UTF-8字字符串使用模式’%s’，但它只能匹配ASCII空格，而不能匹配诸如HTML空格或蒙古文元音分隔符等其他的Uicode空格。<br>恰当的模式能够为处理Unicode带来额外的能力。一个优秀的例子是预定义模式utf8.charpattern，该模式只精确地匹配一个UTF-8字符。utf8标准库中就是按照下面的方法定义这个模式的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">utf8.charpattern = [\<span class="number">0</span>-\x7F\xC2-\xF4][\x80-\xBF]*</span><br></pre></td></tr></table></figure>
<p>该模式的第1部分匹配ASCII字符或多字节序列的其实字节。第2部分则匹配零个或多个后续的自己。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/14/Lua%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/Lua%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Lua闭包详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-14 11:28:38" itemprop="dateCreated datePublished" datetime="2020-04-14T11:28:38+08:00">2020-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Lua语言中，函数是严格遵循词法定界的第一类值。<br>“第一类值”以为这Lua语言中的函数与其他常见类型的值具有同等权限：一个程序可以将某个函数保存到变量中或表中，也可以将某个函数作为参数传递给其他函数，还可以将某个函数作为其他函数的返回值返回。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>“词法定界”意味着Lua语言中的函数可以访问包含其自身的外部函数中的变量。<br>上述两个特行联合起来为Lua语言带来了极大的灵活性。例如，一个程序可以通过重新定义函数来增加新功能，也可以通过擦除函数来为不受信任的代码创建一个安全的运行时环境。更重要的是，上述两个特行允许我们在Lua语言中使用很多函数式语言的强大编程技巧。即使对函数式编程毫无兴趣，也不妨学习下如何使用这些技巧。因为这些技巧可以使程序变得更加小巧和简单。</p>
<h2 id="函数是第一类值"><a href="#函数是第一类值" class="headerlink" title="函数是第一类值"></a>函数是第一类值</h2><p>如前所述，Lua语言中的函数是第一类值。以下的示例演示了第一类值的含义：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;p = <span class="built_in">print</span>&#125;				<span class="comment">-- &#x27;a.p&#x27;指向&#x27;print&#x27;函数</span></span><br><span class="line">a.p(<span class="string">&quot;Hello World&quot;</span>)			<span class="comment">-- HEllo World</span></span><br><span class="line"><span class="built_in">print</span> = <span class="built_in">math</span>.<span class="built_in">sin</span>			<span class="comment">-- &#x27;print&#x27;现在指向sine函数</span></span><br><span class="line">a.p(<span class="built_in">print</span>(<span class="number">1</span>))				<span class="comment">-- 0.8414709848079</span></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">sin</span> = a.p 				<span class="comment">-- &#x27;sin&#x27;现在指向print函数</span></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">10</span>,<span class="number">20</span>)				<span class="comment">-- 10	20</span></span><br></pre></td></tr></table></figure>
<p>如果函数也是值的话，那么是否有创建函数的表达式呢？答案是肯定的。事实上，Lua语言中常见的函数定义方式如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>就是所谓的语法糖的例子，它只是下面这种写法的一种美化形式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>赋值语句右边的表达式(function(x) body end)就是函数构造器，与表构造器{}相似。因此，函数定义实际上就是创建类型为”function”的值并把她赋值给一个变量的语句。<br>请注意，在Lua语言中，所有的函数都是匿名的。像其他所有的值一样，函数并没有名字。当讨论函数时，比如print，实际上指的是保存函数的变量。虽然我们通常会把函数赋值给全局变量，从而看似给函数起了一个名字，但在很多场景下仍然会保留函数的匿名性。<br>表标准库提供了函数table.sort，该函数以一个表为参数并对其中的元素排序。这种函数必须支持各种各样的排序方式：升序或降序、按数值顺序或按字母顺序、按表中的键等。函数sort并没有试图穷尽所有的排序方式，而是提供了一个可选的参数，也就是所谓的排序函数，排序函数接收两个参数并根据第一个元素是否应排在第二个元素之前返回不同的值。<br>假如，有一个如下所示的表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network = &#123;</span><br><span class="line">	&#123;name = <span class="string">&quot;grauna&quot;</span> , IP = <span class="string">&quot;210,26.30.34&quot;</span>&#125;,</span><br><span class="line">	&#123;name = <span class="string">&quot;arraial&quot;</span>, IP = <span class="string">&quot;210,26,30,23&quot;</span>&#125;,</span><br><span class="line">	&#123;name = <span class="string">&quot;lua&quot;</span>,	   IP = <span class="string">&quot;210,26,23,12&quot;</span>&#125;,</span><br><span class="line">	&#123;name = <span class="string">&quot;derain&quot;</span>,  IP = <span class="string">&quot;210,26,23,20&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想针对name字段、按字母顺序逆序对这个表排序，只需使用下面语句：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">talbe.<span class="built_in">sort</span>(network,<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span> <span class="keyword">return</span> (a.name &gt; b.name) <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>可见，匿名函数在这条语句中显示出了很好的便利性。<br>像函数sort这样以另一个函数为参数的函数，我们称之为高阶函数。高阶函数是一种强大的编程机制，而利用匿名函数作为参数正式其灵活性的主要来源。不过尽管如此，请记住高阶函数也并没有什么特殊的，它们只是Lua语言将函数作为第一类值处理所带来的直接体现。<br>为了进一步演示高阶函数的用法，让我们再来实现一个常见的高阶函数，即导数。按照通常的定义，函数f的导数为$f’(x) &#x3D; (f(x + d) - f(x))&#x2F;d$,其中d趋向于无穷小。根据这个定义，可以赢如下方式近似第计算导数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">derivative</span> <span class="params">(f,delta)</span></span></span><br><span class="line">	delta = delta <span class="keyword">or</span> <span class="number">1e-4</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span></span><br><span class="line">		<span class="keyword">return</span> (f(x + delta) - f(x))/delta</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>对于指定的函数f，调用derivative(f)将返回其导数，也就是另一个函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = derivative(<span class="built_in">math</span>.<span class="built_in">sin</span>)</span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">cos</span>(<span class="number">5.2</span>),c(<span class="number">5.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">cos</span>(<span class="number">10</span>),c(<span class="number">10</span>)) 		</span><br></pre></td></tr></table></figure>
<h2 id="非全局函数"><a href="#非全局函数" class="headerlink" title="非全局函数"></a>非全局函数</h2><p>由于函数是一种“第一类值”，因此一个显而易见的结果就是：函数不仅可以被存储在全局变量中，还可以被存储在表字段和局部变量中。<br>创建函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lib = &#123;&#125;</span><br><span class="line">Lib.foo = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span></span><br><span class="line">Lib.goo = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(Lib.foo(<span class="number">2</span>,<span class="number">3</span>),Lib.goo(<span class="number">2</span>,<span class="number">3</span>))		<span class="comment">-- 5 -1</span></span><br></pre></td></tr></table></figure>
<p>当然，也可使用表构造器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lib = &#123;</span><br><span class="line">	foo = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span></span><br><span class="line">	goo = <span class="function"><span class="keyword">function</span><span class="params">(X,y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此以外，Lua语言还提供了另一种特殊的语言来定义这类函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lib = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lib.foo</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lib.goo</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在表字段中存储函数是Lua语言中实现面向对象编程的关键要素。<br>当把一个函数存储到局部变量时，就得到一个局部函数，即一个被限定在指定作用域中使用的函数。局部函数对于包而言尤其有用：由于Lua语言将每个程序段作为一个函数处理，所以在一段程序中声明的函数就是局部函数，这些局部函数只在该程序段中可见。词法定界保证了程序段中的其他函数可以使用这些局部函数。<br>对于这种局部函数的使用，Lua语言提供了一种语法他那个：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> <span class="params">(params)</span></span></span><br><span class="line">	body</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在定义局部递归函数时，由于原来的方法不使用，所有有一点是极易出错的。考虑如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)   <span class="comment">--有问题</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当Lua语言编译函数体中的fact(n-1)调用时，局部的fact尚未定义。因此，这个表达式会尝试调用全局的fact而非局部的fact。我们可以通过先定义局部变量再定义函数的方式来解决这个问题：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact</span><br><span class="line">fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，函数内的fact指向的是局部变量。尽管在定义函数时，这个局部变量的值尚未确定，但到了执行函数时，fact肯定有了正确的赋值。<br>当Lua语言展开局部函数的语法糖时，使用的并不是之前的基本函数定义。相反，形如</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(params)</span></span> body <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>的定义会被展开成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local foo; foo = function(params) body end</span><br></pre></td></tr></table></figure>
<p>因此，使用这个语法来定义递归函数不会有问题。<br>当然，这个技巧对于简介递归函数是无效的。在间接递归的情况下，必须使用与明确的前向声明等价的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local f </span><br><span class="line"></span><br><span class="line">local function <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">	some code <span class="title function_">f</span><span class="params">()</span> some code</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">	some code <span class="title function_">g</span><span class="params">()</span> some code</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>请注意，不能在最后一个函数定义前加上local。否则，Lua语言会创建一个全新的局部变量f，从而使得先前声明的f变为未定义状态。</p>
<h2 id="词法定界"><a href="#词法定界" class="headerlink" title="词法定界"></a>词法定界</h2><p>当编写一个被其他函数B包含的函数A时，被包含的函数A可以访问包含其的函数B的所有局部变量，我们将这种特行称为词法定界。虽然这种可见性规则听上去很明确，但实际上并非如此。词法定界外加嵌套的第一类值函数可以为编程语言提供强大的功能，但很多编程语言并不支持将这两者组合使用。<br>先看一个例子。假设有一个表，其中包含了学生的姓名和对应的成绩，如果我们想基于分数对学生姓名排序，分数高者在前，那么可以使用如下的代码完成上述需求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = &#123;<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Paul&quot;</span>,<span class="string">&quot;MAry&quot;</span>&#125;</span><br><span class="line">grades = &#123;Mary = <span class="number">10</span>, Paul = <span class="number">7</span>, Peter = <span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(names,<span class="function"><span class="keyword">function</span><span class="params">(n1,n2)</span></span></span><br><span class="line">	<span class="keyword">return</span> grades[n1] &gt; grades[n2]</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>现在，假设我们想创建一个函数来完成这个需求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortbygrade</span><span class="params">(names,grades)</span></span></span><br><span class="line">	<span class="built_in">table</span>.<span class="built_in">sort</span>( names, <span class="function"><span class="keyword">function</span><span class="params">(n1,n2)</span></span></span><br><span class="line">		<span class="keyword">return</span> grades[n1] &gt; grades[n2]</span><br><span class="line">	<span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在后一个示例中，有趣的一点就在于传给函数sort的匿名函数可以访问grades,而grades是包含匿名函数的外层函数sortbygrade的形参。在该匿名函数中，grades既不是全局变量也不是局部变量，而是我们所说的非局部变量。<br>这一点之所有如此有趣是因为函数作为第一类值，能够逃逸出它们变量的原始定界范围。考虑如下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">		count = count + <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> count</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">c1 = newCounter()</span><br><span class="line"><span class="built_in">print</span>(c1())			<span class="comment">-- 1</span></span><br><span class="line">pirnt(c2())			<span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，匿名函数访问了一个非局部变量并将其当作计数器。然而，游艺创建变量的函数已经返回，因此当我们调用匿名函数时，变量count似乎已经超出了作用范围。但其实不然，由于闭包概念的存在，Lua语言能够正确地应对这种情况。简单地说，一个闭包就是一个函数外加能够使该函数正确访问非局部变量所需的其他机制。如果我们再次调用newCounter，那么一个新的局部变量count和一个新的闭包会被创建出来，这个新的闭包针对的是这个新变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c2 = newCounter()</span><br><span class="line"><span class="built_in">print</span>(c2())			<span class="comment">-- 1</span></span><br><span class="line"><span class="built_in">print</span>(c1())			<span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(c3())			<span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
<p>因此，c1和c2是不同的闭包。它们建立在相同的函数之上，但是各自拥有局部变量count的独立实例。<br>从技术上讲，Lua语言中只有闭包而没有函数。函数本身只是闭包的一种原型。不过尽管如此，只要不会引起混淆，我们就仍将使用术语“函数”来指代闭包。<br>闭包在许多场合中均是一种有价值的工具。闭包在作为诸如sort这样的高阶函数的参数时就非常有用。同样，闭包对于那些创建了其他函数的函数也很有用。这种机制使得Lua程序能够综合运用函数式编程世界中多种精妙的编程技巧。另外，闭包对于回调函数来说也很有用。对于回调函数而言，一个典型的例子就是在传统GUI工具箱中创建按钮。每个按钮通常都对应一个回调函数，当用户按下按钮时，完成不同的处理动作的回调函数就会被调用。<br>例如，假设有一个具有10个类似按钮的数字计算器，我们就可以使用如下的函数来创建这些按钮：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">digitButton</span><span class="params">(digit)</span></span></span><br><span class="line">	<span class="keyword">return</span> Button&#123; label = <span class="built_in">tostring</span>(digit),</span><br><span class="line">		action = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">			add_to_display(digit)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，假设Button是一个创建新按钮的工具箱函数，label是按钮的标签，action是当按钮按下时被调用的回调函数。回调可能发生在函数digitButton早已执行完后，那时变量digit已经超出了作用范围，但闭包仍可以访问它。<br>闭包在另一种很不一样的场景下也非常有用。由于函数可以保存在普通变量中，因此在Lua语言中可以轻松地重新定义函数，甚至是预定义函数。这种机制也正是Lua语言灵活的原因之一。通常，当重新定义一个函数的时候，我们需要在新的实现中调用原来的那个函数。例如，假设要重新定义函数sin以使其参数以角度为单位而不是以弧度为单位。那么这个新函数就可以先对参数进行转换，然后再调用原来的sin函数进行真正的计算。代码可能形如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> oldSin - <span class="built_in">math</span>.<span class="built_in">sin</span> </span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">sin</span> = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="keyword">return</span> oldSin(x * (<span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">180</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>另一种更清晰一点的完成重新定义的写法是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> oldSin = <span class="built_in">math</span>.<span class="built_in">sin</span> </span><br><span class="line">	<span class="keyword">local</span> k = <span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">180</span></span><br><span class="line">	<span class="built_in">math</span>.<span class="built_in">sin</span> = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span></span><br><span class="line">		<span class="keyword">return</span> oldSin(x * k)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述代码使用了do代码段来限制局部变量oldSin的作用范围；根据可见性规则，局部变量oldSin只在这部分代码段中有效。因此，只有新版本的函数sin才能访问原来的sin函数，其他部分的代码则访问不了。<br>我们可以使用同样的技巧来创建安全的运行时环境，即所谓的沙盒。当执行一些诸如从远程服务器上下载到的未受信任代码时，安全的运行时环境非常重要。例如，我们可以通过使用闭包重定义函数io.open来限制一个程序能够访问的文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">local</span> oldOpen = <span class="built_in">io</span>.<span class="built_in">open</span></span><br><span class="line">	<span class="keyword">local</span> access_OK - <span class="function"><span class="keyword">function</span> <span class="params">(filename, mode)</span></span></span><br><span class="line">		check access </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">open</span> = <span class="function"><span class="keyword">function</span> <span class="params">(filename ,mode)</span></span></span><br><span class="line">		<span class="keyword">if</span> access_OK(filename, mode) <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">return</span> oldOpen(filename,mode)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;access denied&quot;</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述示例的巧妙之处在于，在经过重新定义后，一个程序就只能通过新的受限版本来调用原来未受限版本的io.open函数。示例代码将原来不安全的版本保存为闭包的一个私有变量，该变量无法从外部访问。通过这一技巧，就可以在保证简洁性和灵活性的前提下在Lua语言本身上构建Lua沙盒。相对于提供一套大而全的解决方案，Lua语言提供的是一套“元机制”，借助这种机制可以根据特定的安全需求来裁剪具体的运行时环境。</p>
<h2 id="小试函数式编程"><a href="#小试函数式编程" class="headerlink" title="小试函数式编程"></a>小试函数式编程</h2><p>这里，我们的目标就是开发一个用来表示几何区域的系统，其中区域即为点的几何。我们希望能够利用该系统表示各种各样的图形，同时可以通过多种方式组合和修改这些图形。<br>为了实现这样的一个系统，首先需要找到表示这些图形的合理数据结构。我们可以尝试着使用面向对象的方案，利用继承来抽象某些图形；或者，也可以直接利用特征函数来进行更高层次的抽象。鉴于一个几何区域就是点的集合，因此可以通过特征函数来表示一个区域，即可以提供一个点并根据点是否属于指定区域而返回真或假的函数来表示一个区域。<br>举例来说，下面的函数表示一个点(1.0,3.0)为圆心、半径4.5的圆盘：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disk1</span><span class="params">(x,y)</span></span></span><br><span class="line">	<span class="keyword">return</span> (x - <span class="number">1.0</span>)^<span class="number">2</span> + (y - <span class="number">3.0</span>)^<span class="number">2</span> &lt;= <span class="number">4.5</span>^<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>利用高阶函数和词法定界，可以很容易地定义一个根据指定的圆心和半径创建圆盘的工厂：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disk</span><span class="params">(cx,cy,r)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span></span><br><span class="line">		<span class="keyword">return</span> (x - cx)^<span class="number">2</span> + (y - cy)^<span class="number">2</span> &lt;= r^<span class="number">2</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>形如disk(1.0,3.0,4.5)的调用会创建一个与disk1等价的圆盘。<br>下面的函数创建了一个指定边界的轴对称矩形：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rect</span><span class="params">(left,right,bottom,up)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span></span><br><span class="line">		<span class="keyword">return</span> left &lt;= x <span class="keyword">and</span> x &lt;= right <span class="keyword">and</span> bottom &lt;= y <span class="keyword">and</span> y &lt;= up</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>按照类似的方式，可以定义函数以创建诸如三角形或非轴承矩形等其他基本图形。每一种图形都具有完全独立的实现，所需的仅仅是一个正确的特征函数。<br>接下来让我们考虑一下如何改变和组合区域。我们可以很容易地创建任何区域的补集：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complement</span><span class="params">(r)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">not</span> r(x,y)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>并集、交集和差集也很简单。</p>
<blockquote>
<p>示例 区域的并集、交集和差集</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span> <span class="params">(r1,r2)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span></span><br><span class="line">		<span class="keyword">return</span> r1(x,y) <span class="keyword">or</span> r2(x,y)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span> <span class="params">(r1,r2)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span></span><br><span class="line">		<span class="keyword">return</span> r1(x,y) <span class="keyword">and</span> r2(x,y)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span> <span class="params">(r1,r2)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span></span><br><span class="line">		<span class="keyword">return</span> r1(x,y) <span class="keyword">and</span> <span class="keyword">not</span> r2(x,y)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>以下函数按照指定的增量平移指定的区域：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span><span class="params">(r,dx,dy)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span></span><br><span class="line">		<span class="keyword">return</span> r(x - dx, y -dy)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>为了使一个区域可视化，我们可以遍历每个像素进行视口测试；位于区域内的像素被绘制成黑色，而位于区域外的像素被绘制成白色。为了用简单的方式演示这个过程，我们接下来写一个函数来生成一个PBM格式的文件来绘制指定的区域。<br>PBM文件的结构很简单。PBM文件的文本形式以字符串”P1”开头，接下来的一行是图片的宽和高，然后是对应每一个像素、由1和0组成的数字序列，最后是EOF。</p>
<blockquote>
<p>示例 在PBM文件中绘制区域</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plot</span><span class="params">(r,M,N)</span></span></span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;P1\n&quot;</span>,M,<span class="string">&quot; &quot;</span>,N,<span class="string">&quot;\n&quot;</span>)		<span class="comment">-- 文件头</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> y = (N - i*<span class="number">2</span>)/N</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">local</span> x = (j*<span class="number">2</span> - M)/M</span><br><span class="line">			<span class="built_in">io</span>.<span class="built_in">write</span>(r(x,y) <span class="keyword">and</span> <span class="string">&quot;1&quot;</span> <span class="keyword">or</span> <span class="string">&quot;0&quot;</span>)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>为了让示例更加完整，一下的代码绘制了一个南半球所能看到的娥眉月：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = disk(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plot(difference(c1,translate(c1,<span class="number">0.3</span>,<span class="number">0</span>)),<span class="number">500</span>,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/13/Lua%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/13/Lua%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Lua的控制结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-13 21:02:21" itemprop="dateCreated datePublished" datetime="2020-04-13T21:02:21+08:00">2020-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言提供了一组精简且常用的控制结构，包括用于条件执行的if以及用户循环的while、repeat和for。所有的控制结构语法上都有一个显示的终结符：end用于终结if、for及while结构，until用于终结repeat结构。</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>控制结构的条件表达式的结果可以是任何值。Lua语言将所有不是false和nil的值当做真。</p>
<h3 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if then else"></a>if then else</h3><p>if 语句先测试其条件，并根据条件是否满足执行相应的then部分或else部分。else部分是可选的。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a&lt;<span class="number">0</span> <span class="keyword">then</span> a == <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt;b <span class="keyword">then</span> <span class="keyword">return</span> a <span class="keyword">else</span> <span class="keyword">return</span> b <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> line &gt; MAXLINES <span class="keyword">then</span></span><br><span class="line">	showpage()</span><br><span class="line">	line = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果要编写嵌套的if语句，可以使用elseif。它类似于在else后面紧跟一个if，但可以避免重复使用end：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span> <span class="keyword">then</span></span><br><span class="line">	r = a + b</span><br><span class="line"><span class="keyword">elseif</span> op == <span class="string">&quot;-&quot;</span> <span class="keyword">then</span></span><br><span class="line">	r = a - b</span><br><span class="line"><span class="keyword">elseif</span> op == <span class="string">&quot;*&quot;</span> <span class="keyword">then</span></span><br><span class="line">	r = a * b</span><br><span class="line"><span class="keyword">elseif</span> op == <span class="string">&quot;/&quot;</span> <span class="keyword">then</span></span><br><span class="line">	r = a / b</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">error</span>(<span class="string">&quot;invalid operation&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于Lua语言不支持switch语句，所以这种一连串的else-if语句比较常见。</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>当条件为真时while循环会重复执行其循环体。Lua语言先测试while语句的条件，若条件为假则循环结束；否则，Lua会执行循环体并不断地重复这个过程。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a[i] <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(a[i])</span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>repeat-until语句会重复执行其循环体知道条件为真时结束。由于条件测试在循环体之后执行，所以循环体至少会执行一次。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 输出第一个非空的行</span></span><br><span class="line"><span class="keyword">local</span> line </span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">	line = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line"><span class="keyword">until</span> line ~= <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>
<p>和大多数其他编程语言不同，在Lua语言中，循环体内声明的局部变量的作用于包括测试条件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用Newton-Raphson法计算&quot;x&quot;的平方根</span></span><br><span class="line"><span class="keyword">local</span> sqr = x / <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> </span><br><span class="line">	sqr = (sqr + x / sqr) /<span class="number">2</span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">error</span> = <span class="built_in">math</span>.<span class="built_in">abs</span>(sqr^<span class="number">2</span> - x)</span><br><span class="line"><span class="keyword">until</span> <span class="built_in">error</span> &lt; x/ <span class="number">10000</span>  <span class="comment">-- 局部变量&#x27;error&#x27;此时仍然可见</span></span><br></pre></td></tr></table></figure>

<h3 id="数值型for"><a href="#数值型for" class="headerlink" title="数值型for"></a>数值型for</h3><p>for 语句有两种形式：数值型for和泛型for。<br>数值型for的语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var = exp1 , exp2, exp3 <span class="keyword">do</span></span><br><span class="line">	something</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这种循环中，var的值从exp1变化到exp2之前的每次循环会执行something。并且在每次循环结束后将步长exp3增加到var上。第三个表达式exp3是可选的，若不存在，Lua语言会默认步长值为1.如果不想给循环设置上限，可以使用常量math.huge:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span> </span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0.3</span>*i^<span class="number">3</span> - <span class="number">20</span>*i^<span class="number">2</span> - <span class="number">500</span> &gt;= <span class="number">0</span> ) <span class="keyword">then</span></span><br><span class="line">		pirnt(i)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>为了更好地使用for循环，还需要了解一些细节。首先，在循环开始前，三个表达式都会运行一次；其次，控制变量是被for语句自动声明的局部变量，且其作用范围仅限于循环体内。一种典型的错误是认为控制变量在循环结束后仍然存在：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> , <span class="number">10</span> <span class="keyword">do</span> <span class="built_in">print</span>(i) <span class="keyword">end</span></span><br><span class="line"><span class="built_in">max</span> = i 			<span class="comment">-- 可能会出错</span></span><br></pre></td></tr></table></figure>
<p>如果需要在循环结束后使用控制变量的值，则必须将控制变量的值保存到另一个变量中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在一个列表中寻找一个值</span></span><br><span class="line"><span class="keyword">local</span> found = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> , #a <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> a[i] &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		found = i</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(found)</span><br></pre></td></tr></table></figure>
<p>最后，不要改变控制变量的值，随意改变控制变量的值可能产生不可预知的结果。如果要在循环正常结束前停止for，那么可以使用break语句。</p>
<h3 id="泛型for"><a href="#泛型for" class="headerlink" title="泛型for"></a>泛型for</h3><p>泛型for遍历迭代函数返回的所有值。例如我们已经在很多示例中看到过的pairs、ipairs和io.lines等。虽然泛型for看似简单，但它的功能非常强大。使用恰当的迭代器可以在保证代码可读性的情况下遍历几乎所有的数据结构。<br>当然，我们也可以自己编写迭代器。尽管泛型for的使用很简单，但编写迭代函数却有不少细节需要注意。<br>与数值型for不同，泛型for可以使用多个变量，这些变量在每次循环时都会更新。当第一个变量变为nil时，循环终止。像数值型for一样，控制变量时循环体中的局部变量，我们也不应该在循环中改变其值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/13/Lua%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南锋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/13/Lua%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97/" class="post-title-link" itemprop="url">Lua局部变量和代码块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-13 13:15:27" itemprop="dateCreated datePublished" datetime="2020-04-13T13:15:27+08:00">2020-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 09:53:40" itemprop="dateModified" datetime="2024-03-12T09:53:40+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua语言中的变量在默认情况下是全局变量，所有的局部变量在使用前必须声明。与全局变量不同，局部变量的生效范围仅限于声明它的代码块。一个代码块是一个控制结构的主体，或是一个函数的主体，或是一个代码段：</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3160571902547760"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3160571902547760"
     data-ad-slot="8630948880"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span> </span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span>		<span class="comment">-- 对于代码段来说是局部的</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= x <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> x = i * <span class="number">2</span>	<span class="comment">--对于循环来说是局部的</span></span><br><span class="line">	<span class="built_in">print</span>(x)		<span class="comment">-- 2,4,6...</span></span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">20</span> <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">local</span> x 			<span class="comment">-- 对于&quot;zhen&quot;来说是局部的</span></span><br><span class="line">	x = <span class="number">20</span></span><br><span class="line">	<span class="built_in">print</span>(x + <span class="number">2</span>)		<span class="comment">-- 如果测试成功会输出22</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(x)		<span class="comment">-- 10(全局的)</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>请注意，上述示例在交互模式中不能正常运行。因为在交互模式中，每一行代码就是一个代码段。一旦输入示例的第二行，Lua语言解释器就会直接运行它并在下一行开始一个新的代码段。这样，局部的声明就超出了原来的作用范围。解决这个问题的一种方式是显示地声明整个代码块，即将它放入一对do-end中。一旦输入了do，命令就只会在遇到匹配的end时才结束，这样Lua语言解释器就不会单独执行每一行的命令。<br>当需要更好地控制某些局部变量的生效范围时，do程序块也同样有用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> x1 , x2</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">local</span> a2 = <span class="number">2</span> * a2</span><br><span class="line">	<span class="keyword">local</span> d = (b^<span class="number">2</span> - <span class="number">4</span>*a*c)^(<span class="number">1</span>/<span class="number">2</span>)</span><br><span class="line">	x1 = (-b + d)/a2</span><br><span class="line">	x2 = (-b - d)/a2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(x1,x2)</span><br></pre></td></tr></table></figure>
<p>尽可能地使用局部变量是一种良好的编程风格。首先，局部变量可以避免由于不必要的命名而造成全局变量的混乱；其次，局部变量还能避免同一程序中不同代码部分中的命名冲突；再次，访问局部变量比访问全局变量更快；最后，局部变量会随着其作用域的结束儿消失，从而使得垃圾收集器能够将其释放。<br>鉴于局部变量优于全局变量，有些人就认为Lua语言应该把变量默认视为局部的。然而，把变量默认视为局部的也有一些列的问题。一个更好的解决办法并不是把变量默认视为局部变量，而是在使用变量前必须先声明。Lua语言的发型版中有一个用于全局变量检查的模块strict.lua，如果视图在一个函数中对不存在的全局变量赋值或者使用不存在的全局变量，将会抛出异常。<br>局部变量的声明可以包含初始值，其赋值规则与常见的多重赋值一样：多余的值被丢弃，多余的变量被赋值为nil。如果一个声明中没有赋值，则变量会被初始化为nil：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a , b = <span class="number">1</span> , <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a &lt; b <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(a)			<span class="comment">-- 1</span></span><br><span class="line">	<span class="keyword">local</span> a 			<span class="comment">-- &#x27;= nil&#x27; 是隐式的</span></span><br><span class="line">	<span class="built_in">print</span>(a)			<span class="comment">-- nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(a,b)				<span class="comment">-- 1, 10</span></span><br></pre></td></tr></table></figure>
<p>Lua语言中有一种常见的用法：<br><code>local foo = foo</code><br>这段代码声明了一个局部变量foo，然后用全局变量foo对其赋值。这个用法在需要提高对foo的访问速度时很有用。当其他函数改变了全局变量foo的值，而代码段又需要保留foo的原始值时，这个用法也很有用，尤其是在进行运行时动态替换时。即使其他代码把print动态替换成了而其他函数，在<code>local print = print</code>语句之前的所有代码使用的还都是原先的print函数。<br>有些人认为在代码块的中间位置声明变量时一个不好的习惯，实际上恰恰相反，我们很少会在不赋初始值的情况下声明变量，在需要时才声明变量可以避免漏掉初始化这个变量。此外，通过缩小变量的作用域还有助于提高代码的可读性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">南锋</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">168</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南锋</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
